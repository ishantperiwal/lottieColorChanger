<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lottie Color Editor with Speed Control and GIF Export</title>
  <style>
    /* General Reset and Body Styles */
  body {
    font-family: sans-serif;
    padding: 2rem;
    background: #f5f5f5;
    display: flex;
    flex-direction: row;
    gap: 2rem;
  }

  /* Layout Areas */
  #editorArea, #previewArea {
    display: flex;
    flex-direction: column;
  }

  #editorArea {
    flex: 1;
    overflow-y: auto;
    max-height: 90vh;
  }

  #previewArea {
    flex: 1.2;
    position: sticky;
    top: 2rem;
    height: fit-content;
  }

  /* Input Fields */
  input[type="file"],
  input[type="color"],
  input[type="text"],
  select {
    padding: 4px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 3px;
  }

  input[type="file"] {
    margin-bottom: 1rem;
  }

  input[type="text"],
  input[type="color"] {
    width: 80px;
  }

  /* Button Styles */
  .btn {
    padding: 0.5rem 1rem;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }

  .btn:hover {
    background-color: #45a049;
  }

  .btn--download-json {
    background-color: #2196F3;
  }

  .btn--download-gif {
    background-color: #FFC107;
  }

  /* Accordion Styles */
      span{
          font-size: 16px;
          letter-spacing: 0px;
      }

  .accordion, .gradient-accordion {
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-bottom: 1rem;
  }

  .accordion-header, .gradient-header {
    padding: 0.75rem 1rem;
    background-color: #eee;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

      .stop-row{
          display: flex;
          justify-content: space-between;
          margin-top: 12px;
          margin-bottom: 12px;
          margin-left: 12px;
          margin-right: 12px;
      }

      .color-row{
           display: flex;
          justify-content: space-between;
      }

      .gradient-preview{
         height: 20px;
          width: 100px;
         border-radius:  4px;

      }

  .accordion-body {
    padding: 1rem;
    border-top: 1px solid #ccc;
    display: none;
  }

  .accordion-group {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  /* Color Picker Rows */
  .color-picker-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.75rem;
  }

  .color-picker-row label {
    flex: 1;
    font-size: 14px;
  }

  .color-picker {
    width: 80px;
    padding: 4px;
    font-size: 14px;
  }

  .color-picker-row input[type="text"] {
    width: 90px;
  }

  /* Speed Control and Settings */
  .speed-control,
  .gif-settings {
    margin-top: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .speed-control label,
  .gif-settings label {
    font-weight: bold;
    min-width: 80px;
  }

  .speed-control input[type="range"] {
    flex: 1;
  }

  .speed-value {
    min-width: 50px;
    text-align: center;
  }

  /* Loading Spinner */
  .loading {
    display: none;
    align-items: center;
    justify-content: center;
    margin-top: 1rem;
  }

  .loading-spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    margin-right: 10px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Checkbox Styles */
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* Background Checkerboard */
  .checkerboard {
    background-image: linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                      linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                      linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                      linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  }

  #lottiePreview {
  transform: scale(0.75);
  transform-origin: center;
  margin: auto;
  /* Add these if not already present */
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible;
}

  /* Media Queries */
  @media (max-width: 768px) {
    body {
      flex-direction: column;
    }

    #editorArea, #previewArea {
      flex: none;
      width: 100%;
      margin-bottom: 1rem;
    }
  }

  /* Overlay Styles */



  .editor-section {
    width: 100%;
    height: 100% !important; /* Increase editor section height */
  }





  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .overlay-content {
    background: white;
    width: 90%;
    height: 90%;
    padding: 10px;
    border-radius: 8px;
    position: relative;

  }

  .overlay-close {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-weight: bold;
    font-size: 20px;
  }

  #customContent {
    width: 100%;
    height: calc(100% - 20px);
    border: none;
  }

  .setting-row {
    margin: 1rem 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .setting-row label {
    min-width: 160px;
  }

  .setting-row input[type="text"] {
    width: 80px;
  }


  </style>
</head>
<body>
  <div id="editorArea">
    <h2>Edit Lottie Colors</h2>
    <input type="file" id="fileInput" accept=".json" />
    <div id="colorEditor"></div>
    <div id="stopEditor"></div>

    <div class="speed-control">
      <label for="speedSlider">Animation Speed:</label>
      <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
      <span id="speedValue" class="speed-value">1.0x</span>
    </div>
    <div class="gif-settings">
      <label for="gifScale">GIF Scale:</label>
      <select id="gifScale">
        <option value="0.25">0.25x</option>
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
      </select>
    </div>


      <div class="gif-settings">
  <label>Background:</label>
  <div class="checkbox-container">
    <input type="checkbox" id="transparentBg" checked>
    <label for="transparentBg">Transparent</label>

    <!-- new: custom BG picker, starts hidden -->
    <input type="color" id="bgColorPicker" value="#ffffff"
           style="display:none; margin-left:8px;">
    <input type="text" id="bgHexInput" value="#ffffff"
           style="display:none; width:80px; margin-left:4px;">
    <button id="gifSettingsBtn" class="btn">⚙</button>
  </div>
</div>


<!-- Settings Overlay -->
<div class="overlay" id="renderSettingsOverlay">
  <div class="overlay-content" style="width:400px;">
    <span class="overlay-close">&times;</span>
    <h3>GIF Render Settings</h3>

    <div class="setting-row">
      <label>Transparency Key Color:</label>
      <input type="color" id="keyColor" value="#000000">
      <input type="text" id="keyHex" value="#000000">
    </div>

    <div class="setting-row">
      <label>Replacement Color:</label>
      <input type="color" id="replaceColor" value="#010101">
      <input type="text" id="replaceHex" value="#010101">
    </div>

    <button onclick="closeSettings()" class="btn">Save</button>
  </div>
</div>


    <div class="button-group">
      <button id="downloadJsonBtn" style="display:none;">Download JSON</button>
      <button id="downloadGifBtn" style="display:none;">Download GIF</button>
    </div>
    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <span>Generating GIF...</span>
    </div>
  </div>
  <div id="gifContainer" style="position:absolute; top:-9999px; left:-9999px; width:0; height:0; overflow:hidden"></div>
  <div id="previewArea">
    <h2>Live Preview<button id="openOverlayBtn" class="btn" style="margin-left: 10px; opacity: 20%;" disabled>Edit</button></h2>
    <div id="lottiePreview" class="checkerboard"></div>
  </div>
  <div class="overlay" id="customOverlay">
    <div class="overlay-content">
      <span class="overlay-close">&times;</span>

      <div class="editor-section">
        <iframe id="customContent"></iframe>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script>
    let lottieData;
    let colorRefs = [];
    let animationInstance;
    let currentSpeed = 1.0;
    let originalFrameRate;
    let animWidth, animHeight; // Store animation dimensions

    let keyColor = '#000000';
    let replaceColor = '#010101';


    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [
        ((bigint >> 16) & 255) / 255,
        ((bigint >> 8) & 255) / 255,
        (bigint & 255) / 255
      ];
    }

    function findColors(obj, path = []) {
      if (Array.isArray(obj)) {
        obj.forEach((item, i) => findColors(item, [...path, i]));
      } else if (typeof obj === 'object' && obj !== null) {
        if (
          obj.hasOwnProperty('c') &&
          obj.c.hasOwnProperty('k') &&
          Array.isArray(obj.c.k) &&
          obj.c.k.length >= 3 &&
          obj.c.k.length <= 4
        ) {
          colorRefs.push({
            path: [...path, 'c', 'k'],
            original: obj.c.k
          });
        }
        for (let key in obj) {
          findColors(obj[key], [...path, key]);
        }
      }
    }

    function getValueByPath(obj, path) {
      return path.reduce((acc, key) => acc[key], obj);
    }

    function setValueByPath(obj, path, newValue) {
      const lastKey = path[path.length - 1];
      const target = path.slice(0, -1).reduce((acc, key) => acc[key], obj);
      target[lastKey] = newValue;
    }

    function updateColor(ref, newHex) {
      const rgb = hexToRgb(newHex);
      const currentAlpha = getValueByPath(lottieData, ref.path)[3] ?? 1;
      const finalColor = [...rgb, currentAlpha];
      setValueByPath(lottieData, ref.path, finalColor);
      reloadLottiePreview();
    }

   function renderColorPickers() {
      const editor = document.getElementById('colorEditor');
      editor.innerHTML = "";
      const groupedColors = {};

      colorRefs.forEach((ref, i) => {
        const [r, g, b] = getValueByPath(lottieData, ref.path);
        const hex = rgbToHex(r, g, b);
        if (!groupedColors[hex]) groupedColors[hex] = [];
        groupedColors[hex].push({ ref, index: i });
      });

      Object.entries(groupedColors).forEach(([hex, refs]) => {
        const accordion = document.createElement("div");
        accordion.className = "accordion";

        const header = document.createElement("div");
        header.className = "accordion-header";

        const headerContent = document.createElement("div");
        headerContent.style.display = 'flex';
        headerContent.style.justifyContent = 'space-between';
        headerContent.style.width = '100%';
        headerContent.style.alignItems = 'center';


        const title = document.createElement("span");
        title.textContent = `Color Group (${refs.length})`;

        const controls = document.createElement("div");
        controls.className = "accordion-header-controls";

        const groupColorInput = document.createElement("input");
        groupColorInput.type = "color";
        groupColorInput.value = hex;

        const groupHexInput = document.createElement("input");
        groupHexInput.type = "text";
        groupHexInput.value = hex;
        groupHexInput.style.width = "80px";

        controls.appendChild(groupHexInput);
        controls.appendChild(groupColorInput);

        headerContent.appendChild(title);
        headerContent.appendChild(controls);
        header.appendChild(headerContent);

        header.addEventListener("click", (e) => {
          // Check if click was on an input element
          if (e.target.closest('input[type="color"], input[type="text"]')) {
            return;
          }
          const body = header.nextElementSibling;
          body.style.display = body.style.display === "block" ? "none" : "block";
        });

        const body = document.createElement("div");
        body.className = "accordion-body";

        // Update handler for header inputs
        const handleHeaderInput = (newHex) => {
          groupColorInput.value = newHex;
          groupHexInput.value = newHex;
          refs.forEach(({ ref }) => updateColor(ref, newHex));

          // Update all child inputs
          const rows = body.querySelectorAll('.color-row');
          rows.forEach(row => {
            row.querySelector('input[type="color"]').value = newHex;
            row.querySelector('input[type="text"]').value = newHex;
          });
        };

        groupColorInput.addEventListener("input", (e) => {
          handleHeaderInput(e.target.value);
        });

        groupHexInput.addEventListener("change", (e) => {
          let newHex = e.target.value;
          if (!newHex.startsWith("#")) newHex = "#" + newHex;
          if (/^#[0-9A-F]{6}$/i.test(newHex)) {
            handleHeaderInput(newHex);
          } else {
            alert("Invalid hex code. Use format like #FF0000.");
            groupHexInput.value = hex;
          }
        });

        refs.forEach(({ ref, index }) => {
          const [r, g, b] = getValueByPath(lottieData, ref.path);
          const colorHex = rgbToHex(r, g, b);

          const row = document.createElement("div");
          row.className = "color-row";

          const label = document.createElement("label");
          label.textContent = `Color ${index + 1}`;


          const colorRowRight = document.createElement("div");
            colorRowRight.style.display = 'flex';
        colorRowRight.style.justifyContent = 'space-between';

        colorRowRight.style.gap = '0px';

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = colorHex;

          const hexInput = document.createElement("input");
          hexInput.type = "text";
          hexInput.value = colorHex;

          colorInput.addEventListener("input", (e) => {
            const newHex = e.target.value;
            hexInput.value = newHex;
            updateColor(ref, newHex);
            // Update header if all colors match
            if (body.querySelectorAll('input[type="color"]').every(input => input.value === newHex)) {
              groupColorInput.value = newHex;
              groupHexInput.value = newHex;
            }
          });

          hexInput.addEventListener("change", (e) => {
            let newHex = e.target.value;
            if (!newHex.startsWith("#")) newHex = "#" + newHex;
            if (/^#[0-9A-F]{6}$/i.test(newHex)) {
              colorInput.value = newHex;
              updateColor(ref, newHex);
              // Update header if all colors match
              if (body.querySelectorAll('input[type="text"]').every(input => input.value === newHex)) {
                groupColorInput.value = newHex;
                groupHexInput.value = newHex;
              }
            } else {
              alert("Invalid hex code. Use format like #FF0000.");
              hexInput.value = colorInput.value;
            }
          });

          row.appendChild(label);
            row.appendChild(colorRowRight);

           colorRowRight.appendChild(hexInput);
          colorRowRight.appendChild(colorInput);

          body.appendChild(row);
        });

        accordion.appendChild(header);
        accordion.appendChild(body);
        editor.appendChild(accordion);
      });

      if (colorRefs.length > 0) {
        document.getElementById("downloadJsonBtn").style.display = "inline-block";
        document.getElementById("downloadGifBtn").style.display = "inline-block";
      }

      updateDownloadButtons();
    }

    function updateDownloadButtons() {
   const hasFile = !!lottieData;              // any file loaded?
 document.getElementById('downloadJsonBtn').style.display = hasFile ? 'inline-block' : 'none';
document.getElementById('downloadGifBtn' ).style.display = hasFile ? 'inline-block' : 'none';
}


    function reloadLottiePreview() {
      if (animationInstance) animationInstance.destroy();

      // work on the master, but hand a clone to the player
      const playbackData = JSON.parse(JSON.stringify(lottieData));

      // keep frame-rate tweak, or copy it here:
      playbackData.fr = originalFrameRate * currentSpeed;

      animationInstance = lottie.loadAnimation({
        container: document.getElementById('lottiePreview'),
        renderer : 'svg',
        loop     : true,
        autoplay : true,
        animationData: playbackData     // ← clone, not the master object
      });
    }

    function replacePureBlack(obj) {
      // Convert our key/replacement colors to 0-1 range RGB arrays
      const keyRGB = hexToRgb(keyColor);
      const replaceRGB = hexToRgb(replaceColor);

      // Threshold for color matching (accounts for floating point precision)
      const COLOR_THRESHOLD = 0.01;

      function shouldReplace(r, g, b) {
        return (
          Math.abs(r - keyRGB[0]) < COLOR_THRESHOLD &&
          Math.abs(g - keyRGB[1]) < COLOR_THRESHOLD &&
          Math.abs(b - keyRGB[2]) < COLOR_THRESHOLD
        );
      }

      function processColor(colorArray) {
        const [r, g, b, a = 1] = colorArray;
        if (shouldReplace(r, g, b)) {
          return [...replaceRGB, a];
        }
        return colorArray;
      }

      // Recursive object processing
      function processObject(obj) {
        if (Array.isArray(obj)) {
          obj.forEach(processObject);
        } else if (obj && typeof obj === 'object') {
          // Solid fills/strokes
          if (obj.c?.k && Array.isArray(obj.c.k)) {
            obj.c.k = processColor(obj.c.k);
          }

          // Gradients
          if (obj.ty === 'gf' && obj.g?.k?.k) {
            const raw = obj.g.k.k;
            const stops = obj.g.p;
            const hasOpacity = raw.length === stops * 6;

            // Process color stops
            for (let i = 0; i < stops; i++) {
              const base = i * 4;
              const r = raw[base + 1];
              const g = raw[base + 2];
              const b = raw[base + 3];

              if (shouldReplace(r, g, b)) {
                raw[base + 1] = replaceRGB[0];
                raw[base + 2] = replaceRGB[1];
                raw[base + 3] = replaceRGB[2];
              }
            }

            // Process opacity stops if they exist
            if (hasOpacity) {
              const colorLen = stops * 4;
              for (let i = 0; i < stops; i++) {
                const opaBase = colorLen + i * 2;
                const r = raw[opaBase + 1];
                // No color in opacity stops, just leave as-is
              }
            }
          }

          // Recursively process all object properties
          for (const key in obj) {
            processObject(obj[key]);
          }
        }
      }

      processObject(obj);
    }

    document.getElementById('gifSettingsBtn').addEventListener('click', () => {
      // Refresh inputs with current values before showing
      document.getElementById('keyColor').value = keyColor;
      document.getElementById('keyHex').value = keyColor;
      document.getElementById('replaceColor').value = replaceColor;
      document.getElementById('replaceHex').value = replaceColor;

      document.getElementById('renderSettingsOverlay').style.display = 'flex';
    });


    function closeSettings() {
      // Update global variables with current input values
      keyColor = document.getElementById('keyColor').value;
      replaceColor = document.getElementById('replaceColor').value;
      document.getElementById('renderSettingsOverlay').style.display = 'none';
    }

    // Initialize when page loads
    initSettings();




// gif generation Code




    const transparentCheckbox = document.getElementById('transparentBg');
    const bgPicker            = document.getElementById('bgColorPicker');
    const bgHexInput          = document.getElementById('bgHexInput');

    // Show/hide the custom‐color inputs when the checkbox toggles
    function updateBgInputs() {
      if (transparentCheckbox.checked) {
        bgPicker.style.display   = 'none';
        bgHexInput.style.display = 'none';
      } else {
        bgPicker.style.display   = 'inline-block';
        bgHexInput.style.display = 'inline-block';
      }
    }
    transparentCheckbox.addEventListener('change', updateBgInputs);
    updateBgInputs();

    // Keep color picker and hex input in sync
    bgPicker.addEventListener('input', () => {
      bgHexInput.value = bgPicker.value;
    });
    bgHexInput.addEventListener('change', () => {
      if (/^#[0-9A-F]{6}$/i.test(bgHexInput.value)) {
        bgPicker.value = bgHexInput.value;
      } else {
        alert('Invalid hex. Use format like #FFCC00');
        bgHexInput.value = bgPicker.value;
      }
    });


// custom settings


function initSettings() {
  // Initialize inputs with current values
  document.getElementById('keyColor').value = keyColor;
  document.getElementById('keyHex').value = keyColor;
  document.getElementById('replaceColor').value = replaceColor;
  document.getElementById('replaceHex').value = replaceColor;

  // Add real-time sync between color pickers and hex inputs
  function createSync(colorId, hexId) {
    const colorInput = document.getElementById(colorId);
    const hexInput = document.getElementById(hexId);

    colorInput.addEventListener('input', () => {
      hexInput.value = colorInput.value;
    });

    hexInput.addEventListener('input', (e) => {
      const newVal = e.target.value.startsWith('#') ? e.target.value : `#${e.target.value}`;
      if (/^#[0-9A-F]{6}$/i.test(newVal)) {
        colorInput.value = newVal;
        hexInput.value = newVal;
      }
    });
  }

  createSync('keyColor', 'keyHex');
  createSync('replaceColor', 'replaceHex');
}




    function generateGif() {
  const loadingDiv = document.getElementById('loading');
  loadingDiv.style.display = 'flex';

  // 1. deep-clone and patch blacks
  const gifData = JSON.parse(JSON.stringify(lottieData));
  replacePureBlack(gifData);

  // 2. set up a hidden Lottie instance just for the export
  const tmpContainer = document.getElementById('gifContainer');
  tmpContainer.innerHTML = '';
  const tmpAnim = lottie.loadAnimation({
    container: tmpContainer,
    renderer: 'svg',
    loop: true,
    autoplay: false,
    animationData: gifData
  });
  tmpAnim.setSpeed(currentSpeed);
  tmpAnim.pause();

  // 3. original math for frames
  const scaleValue = parseFloat(document.getElementById('gifScale').value);
  const aspectRatio = animWidth / animHeight;
  const gifW = Math.round(400 * scaleValue);
  const gifH = Math.round(gifW / aspectRatio);
  const GIF_FPS = 30;
  const FRAME_DELAY_CS = Math.round((100 / GIF_FPS) * (1 / 0.127));
  const animDur = (lottieData.op - lottieData.ip) / originalFrameRate;
  const totalFrames = Math.min(Math.floor(animDur / currentSpeed * GIF_FPS), 500);

  const useTransparent = transparentCheckbox.checked;
   const customBgColor  = bgPicker.value;  // e.g. "#abcdef"

   // 5. build the GIF.js options
  const KEY_COLOR = parseInt(keyColor.replace('#', '0x'), 16);

const gifOpts = {
  workers:      2,
  quality:      10,
  width:        gifW,
  height:       gifH,
  workerScript: './gif.worker.js'
};

if (useTransparent) {
  // only include transparent when you want to chroma‐key
  gifOpts.transparent = KEY_COLOR;
} else {
  // only include background when you want a solid fill
  gifOpts.background = customBgColor;
}

const gif = new GIF(gifOpts);

  const svgEl = tmpContainer.querySelector('svg');

  function capture(i) {
    if (i >= totalFrames) {
      gif.on('finished', blob => {
        // cleanup
        tmpAnim.destroy();
        tmpContainer.innerHTML = '';
        loadingDiv.style.display = 'none';
        // download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'animation.gif';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
      gif.render();
      return;
    }

    // go to frame on the *temporary* instance
    const t = i / GIF_FPS;
    const frame = lottieData.ip + t * originalFrameRate * currentSpeed;
    tmpAnim.goToAndStop(frame, true);

    setTimeout(() => {
      // snapshot
      const cloneSvg = svgEl.cloneNode(true);
      cloneSvg.setAttribute('viewBox', `0 0 ${animWidth} ${animHeight}`);
      cloneSvg.setAttribute('width', gifW);
      cloneSvg.setAttribute('height', gifH);

      const canvas = document.createElement('canvas');
      canvas.width = gifW; canvas.height = gifH;
      const ctx = canvas.getContext('2d');


      if (useTransparent) {
        ctx.fillStyle = keyColor;             // the hex string is fine for fillStyle
        ctx.fillRect(0, 0, gifW, gifH);
      } else {
        ctx.fillStyle = customBgColor;
        ctx.fillRect(0, 0, gifW, gifH);
      }

      
      const data = new XMLSerializer().serializeToString(cloneSvg);
      const blob = new Blob([data], {type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);

      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img,0,0,gifW,gifH);
        URL.revokeObjectURL(url);
        gif.addFrame(canvas,{ delay: FRAME_DELAY_CS, copy: true });
        capture(i+1);
      };
      img.src = url;
    }, 100);
  }

  capture(0);
}



function rgbToHexGr(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function hexToRGBGr(hex) {
  const value = hex.replace('#', '');
  return {
    r: parseInt(value.substring(0, 2), 16),
    g: parseInt(value.substring(2, 4), 16),
    b: parseInt(value.substring(4, 6), 16),
  };
}

function renderGradientEditor() {
const container = document.getElementById('stopEditor');
container.innerHTML = ''; // Clear previous content

allGradients.forEach((gradientStops, index) => {
    const accordion = document.createElement('div');
    accordion.className = 'gradient-accordion';

    const header = document.createElement('div');
    header.className = 'gradient-header';
    header.innerHTML = `
        Gradient ${index + 1}
        <div class="gradient-preview"></div>
    `;
    const gradientPreview = header.querySelector('.gradient-preview');

    const content = document.createElement('div');
    content.className = 'gradient-content';

    gradientStops.forEach((stop, i) => {
        const row = document.createElement('div');
        row.className = 'stop-row';

        const stopRowRight = document.createElement('div');
        stopRowRight.style.display = 'flex';
        stopRowRight.style.justifyContent = 'space-between';
         stopRowRight.style.gap = '20px';


        const dot = document.createElement('div');
        dot.className = 'color-dot';
        dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a || 1})`;

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `Stop ${i + 1} (${stop.offset}%)`;

        // **Color Picker Input**
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.value = rgbToHexGr(stop.r, stop.g, stop.b);

        // **Hex Code Input**
        const hexInput = document.createElement('input');
        hexInput.type = 'text';
        hexInput.className = 'hex-input';
        hexInput.maxLength = 7;
        hexInput.placeholder = "#HEX";
        hexInput.value = rgbToHexGr(stop.r, stop.g, stop.b);

        // **Sync Changes Between Hex Input and Color Picker**
        function updateColor(hex) {
            if (/^#([0-9A-Fa-f]{6})$/.test(hex)) {
                const { r, g, b } = hexToRGBGr(hex);
                stop.r = r;
                stop.g = g;
                stop.b = b;
                dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${stop.a || 1})`;
                colorInput.value = hex;
                updateGradientPreview();
                updateLottieGradient();
            }
        }

        colorInput.addEventListener('input', (e) => {
            updateColor(e.target.value);
            hexInput.value = e.target.value;
        });

        hexInput.addEventListener('input', (e) => {
            updateColor(e.target.value);
        });

        // **Alpha Input (Opacity)**
        const alphaInput = document.createElement('input');
        alphaInput.type = 'number';
        alphaInput.min = 0;
        alphaInput.max = 1;
        alphaInput.step = 0.01;
        alphaInput.value = stop.a ?? 1;

        alphaInput.addEventListener('input', (e) => {
            stop.a = parseFloat(e.target.value);
            dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a})`;
            updateGradientPreview();
            updateLottieGradient();
        });

        row.appendChild(label);
        row.appendChild(stopRowRight);
        stopRowRight.appendChild(dot);
        stopRowRight.appendChild(alphaInput);
        stopRowRight.appendChild(hexInput);
        stopRowRight.appendChild(colorInput);


        content.appendChild(row);
    });

function updateGradientPreview() {
    const gradientStyle = `linear-gradient(to right, ${gradientStops.map(stop =>
        `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a}) ${stop.offset}%`
    ).join(', ')})`;

    gradientPreview.style.background = gradientStyle;  // Set the background as the generated gradient
}

        updateGradientPreview(); // Initialize preview on render


    header.addEventListener('click', () => {
        const isOpen = content.style.display !== 'none';
        content.style.display = isOpen ? 'none' : 'block';

        header.classList.toggle('active', !isOpen);
    });

    content.style.display = 'none';
    accordion.appendChild(header);
    accordion.appendChild(content);
    container.appendChild(accordion);
});

updateDownloadButtons();

}




let allGradients = []; // To store all gradients from the Lottie file

// Update extractGradientStops to extract all gradients
// Extract all gradient paths from the Lottie JSON
function extractGradientStops(json) {
  const gradients = [];
  const visited = new WeakSet();
  const stack = [json]; // Use stack instead of recursion

  try {
    while (stack.length > 0) {
      const obj = stack.pop();

      // Skip non-objects/already visited
      if (typeof obj !== 'object' || obj === null || visited.has(obj)) {
        continue;
      }

      visited.add(obj);

      // Process gradient fills first
      if (obj.ty === 'gf' && obj.g?.k?.k && obj.g.p) {
        const raw = obj.g.k.k;
        const stops = obj.g.p;
        const hasOpacity = raw.length === stops * 6;
        const gradient = [];

        for (let i = 0; i < stops; i++) {
          const base = i * 4;
          const offset = raw[base];
          const r = raw[base + 1] * 255;
          const g = raw[base + 2] * 255;
          const b = raw[base + 3] * 255;
          let a = 1;

          if (hasOpacity) {
            const opaBase = stops * 4 + i * 2;
            a = raw[opaBase + 1];
          }

          gradient.push({
            offset: Math.round(offset * 100),
            r: Math.round(r),
            g: Math.round(g),
            b: Math.round(b),
            a: parseFloat(a.toFixed(2)),
            _path: obj
          });
        }
        gradients.push(gradient);
      }

      // Add child nodes to stack
      for (const value of Object.values(obj)) {
        if (typeof value === 'object' && value !== null) {
          // Handle arrays efficiently
          if (Array.isArray(value)) {
            // Add array elements in reverse order to maintain processing order
            for (let i = value.length - 1; i >= 0; i--) {
              stack.push(value[i]);
            }
          } else {
            stack.push(value);
          }
        }
      }
    }

    return gradients;
  } catch (error) {
    console.error('Error extracting gradients:', error);
    return [];
  }
}
function updateLottieGradient() {
  if (!lottieData || allGradients.length === 0) return;

  allGradients.forEach(gradientStops => {
    const gradientObj = gradientStops[0]._path;      // one path per gradient
    const raw   = gradientObj.g.k.k;
    const stops = gradientObj.g.p;
    const hasOpacity = raw.length === stops * 6;
    const colourLen  = stops * 4;

    // 1. write/overwrite the colour section
    gradientStops.forEach((stop, i) => {
      const base = i * 4;
      raw[base]     = stop.offset / 100;
      raw[base + 1] = stop.r / 255;
      raw[base + 2] = stop.g / 255;
      raw[base + 3] = stop.b / 255;
    });

    // 2. write the opacity section ***only once***
    if (!hasOpacity && gradientStops.some(s => s.a !== 1)) {
      for (let i = 0; i < stops; i++) {
        raw[colourLen + i * 2]     = gradientStops[i].offset / 100;
        raw[colourLen + i * 2 + 1] = gradientStops[i].a;
      }
    } else if (hasOpacity) {
      for (let i = 0; i < stops; i++) {
        const opaBase = colourLen + i * 2;
        raw[opaBase]     = gradientStops[i].offset / 100;
        raw[opaBase + 1] = gradientStops[i].a;
      }
    }
  });

  reloadLottiePreview();   // refresh the viewer
}







    document.getElementById("fileInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          lottieData = JSON.parse(e.target.result);
          originalFrameRate = lottieData.fr; // Store original frame rate

          // Store animation dimensions
          animWidth = lottieData.w;
          animHeight = lottieData.h;

          colorRefs = [];
          findColors(lottieData);
          renderColorPickers();
          reloadLottiePreview();

          allGradients = extractGradientStops(lottieData);
          renderGradientEditor();
          updateLottieGradient();
          updateDownloadButtons(); 
          document.getElementById('openOverlayBtn').disabled = false;
          document.getElementById('openOverlayBtn').style.opacity = "1";

        } catch (err) {
          alert("Invalid Lottie JSON");
          document.getElementById('openOverlayBtn').disabled = true;
          document.getElementById('openOverlayBtn').style.opacity = "0.2";

          console.error(err);
        }
      };
      reader.readAsText(file);
    });

    function cleanForExport(obj) {
  if (Array.isArray(obj)) return obj.map(cleanForExport);

  if (typeof obj === 'object' && obj !== null) {
    const clean = {};
    for (const [k, v] of Object.entries(obj)) {
      if (k.startsWith('_') || k === 'completed' || k === '__complete') continue;
      clean[k] = cleanForExport(v);
    }
    return clean;
  }
  return obj;
}


    document.getElementById("downloadJsonBtn").addEventListener("click", () => {
      // Create optimized copy
      const exportData = cleanForExport(lottieData);        // 🧹
    exportData.fr = originalFrameRate * currentSpeed;

      // Stringify with no whitespace and minimal precision
      const jsonString = JSON.stringify(exportData, (key, value) => {
        // Round numbers to 3 decimal places to reduce size
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(3));
        }
        return value;
      });

      // Create and trigger download
      const blob = new Blob([jsonString], {
        type: "application/json",
        endings: 'transparent' // Further optimization for Blob
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "animation.min.json"; // Changed to .min.json convention
      a.style.display = 'none'; // More elegant than appending/removing

      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    });

    document.getElementById("downloadGifBtn").addEventListener("click", () => {
      generateGif();
    });

    // Speed control event handlers
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");

    speedSlider.addEventListener("input", (e) => {
      currentSpeed = parseFloat(e.target.value);
      speedValue.textContent = currentSpeed.toFixed(1) + "x";

      // Update the animation speed in real-time
      if (animationInstance) {
        animationInstance.setSpeed(currentSpeed);
      }
    });

    speedSlider.addEventListener("change", (e) => {
      // When slider is released, reload the preview with the new speed
      reloadLottiePreview();
    });


    let overlayAnimationInstance = null;

  document.getElementById('openOverlayBtn').addEventListener('click', () => {
    const overlay = document.getElementById('customOverlay');
    const iframe = document.getElementById('customContent');
    const previewContainer = document.getElementById('lottieOverlayPreview');

    // Clear previous animation if exists
    if (overlayAnimationInstance) {
      overlayAnimationInstance.destroy();
    }

    // Show overlay first
    overlay.style.display = 'flex';
    const overlayData = JSON.parse(JSON.stringify(lottieData));
    overlayData.fr = originalFrameRate * currentSpeed;
    // Render the modified Lottie animation directly in overlay
    // Create minimal custom HTML content
     iframe.src = 'overlay.html';

    // Load into ifram

    iframe.onload = () => {
     // Create clean copy of data
     const overlayData = JSON.parse(JSON.stringify(lottieData));
     overlayData.fr = originalFrameRate * currentSpeed;

     // Send to iframe
     iframe.contentWindow.postMessage({
       type: 'lottieData',
       data: overlayData
     }, '*');
   };
  });

  // Close handler remains the same
  document.querySelector('.overlay-close').addEventListener('click', () => {
    document.getElementById('customOverlay').style.display = 'none';
    if (overlayAnimationInstance) {
      overlayAnimationInstance.destroy();
      overlayAnimationInstance = null;
    }
  });


  </script>
</body>
</html>
