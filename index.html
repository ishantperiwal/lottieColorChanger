<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lottie Color Editor with Speed Control and GIF Export</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: #f5f5f5;
      display: flex;
      flex-direction: row;
      gap: 2rem;
    }
    #editorArea {
      flex: 1;
      overflow-y: auto;
      max-height: 90vh;
    }
    #previewArea {
      flex: 1.2;
      position: sticky;
      top: 2rem;
      height: fit-content;
    }
    input[type="file"] {
      margin-bottom: 1rem;
    }
    .accordion {
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
      margin-bottom: 1rem;
    }
    .accordion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      cursor: pointer;
      background-color: #eee;
      font-weight: bold;
    }
    .accordion-header-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .accordion-header input[type="text"] {
      width: 80px;
      padding: 4px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .accordion-body {
      display: none;
      padding: 1rem;
      border-top: 1px solid #ccc;
    }
    .color-row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .color-row label {
      flex: 1;
      font-size: 14px;
    }
    .color-row input[type="color"],
    .color-row input[type="text"] {
      width: 80px;
      padding: 4px;
      font-size: 14px;
    }
    .color-row input[type="text"] {
      width: 90px;
    }
    button {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 0.5rem;
    }
    button:hover {
      background-color: #45a049;
    }
    .button-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    #lottiePreview {
      width: 100%;
      max-width: 100%;
      height: 400px;
      background: transparent;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 1rem;
      overflow: hidden;
    }
    .speed-control, .gif-settings {
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .speed-control label, .gif-settings label {
      font-weight: bold;
      min-width: 80px;
    }
    .speed-control input[type="range"] {
      flex: 1;
    }
    .speed-value {
      min-width: 50px;
      text-align: center;
    }
    .loading {
      display: none;
      align-items: center;
      justify-content: center;
      margin-top: 1rem;
    }
    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Show checkerboard background pattern for transparency */
    .checkerboard {
      background-image: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                       linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                       linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                       linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
  </style>
</head>
<body>
  <div id="editorArea">
    <h2>Edit Lottie Colors</h2>
    <input type="file" id="fileInput" accept=".json" />
    <div id="colorEditor"></div>
    <div class="speed-control">
      <label for="speedSlider">Animation Speed:</label>
      <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
      <span id="speedValue" class="speed-value">1.0x</span>
    </div>
    <div class="gif-settings">
      <label for="gifScale">GIF Scale:</label>
      <select id="gifScale">
        <option value="0.25">0.25x</option>
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
      </select>
    </div>
    <div class="gif-settings">
      <label>Background:</label>
      <div class="checkbox-container">
        <input type="checkbox" id="transparentBg" checked>
        <label for="transparentBg">Transparent</label>
      </div>
    </div>
    <div class="button-group">
      <button id="downloadJsonBtn" style="display:none;">Download JSON</button>
      <button id="downloadGifBtn" style="display:none;">Download GIF</button>
    </div>
    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <span>Generating GIF...</span>
    </div>
  </div>
  <div id="previewArea">
    <h2>Live Preview</h2>
    <div id="lottiePreview" class="checkerboard"></div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script>
    let lottieData;
    let colorRefs = [];
    let animationInstance;
    let currentSpeed = 1.0;
    let originalFrameRate;
    let animWidth, animHeight; // Store animation dimensions

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [
        ((bigint >> 16) & 255) / 255,
        ((bigint >> 8) & 255) / 255,
        (bigint & 255) / 255
      ];
    }

    function findColors(obj, path = []) {
      if (Array.isArray(obj)) {
        obj.forEach((item, i) => findColors(item, [...path, i]));
      } else if (typeof obj === 'object' && obj !== null) {
        if (
          obj.hasOwnProperty('c') &&
          obj.c.hasOwnProperty('k') &&
          Array.isArray(obj.c.k) &&
          obj.c.k.length >= 3 &&
          obj.c.k.length <= 4
        ) {
          colorRefs.push({
            path: [...path, 'c', 'k'],
            original: obj.c.k
          });
        }
        for (let key in obj) {
          findColors(obj[key], [...path, key]);
        }
      }
    }

    function getValueByPath(obj, path) {
      return path.reduce((acc, key) => acc[key], obj);
    }

    function setValueByPath(obj, path, newValue) {
      const lastKey = path[path.length - 1];
      const target = path.slice(0, -1).reduce((acc, key) => acc[key], obj);
      target[lastKey] = newValue;
    }

    function updateColor(ref, newHex) {
      const rgb = hexToRgb(newHex);
      const currentAlpha = getValueByPath(lottieData, ref.path)[3] ?? 1;
      const finalColor = [...rgb, currentAlpha];
      setValueByPath(lottieData, ref.path, finalColor);
      reloadLottiePreview();
    }

    function renderColorPickers() {
      const editor = document.getElementById('colorEditor');
      editor.innerHTML = "";
      const groupedColors = {};

      colorRefs.forEach((ref, i) => {
        const [r, g, b] = getValueByPath(lottieData, ref.path);
        const hex = rgbToHex(r, g, b);
        if (!groupedColors[hex]) groupedColors[hex] = [];
        groupedColors[hex].push({ ref, index: i });
      });

      Object.entries(groupedColors).forEach(([hex, refs]) => {
        const accordion = document.createElement("div");
        accordion.className = "accordion";

        const header = document.createElement("div");
        header.className = "accordion-header";
        
        const headerContent = document.createElement("div");
        headerContent.style.display = 'flex';
        headerContent.style.justifyContent = 'space-between';
        headerContent.style.width = '100%';
        headerContent.style.alignItems = 'center';

        const title = document.createElement("span");
        title.textContent = `Color Group (${refs.length})`;

        const controls = document.createElement("div");
        controls.className = "accordion-header-controls";

        const groupColorInput = document.createElement("input");
        groupColorInput.type = "color";
        groupColorInput.value = hex;

        const groupHexInput = document.createElement("input");
        groupHexInput.type = "text";
        groupHexInput.value = hex;
        groupHexInput.style.width = "80px";

        controls.appendChild(groupColorInput);
        controls.appendChild(groupHexInput);
        headerContent.appendChild(title);
        headerContent.appendChild(controls);
        header.appendChild(headerContent);

        header.addEventListener("click", (e) => {
          // Check if click was on an input element
          if (e.target.closest('input[type="color"], input[type="text"]')) {
            return;
          }
          const body = header.nextElementSibling;
          body.style.display = body.style.display === "block" ? "none" : "block";
        });

        const body = document.createElement("div");
        body.className = "accordion-body";

        // Update handler for header inputs
        const handleHeaderInput = (newHex) => {
          groupColorInput.value = newHex;
          groupHexInput.value = newHex;
          refs.forEach(({ ref }) => updateColor(ref, newHex));
          
          // Update all child inputs
          const rows = body.querySelectorAll('.color-row');
          rows.forEach(row => {
            row.querySelector('input[type="color"]').value = newHex;
            row.querySelector('input[type="text"]').value = newHex;
          });
        };

        groupColorInput.addEventListener("input", (e) => {
          handleHeaderInput(e.target.value);
        });

        groupHexInput.addEventListener("change", (e) => {
          let newHex = e.target.value;
          if (!newHex.startsWith("#")) newHex = "#" + newHex;
          if (/^#[0-9A-F]{6}$/i.test(newHex)) {
            handleHeaderInput(newHex);
          } else {
            alert("Invalid hex code. Use format like #FF0000.");
            groupHexInput.value = hex;
          }
        });

        refs.forEach(({ ref, index }) => {
          const [r, g, b] = getValueByPath(lottieData, ref.path);
          const colorHex = rgbToHex(r, g, b);

          const row = document.createElement("div");
          row.className = "color-row";

          const label = document.createElement("label");
          label.textContent = `Color ${index + 1}`;

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = colorHex;

          const hexInput = document.createElement("input");
          hexInput.type = "text";
          hexInput.value = colorHex;

          colorInput.addEventListener("input", (e) => {
            const newHex = e.target.value;
            hexInput.value = newHex;
            updateColor(ref, newHex);
            // Update header if all colors match
            if (body.querySelectorAll('input[type="color"]').every(input => input.value === newHex)) {
              groupColorInput.value = newHex;
              groupHexInput.value = newHex;
            }
          });

          hexInput.addEventListener("change", (e) => {
            let newHex = e.target.value;
            if (!newHex.startsWith("#")) newHex = "#" + newHex;
            if (/^#[0-9A-F]{6}$/i.test(newHex)) {
              colorInput.value = newHex;
              updateColor(ref, newHex);
              // Update header if all colors match
              if (body.querySelectorAll('input[type="text"]').every(input => input.value === newHex)) {
                groupColorInput.value = newHex;
                groupHexInput.value = newHex;
              }
            } else {
              alert("Invalid hex code. Use format like #FF0000.");
              hexInput.value = colorInput.value;
            }
          });

          row.appendChild(label);
          row.appendChild(colorInput);
          row.appendChild(hexInput);
          body.appendChild(row);
        });

        accordion.appendChild(header);
        accordion.appendChild(body);
        editor.appendChild(accordion);
      });

      if (colorRefs.length > 0) {
        document.getElementById("downloadJsonBtn").style.display = "inline-block";
        document.getElementById("downloadGifBtn").style.display = "inline-block";
      }
    }

    function reloadLottiePreview() {
      if (animationInstance) animationInstance.destroy();
      
      // Create a deep copy of the lottie data for preview
      const previewData = JSON.parse(JSON.stringify(lottieData));
      
      // Apply speed adjustment if needed
      if (currentSpeed !== 1.0) {
        previewData.fr = originalFrameRate * currentSpeed;
      }
      
      // Store animation dimensions from the data
      animWidth = previewData.w;
      animHeight = previewData.h;
      
      animationInstance = lottie.loadAnimation({
        container: document.getElementById('lottiePreview'),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        animationData: previewData
      });
    }

    function createModifiedJson() {
      // Create a deep copy of the original data
      const modifiedData = JSON.parse(JSON.stringify(lottieData));
      
      // Apply the speed change to the frame rate
      if (currentSpeed !== 1.0) {
        modifiedData.fr = originalFrameRate * currentSpeed;
      }
      
      return modifiedData;
    }

 function generateGif() {
  const loadingDiv = document.getElementById('loading');
  loadingDiv.style.display = 'flex';

  const scaleValue = parseFloat(document.getElementById('gifScale').value);
  const useTransparent = document.getElementById('transparentBg').checked;

  const aspectRatio = animWidth / animHeight;
  let gifWidth = Math.round(400 * scaleValue);
  let gifHeight = Math.round(gifWidth / aspectRatio);

  const gif = new GIF({
    workers: 2,
    quality: 10,
    width: gifWidth,
    height: gifHeight,
    workerScript: './gif.worker.js',
    transparent: useTransparent ? 'rgba(0,0,0,0)' : null, // use real transparency
    background: useTransparent ? 'rgba(0,0,0,0)' : '#FFFFFF'
  });

  animationInstance.pause();
  const totalFrames = Math.min(50, Math.round(lottieData.op - lottieData.ip));
  const frameStep = (lottieData.op - lottieData.ip) / totalFrames;
  const previewContainer = document.getElementById('lottiePreview');
  const svgElement = previewContainer.querySelector('svg');

  function captureFrame(frameIndex) {
    if (frameIndex >= totalFrames) {
      gif.on('finished', function (blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'animation.gif';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        animationInstance.play();
        loadingDiv.style.display = 'none';
      });
      gif.render();
      return;
    }

    const frame = lottieData.ip + (frameIndex * frameStep);
    animationInstance.goToAndStop(frame, true);

    setTimeout(() => {
      const clonedSvg = svgElement.cloneNode(true);
      clonedSvg.setAttribute('viewBox', `0 0 ${animWidth} ${animHeight}`);
      clonedSvg.setAttribute('width', gifWidth);
      clonedSvg.setAttribute('height', gifHeight);

      const canvas = document.createElement('canvas');
      canvas.width = gifWidth;
      canvas.height = gifHeight;
      const ctx = canvas.getContext('2d');

      const svgData = new XMLSerializer().serializeToString(clonedSvg);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        URL.revokeObjectURL(url);

        const effectiveFrameRate = originalFrameRate * currentSpeed;
        const frameDelay = 1000 / effectiveFrameRate;

        gif.addFrame(canvas, { delay: frameDelay, copy: true });
        captureFrame(frameIndex + 1);
      };
      img.src = url;
    }, 100);
  }

  captureFrame(0);
}


    document.getElementById("fileInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          lottieData = JSON.parse(e.target.result);
          originalFrameRate = lottieData.fr; // Store original frame rate
          
          // Store animation dimensions
          animWidth = lottieData.w;
          animHeight = lottieData.h;
          
          colorRefs = [];
          findColors(lottieData);
          renderColorPickers();
          reloadLottiePreview();
        } catch (err) {
          alert("Invalid Lottie JSON");
          console.error(err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("downloadJsonBtn").addEventListener("click", () => {
      const modifiedData = createModifiedJson();
      const blob = new Blob([JSON.stringify(modifiedData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "updated_lottie.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
    
    document.getElementById("downloadGifBtn").addEventListener("click", () => {
      generateGif();
    });
    
    // Speed control event handlers
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");
    
    speedSlider.addEventListener("input", (e) => {
      currentSpeed = parseFloat(e.target.value);
      speedValue.textContent = currentSpeed.toFixed(1) + "x";
      
      // Update the animation speed in real-time
      if (animationInstance) {
        animationInstance.setSpeed(currentSpeed);
      }
    });
    
    speedSlider.addEventListener("change", (e) => {
      // When slider is released, reload the preview with the new speed
      reloadLottiePreview();
    });
  </script>
</body>
</html>
