<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lottie Color Editor with Speed Control and GIF Export</title>
  <style>
    /* General Reset and Body Styles */
  body {
    font-family: sans-serif;
    padding: 2rem;
    background: #f5f5f5;
    display: flex;
    flex-direction: row;
    gap: 2rem;
  }

  /* Layout Areas */
  #editorArea, #previewArea {
    display: flex;
    flex-direction: column;
  }

  #editorArea {
    flex: 1;
    overflow-y: auto;
    max-height: 90vh;
  }

  #previewArea {
    flex: 1.2;
    position: sticky;
    top: 2rem;
    height: fit-content;
  }

  /* Input Fields */
  input[type="file"],
  input[type="color"],
  input[type="text"],
  select {
    padding: 4px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 3px;
  }

  input[type="file"] {
    margin-bottom: 1rem;
  }

  input[type="text"],
  input[type="color"] {
    width: 80px;
  }

  /* Button Styles */
  .btn {
    padding: 0.5rem 1rem;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }

  .btn:hover {
    background-color: #45a049;
  }

  .btn--download-json {
    background-color: #2196F3;
  }

  .btn--download-gif {
    background-color: #FFC107;
  }

  /* Accordion Styles */
      span{
          font-size: 16px;
          letter-spacing: 0px;
      }

  .accordion, .gradient-accordion {
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-bottom: 1rem;
  }

  .accordion-header, .gradient-header {
    padding: 0.75rem 1rem;
    background-color: #eee;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

      .stop-row{
          display: flex;
          justify-content: space-between;
          margin-top: 12px;
          margin-bottom: 12px;
          margin-left: 12px;
          margin-right: 12px;
      }

      .color-row{
           display: flex;
          justify-content: space-between;
      }

      .gradient-preview{
         height: 20px;
          width: 100px;
         border-radius:  4px;

      }

  .accordion-body {
    padding: 1rem;
    border-top: 1px solid #ccc;
    display: none;
  }

  .accordion-group {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  /* Color Picker Rows */
  .color-picker-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.75rem;
  }

  .color-picker-row label {
    flex: 1;
    font-size: 14px;
  }

  .color-picker {
    width: 80px;
    padding: 4px;
    font-size: 14px;
  }

  .color-picker-row input[type="text"] {
    width: 90px;
  }

  /* Speed Control and Settings */
  .speed-control,
  .gif-settings {
    margin-top: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .speed-control label,
  .gif-settings label {
    font-weight: bold;
    min-width: 80px;
  }

  .speed-control input[type="range"] {
    flex: 1;
  }

  .speed-value {
    min-width: 50px;
    text-align: center;
  }

  /* Loading Spinner */
  .loading {
    display: none;
    align-items: center;
    justify-content: center;
    margin-top: 1rem;
  }

  .loading-spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    margin-right: 10px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Checkbox Styles */
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* Background Checkerboard */
  .checkerboard {
    background-image: linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                      linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                      linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                      linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  }

  #lottiePreview {
  transform: scale(0.75);
  transform-origin: center;
  margin: auto;
  /* Add these if not already present */
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible;
}

  /* Media Queries */
  @media (max-width: 768px) {
    body {
      flex-direction: column;
    }

    #editorArea, #previewArea {
      flex: none;
      width: 100%;
      margin-bottom: 1rem;
    }
  }

  /* Overlay Styles */



  .editor-section {
    width: 100%;
    height: 100% !important; /* Increase editor section height */
  }





  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .overlay-content {
    background: white;
    width: 90%;
    height: 90%;
    padding: 10px;
    border-radius: 8px;
    position: relative;

  }

  .overlay-close {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-weight: bold;
    font-size: 20px;
  }

  #customContent {
    width: 100%;
    height: calc(100% - 20px);
    border: none;
  }


  </style>
</head>
<body>
  <div id="editorArea">
    <h2>Edit Lottie Colors</h2>
    <input type="file" id="fileInput" accept=".json" />
    <div id="colorEditor"></div>
    <div id="stopEditor"></div>

    <div class="speed-control">
      <label for="speedSlider">Animation Speed:</label>
      <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
      <span id="speedValue" class="speed-value">1.0x</span>
    </div>
    <div class="gif-settings">
      <label for="gifScale">GIF Scale:</label>
      <select id="gifScale">
        <option value="0.25">0.25x</option>
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
      </select>
    </div>
    <div class="gif-settings">
      <label>Background:</label>
      <div class="checkbox-container">
        <input type="checkbox" id="transparentBg" checked>
        <label for="transparentBg">Transparent</label>
      </div>
    </div>
    <div class="button-group">
      <button id="downloadJsonBtn" style="display:none;">Download JSON</button>
      <button id="downloadGifBtn" style="display:none;">Download GIF</button>
    </div>
    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <span>Generating GIF...</span>
    </div>
  </div>
  <div id="previewArea">
    <h2>Live Preview<button id="openOverlayBtn" class="btn" style="margin-left: 10px; opacity: 20%;" disabled>Edit</button></h2>
    <div id="lottiePreview" class="checkerboard"></div>
  </div>
  <div class="overlay" id="customOverlay">
    <div class="overlay-content">
      <span class="overlay-close">&times;</span>

      <div class="editor-section">
        <iframe id="customContent"></iframe>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script>
    let lottieData;
    let colorRefs = [];
    let animationInstance;
    let currentSpeed = 1.0;
    let originalFrameRate;
    let animWidth, animHeight; // Store animation dimensions

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [
        ((bigint >> 16) & 255) / 255,
        ((bigint >> 8) & 255) / 255,
        (bigint & 255) / 255
      ];
    }

    function findColors(obj, path = []) {
      if (Array.isArray(obj)) {
        obj.forEach((item, i) => findColors(item, [...path, i]));
      } else if (typeof obj === 'object' && obj !== null) {
        if (
          obj.hasOwnProperty('c') &&
          obj.c.hasOwnProperty('k') &&
          Array.isArray(obj.c.k) &&
          obj.c.k.length >= 3 &&
          obj.c.k.length <= 4
        ) {
          colorRefs.push({
            path: [...path, 'c', 'k'],
            original: obj.c.k
          });
        }
        for (let key in obj) {
          findColors(obj[key], [...path, key]);
        }
      }
    }

    function getValueByPath(obj, path) {
      return path.reduce((acc, key) => acc[key], obj);
    }

    function setValueByPath(obj, path, newValue) {
      const lastKey = path[path.length - 1];
      const target = path.slice(0, -1).reduce((acc, key) => acc[key], obj);
      target[lastKey] = newValue;
    }

    function updateColor(ref, newHex) {
      const rgb = hexToRgb(newHex);
      const currentAlpha = getValueByPath(lottieData, ref.path)[3] ?? 1;
      const finalColor = [...rgb, currentAlpha];
      setValueByPath(lottieData, ref.path, finalColor);
      reloadLottiePreview();
    }

    function renderColorPickers() {
      const editor = document.getElementById('colorEditor');
      editor.innerHTML = "";
      const groupedColors = {};

      colorRefs.forEach((ref, i) => {
        const [r, g, b] = getValueByPath(lottieData, ref.path);
        const hex = rgbToHex(r, g, b);
        if (!groupedColors[hex]) groupedColors[hex] = [];
        groupedColors[hex].push({ ref, index: i });
      });

      Object.entries(groupedColors).forEach(([hex, refs]) => {
        const accordion = document.createElement("div");
        accordion.className = "accordion";

        const header = document.createElement("div");
        header.className = "accordion-header";

        const headerContent = document.createElement("div");
        headerContent.style.display = 'flex';
        headerContent.style.justifyContent = 'space-between';
        headerContent.style.width = '100%';
        headerContent.style.alignItems = 'center';


        const title = document.createElement("span");
        title.textContent = `Color Group (${refs.length})`;

        const controls = document.createElement("div");
        controls.className = "accordion-header-controls";

        const groupColorInput = document.createElement("input");
        groupColorInput.type = "color";
        groupColorInput.value = hex;

        const groupHexInput = document.createElement("input");
        groupHexInput.type = "text";
        groupHexInput.value = hex;
        groupHexInput.style.width = "80px";

        controls.appendChild(groupHexInput);
        controls.appendChild(groupColorInput);

        headerContent.appendChild(title);
        headerContent.appendChild(controls);
        header.appendChild(headerContent);

        header.addEventListener("click", (e) => {
          // Check if click was on an input element
          if (e.target.closest('input[type="color"], input[type="text"]')) {
            return;
          }
          const body = header.nextElementSibling;
          body.style.display = body.style.display === "block" ? "none" : "block";
        });

        const body = document.createElement("div");
        body.className = "accordion-body";

        // Update handler for header inputs
        const handleHeaderInput = (newHex) => {
          groupColorInput.value = newHex;
          groupHexInput.value = newHex;
          refs.forEach(({ ref }) => updateColor(ref, newHex));

          // Update all child inputs
          const rows = body.querySelectorAll('.color-row');
          rows.forEach(row => {
            row.querySelector('input[type="color"]').value = newHex;
            row.querySelector('input[type="text"]').value = newHex;
          });
        };

        groupColorInput.addEventListener("input", (e) => {
          handleHeaderInput(e.target.value);
        });

        groupHexInput.addEventListener("change", (e) => {
          let newHex = e.target.value;
          if (!newHex.startsWith("#")) newHex = "#" + newHex;
          if (/^#[0-9A-F]{6}$/i.test(newHex)) {
            handleHeaderInput(newHex);
          } else {
            alert("Invalid hex code. Use format like #FF0000.");
            groupHexInput.value = hex;
          }
        });

        refs.forEach(({ ref, index }) => {
          const [r, g, b] = getValueByPath(lottieData, ref.path);
          const colorHex = rgbToHex(r, g, b);

          const row = document.createElement("div");
          row.className = "color-row";

          const label = document.createElement("label");
          label.textContent = `Color ${index + 1}`;


          const colorRowRight = document.createElement("div");
            colorRowRight.style.display = 'flex';
        colorRowRight.style.justifyContent = 'space-between';

        colorRowRight.style.gap = '0px';

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = colorHex;

          const hexInput = document.createElement("input");
          hexInput.type = "text";
          hexInput.value = colorHex;

          colorInput.addEventListener("input", (e) => {
            const newHex = e.target.value;
            hexInput.value = newHex;
            updateColor(ref, newHex);
            // Update header if all colors match
            if (body.querySelectorAll('input[type="color"]').every(input => input.value === newHex)) {
              groupColorInput.value = newHex;
              groupHexInput.value = newHex;
            }
          });

          hexInput.addEventListener("change", (e) => {
            let newHex = e.target.value;
            if (!newHex.startsWith("#")) newHex = "#" + newHex;
            if (/^#[0-9A-F]{6}$/i.test(newHex)) {
              colorInput.value = newHex;
              updateColor(ref, newHex);
              // Update header if all colors match
              if (body.querySelectorAll('input[type="text"]').every(input => input.value === newHex)) {
                groupColorInput.value = newHex;
                groupHexInput.value = newHex;
              }
            } else {
              alert("Invalid hex code. Use format like #FF0000.");
              hexInput.value = colorInput.value;
            }
          });

          row.appendChild(label);
            row.appendChild(colorRowRight);

           colorRowRight.appendChild(hexInput);
          colorRowRight.appendChild(colorInput);

          body.appendChild(row);
        });

        accordion.appendChild(header);
        accordion.appendChild(body);
        editor.appendChild(accordion);
      });

      if (colorRefs.length > 0) {
        document.getElementById("downloadJsonBtn").style.display = "inline-block";
        document.getElementById("downloadGifBtn").style.display = "inline-block";
      }
    }

    function reloadLottiePreview() {
      if (animationInstance) animationInstance.destroy();

      // Modify original data with current speed
      lottieData.fr = originalFrameRate * currentSpeed;

      animationInstance = lottie.loadAnimation({
        container: document.getElementById('lottiePreview'),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        animationData: lottieData
      });
    }


function generateGif() {
  const loadingDiv = document.getElementById('loading');
  loadingDiv.style.display = 'flex';

  const scaleValue = parseFloat(document.getElementById('gifScale').value);
  const useTransparent = document.getElementById('transparentBg').checked;

  const aspectRatio = animWidth / animHeight;
  const gifWidth = Math.round(400 * scaleValue);
  const gifHeight = Math.round(gifWidth / aspectRatio);

  const GIF_FPS = 30;
  const PLAYBACK_MULTIPLIER = 0.127;
  const FRAME_DELAY_CS = Math.round((100 / GIF_FPS) * (1 / PLAYBACK_MULTIPLIER)); // centiseconds

  const animationDuration = (lottieData.op - lottieData.ip) / originalFrameRate;
  const adjustedDuration = animationDuration / currentSpeed;

  let totalFrames = Math.floor(adjustedDuration * GIF_FPS);
  totalFrames = Math.min(totalFrames, 500);

  const gif = new GIF({
    workers: 2,
    quality: 10,
    width: gifWidth,
    height: gifHeight,
    workerScript: './gif.worker.js',
    transparent: useTransparent ? 'rgba(0,0,0,0)' : null,
    background: useTransparent ? 'rgba(0,0,0,0)' : '#FFFFFF'
  });

  animationInstance.pause();

  const previewContainer = document.getElementById('lottiePreview');
  const svgElement = previewContainer.querySelector('svg');

  function captureFrame(frameIndex) {
    if (frameIndex >= totalFrames) {
      gif.on('finished', function (blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'animation.gif';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        animationInstance.play();
        loadingDiv.style.display = 'none';
      });
      gif.render();
      return;
    }

    const timeInAdjusted = frameIndex / GIF_FPS;
    const originalTime = timeInAdjusted * currentSpeed;
    const frame = lottieData.ip + originalTime * originalFrameRate;

    animationInstance.goToAndStop(frame, true);

    setTimeout(() => {
      const clonedSvg = svgElement.cloneNode(true);
      clonedSvg.setAttribute('viewBox', `0 0 ${animWidth} ${animHeight}`);
      clonedSvg.setAttribute('width', gifWidth);
      clonedSvg.setAttribute('height', gifHeight);

      const canvas = document.createElement('canvas');
      canvas.width = gifWidth;
      canvas.height = gifHeight;
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const svgData = new XMLSerializer().serializeToString(clonedSvg);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = function () {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        URL.revokeObjectURL(url);

        gif.addFrame(canvas, { delay: FRAME_DELAY_CS, copy: true });
        captureFrame(frameIndex + 1);
      };
      img.src = url;
    }, 100);
  }

  captureFrame(0);
}

function rgbToHexGr(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function hexToRGBGr(hex) {
  const value = hex.replace('#', '');
  return {
    r: parseInt(value.substring(0, 2), 16),
    g: parseInt(value.substring(2, 4), 16),
    b: parseInt(value.substring(4, 6), 16),
  };
}

function renderGradientEditor() {
const container = document.getElementById('stopEditor');
container.innerHTML = ''; // Clear previous content

allGradients.forEach((gradientStops, index) => {
    const accordion = document.createElement('div');
    accordion.className = 'gradient-accordion';

    const header = document.createElement('div');
    header.className = 'gradient-header';
    header.innerHTML = `
        Gradient ${index + 1}
        <div class="gradient-preview"></div>
    `;
    const gradientPreview = header.querySelector('.gradient-preview');

    const content = document.createElement('div');
    content.className = 'gradient-content';

    gradientStops.forEach((stop, i) => {
        const row = document.createElement('div');
        row.className = 'stop-row';

        const stopRowRight = document.createElement('div');
        stopRowRight.style.display = 'flex';
        stopRowRight.style.justifyContent = 'space-between';
         stopRowRight.style.gap = '20px';


        const dot = document.createElement('div');
        dot.className = 'color-dot';
        dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a || 1})`;

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `Stop ${i + 1} (${stop.offset}%)`;

        // **Color Picker Input**
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.value = rgbToHexGr(stop.r, stop.g, stop.b);

        // **Hex Code Input**
        const hexInput = document.createElement('input');
        hexInput.type = 'text';
        hexInput.className = 'hex-input';
        hexInput.maxLength = 7;
        hexInput.placeholder = "#HEX";
        hexInput.value = rgbToHexGr(stop.r, stop.g, stop.b);

        // **Sync Changes Between Hex Input and Color Picker**
        function updateColor(hex) {
            if (/^#([0-9A-Fa-f]{6})$/.test(hex)) {
                const { r, g, b } = hexToRGBGr(hex);
                stop.r = r;
                stop.g = g;
                stop.b = b;
                dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${stop.a || 1})`;
                colorInput.value = hex;
                updateGradientPreview();
                updateLottieGradient();
            }
        }

        colorInput.addEventListener('input', (e) => {
            updateColor(e.target.value);
            hexInput.value = e.target.value;
        });

        hexInput.addEventListener('input', (e) => {
            updateColor(e.target.value);
        });

        // **Alpha Input (Opacity)**
        const alphaInput = document.createElement('input');
        alphaInput.type = 'number';
        alphaInput.min = 0;
        alphaInput.max = 1;
        alphaInput.step = 0.01;
        alphaInput.value = stop.a ?? 1;

        alphaInput.addEventListener('input', (e) => {
            stop.a = parseFloat(e.target.value);
            dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a})`;
            updateGradientPreview();
            updateLottieGradient();
        });

        row.appendChild(label);
        row.appendChild(stopRowRight);
        stopRowRight.appendChild(dot);
        stopRowRight.appendChild(alphaInput);
        stopRowRight.appendChild(hexInput);
        stopRowRight.appendChild(colorInput);


        content.appendChild(row);
    });

function updateGradientPreview() {
    const gradientStyle = `linear-gradient(to right, ${gradientStops.map(stop =>
        `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a}) ${stop.offset}%`
    ).join(', ')})`;

    gradientPreview.style.background = gradientStyle;  // Set the background as the generated gradient
}

        updateGradientPreview(); // Initialize preview on render


    header.addEventListener('click', () => {
        const isOpen = content.style.display !== 'none';
        content.style.display = isOpen ? 'none' : 'block';

        header.classList.toggle('active', !isOpen);
    });

    content.style.display = 'none';
    accordion.appendChild(header);
    accordion.appendChild(content);
    container.appendChild(accordion);
});
}




let allGradients = []; // To store all gradients from the Lottie file

// Update extractGradientStops to extract all gradients
// Extract all gradient paths from the Lottie JSON
function extractGradientStops(json) {
    const gradients = [];
    try {
        // Recursive function to find all gradient fills in the JSON
        function findGradients(obj) {
            if (typeof obj !== 'object' || obj === null) return;

            if (obj.ty === 'gf' && obj.g?.k?.k && obj.g.p) {
                const raw = obj.g.k.k;
                const stops = obj.g.p;
                const hasOpacity = raw.length === stops * 6;
                const gradient = [];

                for (let i = 0; i < stops; i++) {
                    const base = i * 4;
                    const offset = raw[base];
                    const r = raw[base + 1] * 255;
                    const g = raw[base + 2] * 255;
                    const b = raw[base + 3] * 255;
                    let a = 1;

                    if (hasOpacity) {
                        const opaBase = stops * 4 + i * 2;
                        a = raw[opaBase + 1];
                    }

                    gradient.push({
                        offset: Math.round(offset * 100),
                        r: Math.round(r),
                        g: Math.round(g),
                        b: Math.round(b),
                        a: parseFloat(a.toFixed(2)),
                        _path: obj // Store reference to the gradient object
                    });
                }
                gradients.push(gradient);
            }

            // Recursively search through all object properties
            for (const key in obj) {
                if (typeof obj[key] === 'object') {
                    findGradients(obj[key]);
                }
            }
        }

        findGradients(json);
        return gradients;
    } catch (error) {
        console.error('Error extracting gradients:', error);
        alert('Error processing Lottie structure. Check console for details.');
        return [];
    }
}

function updateLottieGradient() {
    if (!lottieData || allGradients.length === 0) return;

    try {
        const updatedLottieData = JSON.parse(JSON.stringify(lottieData));

        allGradients.forEach((gradientStops) => {
            gradientStops.forEach((stop) => {
                const gradientObj = stop._path;
                const raw = gradientObj.g.k.k;
                const stops = gradientObj.g.p;
                const i = gradientStops.indexOf(stop);
                const base = i * 4;
                const colorLen  = stops * 4;
                // Update color values
                raw[base] = stop.offset / 100;
                raw[base + 1] = stop.r / 255;
                raw[base + 2] = stop.g / 255;
                raw[base + 3] = stop.b / 255;

                // Update opacity if available

                gradientStops.forEach((stop, i) => {
                    const opaBase = colorLen + i * 2;
                      raw[opaBase]     = stop.offset / 100;
                        raw[opaBase + 1] = stop.a;
                        });


            });
        });

        // Clear previous animation
        const container = document.getElementById('lottiePreview');
        container.innerHTML = '';

        // Load new animation
      reloadLottiePreview();
    } catch (error) {
        console.error('Error updating animation:', error);
        document.getElementById('lottiePreview').innerHTML =
            'Error rendering animation. Check console for details.';
    }
}






    document.getElementById("fileInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          lottieData = JSON.parse(e.target.result);
          originalFrameRate = lottieData.fr; // Store original frame rate

          // Store animation dimensions
          animWidth = lottieData.w;
          animHeight = lottieData.h;

          colorRefs = [];
          findColors(lottieData);
          renderColorPickers();
          reloadLottiePreview();

          allGradients = extractGradientStops(lottieData);
          renderGradientEditor();
          updateLottieGradient();
          document.getElementById('openOverlayBtn').disabled = false;
          document.getElementById('openOverlayBtn').style.opacity = "1";

        } catch (err) {
          alert("Invalid Lottie JSON");
          document.getElementById('openOverlayBtn').disabled = true;
          document.getElementById('openOverlayBtn').style.opacity = "0.2";

          console.error(err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("downloadJsonBtn").addEventListener("click", () => {
      // Create optimized copy
      const modifiedData = JSON.parse(JSON.stringify(lottieData));
      modifiedData.fr = originalFrameRate * currentSpeed;

      // Stringify with no whitespace and minimal precision
      const jsonString = JSON.stringify(modifiedData, (key, value) => {
        // Round numbers to 3 decimal places to reduce size
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(3));
        }
        return value;
      });

      // Create and trigger download
      const blob = new Blob([jsonString], {
        type: "application/json",
        endings: 'transparent' // Further optimization for Blob
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "animation.min.json"; // Changed to .min.json convention
      a.style.display = 'none'; // More elegant than appending/removing

      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    });

    document.getElementById("downloadGifBtn").addEventListener("click", () => {
      generateGif();
    });

    // Speed control event handlers
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");

    speedSlider.addEventListener("input", (e) => {
      currentSpeed = parseFloat(e.target.value);
      speedValue.textContent = currentSpeed.toFixed(1) + "x";

      // Update the animation speed in real-time
      if (animationInstance) {
        animationInstance.setSpeed(currentSpeed);
      }
    });

    speedSlider.addEventListener("change", (e) => {
      // When slider is released, reload the preview with the new speed
      reloadLottiePreview();
    });


    let overlayAnimationInstance = null;

  document.getElementById('openOverlayBtn').addEventListener('click', () => {
    const overlay = document.getElementById('customOverlay');
    const iframe = document.getElementById('customContent');
    const previewContainer = document.getElementById('lottieOverlayPreview');

    // Clear previous animation if exists
    if (overlayAnimationInstance) {
      overlayAnimationInstance.destroy();
    }

    // Show overlay first
    overlay.style.display = 'flex';
    const overlayData = JSON.parse(JSON.stringify(lottieData));
    overlayData.fr = originalFrameRate * currentSpeed;
    // Render the modified Lottie animation directly in overlay
    // Create minimal custom HTML content
     iframe.src = 'overlay.html';

    // Load into ifram

    iframe.onload = () => {
     // Create clean copy of data
     const overlayData = JSON.parse(JSON.stringify(lottieData));
     overlayData.fr = originalFrameRate * currentSpeed;

     // Send to iframe
     iframe.contentWindow.postMessage({
       type: 'lottieData',
       data: overlayData
     }, '*');
   };
  });

  // Close handler remains the same
  document.querySelector('.overlay-close').addEventListener('click', () => {
    document.getElementById('customOverlay').style.display = 'none';
    if (overlayAnimationInstance) {
      overlayAnimationInstance.destroy();
      overlayAnimationInstance = null;
    }
  });


  </script>
</body>
</html>
