<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lottie Color Editor - Enhanced UI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    /* --- CSS Variables for Consistency --- */
    :root {
      --font-family-base: 'Inter', sans-serif;
      --color-primary: #4CAF50; /* Green */
      --color-primary-dark: #45a049;
      --color-secondary: #2196F3; /* Blue */
      --color-secondary-dark: #1e88e5;
      --color-accent: #FFC107; /* Yellow */
      --color-accent-dark: #fbc02d;
      --color-background: #f7f7f7; /* Slightly lighter */
      --color-surface: #ffffff; /* Card/element background */
      --color-border: #e0e0e0;
      --color-text-primary: #333333;
      --color-text-secondary: #666666;
      --color-text-on-primary: #ffffff;
      --color-text-on-secondary: #ffffff;
      --color-text-on-accent: #333333; /* Dark text on yellow */
      --color-disabled: #cccccc;
      --color-disabled-bg: #eeeeee;
      --color-checkerboard-light: #f0f0f0;
      --color-checkerboard-dark: transparent;

      --spacing-xs: 0.25rem;  /* 4px */
      --spacing-sm: 0.8rem;   /* 8px */
      --spacing-md: 1rem;     /* 16px */
      --spacing-lg: 1.5rem;   /* 24px */
      --spacing-xl: 2rem;     /* 32px */

      --border-radius-sm: 4px;
      --border-radius-md: 16px;
      --border-radius-lg: 16px;
      --border-radius-pill: 999px;

      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);

      --transition-speed: 0.2s ease-in-out;
    }

    /* --- General Reset and Body Styles --- */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-family-base);
      /* padding: var(--spacing-xl); */
      background-color: var(--color-background);
      color: var(--color-text-primary);
      display: flex;
      flex-direction: row;
      gap: 0;
      max-width: 1200px; /* Increased max-width slightly */
      height: 100vh;
      margin: auto;
      line-height: 1.6;
      justify-content: center;
      overflow-x: auto;
    }

    /* --- Layout Areas --- */
    #editorArea, #previewArea {
      display: flex;
      flex-direction: column;
    }

    #editorArea {
      flex: 1;
      overflow-y: auto;
    height: 100vh; /* Adjusted max-height */
      /* Space for potential scrollbar (hidden) */
      /* Hide scrollbars */
      -ms-overflow-style: none;  /* IE 10+ */
      scrollbar-width: none;     /* Firefox */
      gap: 0;
      /*margin-top: var(--spacing-lg);*/

    }
    #editorArea::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    #previewArea {
      flex: 1.1;
      left:0;
      top: var(--spacing-xl);

      align-items: center; /* Center items in preview area */
      gap: var(--spacing-lg);
    }

    /* --- Upload Wrapper --- */
    #uploadWrapper {
      display: flex;
      gap: var(--spacing-lg);
      flex-direction: column-reverse;
      margin: auto;
      justify-content: center;
      align-items: center;

      opacity: 1;
      transition:
        transform 450ms cubic-bezier(0.8,0,0.9,0.9),
        opacity   280ms linear;
      text-align: center; /* Center the label/button */
    }

      .drag-drop-overlay {

    width: 18rem;
    height: 18rem;
    border: 2px dashed var(--color-border);
    border-radius: 3rem;
    background: rgba(255, 255, 255, 0.9);

    margin: auto;
    align-items: center;
    justify-content: center;

    cursor: pointer;
    z-index: 99;
    transition: all var(--transition-speed);

    /* --- Add these --- */
 background-image: url('dropfile.png'); /* Path to your illustration */
 background-repeat: no-repeat;         /* Don't tile the image */
 background-position: center center;     /* Center the image */
 background-size: contain; /* Or adjust like '80% auto', '150px 150px' etc. */
 /* --- End Add --- */
  }

  .drag-drop-overlay.dragover {
      border-color: var(--color-primary);
      background-color: rgba(76, 175, 80, 0.1);
      transform: scale(1.05);
    }

    @keyframes slideUpFadeIn {
from {
  opacity: 0;
  transform: translateY(40px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
}

@keyframes slideDownFadeIn {
from {
  opacity: 0;
  transform: translateY(-40px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
}

#uploadLabel {
animation: slideUpFadeIn 1350ms cubic-bezier(0.1,0.1,0.1,1) forwards;
}

.drag-drop-overlay {
animation: slideDownFadeIn 950ms cubic-bezier(0.1,0.1,0.1,1) forwards;
}




    /* Style the label like a button */
    #uploadLabel {
      display: inline-block;
      padding: var(--spacing-md) var(--spacing-lg);
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
      border: none;
      border-radius: var(--border-radius-pill);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: background-color var(--transition-speed), transform var(--transition-speed), box-shadow var(--transition-speed);
      box-shadow: var(--shadow-sm);
    }
    #uploadLabel:hover {
      background-color: var(--color-primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    /* Hide the actual file input */
    #fileInput {
      display: none;
    }

    /* --- Main Content Visibility --- */
    #mainContent {
      display: none; /* Initially hidden */
      width: 100%;
      flex-direction: row; /* Re-apply flex row for main layout */

      transform: scale(0.6);
      opacity: 0;
      transition:
        transform 450ms cubic-bezier(0.1,0.1,0.2,1),
        opacity   450ms cubic-bezier(0.1,0.1,0.2,1);
      margin-top: 80px;
    }

    /* --- Buttons --- */
    .btn {
      padding: var(--spacing-sm) var(--spacing-md);
      border: none;
      border-radius: var(--border-radius-pill); /* Pill shape */
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: background-color var(--transition-speed), transform var(--transition-speed), box-shadow var(--transition-speed), opacity var(--transition-speed); /* Added opacity transition */
      display: inline-flex; /* Align icon and text if needed */
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      text-decoration: none; /* Remove underline from potential <a> tags */
      box-shadow: var(--shadow-sm);
      position: relative; /* For loading spinner */
      overflow: hidden; /* Hide spinner overflow */
    }
    .btn:hover:not(:disabled) { /* Added :not(:disabled) */
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    .btn:active:not(:disabled) { /* Added :not(:disabled) */
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    .btn:disabled,
    .btn--loading {
      background-color: var(--color-disabled-bg);
      color: var(--color-disabled);
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
      opacity: 0.5; /* Consistent disabled opacity */
    }

    /* Specific Button Colors */
    .btn--primary {
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
    }
    .btn--primary:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-primary-dark);
    }
    .btn--secondary {
      background-color: var(--color-secondary);
      color: var(--color-text-on-secondary);
    }
    .btn--secondary:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-secondary-dark);
    }
    .btn--accent {
      background-color: var(--color-accent);
      color: var(--color-text-on-accent);
    }
    .btn--accent:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-accent-dark);
    }

    /* Icon Buttons (Download, Trim, Crop) */
    .btn--icon {
      width: 2.5rem; /* Fixed size */
      height: 2.5rem;
      padding: 0; /* Remove padding */
      background-repeat: no-repeat;
      background-position: center;
      background-size: 1.25rem 1.25rem; /* Adjust icon size */
      text-indent: -9999px; /* Hide text */
    }
    #downloadJsonBtn {
      background-color: var(--color-secondary);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>');
    }
    #downloadJsonBtn:hover:not(:disabled) {
      background-color: var(--color-secondary-dark);
    }
    #downloadGifBtn {
      background-color: var(--color-accent);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>'); /* Dark icon */
    }
    #downloadGifBtn:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-accent-dark);
    }
    #openOverlayBtn {
      background-color: #e0e0e0; /* Neutral grey */
    background-image: url('trim.svg'); /* Trim icon */
    }
    #openOverlayBtn:not(:disabled) {
       opacity: 1;
    }
    #openOverlayBtn:hover:not(:disabled) {
      background-color: #bdbdbd;
    }

    /* --- NEW CROP BUTTON STYLE --- */
    #openCropBtn {
      background-color: #e0e0e0; /* Neutral grey */
      /* Placeholder Crop Icon - Replace with your actual SVG */
      background-image: url('crop.svg');
    }
     #openCropBtn:not(:disabled) {
       opacity: 1;
     }
    #openCropBtn:hover:not(:disabled) {
      background-color: #bdbdbd;
    }
    /* --- END NEW CROP BUTTON STYLE --- */


    /* --- Loading Spinner (integrated) --- */
    .loading-spinner {
      border: 3px solid rgba(255, 255, 255, 0.3); /* Light border */
      border-top: 3px solid var(--color-text-on-primary); /* Primary spinner color */
      border-radius: 50%;
      width: 1.2rem;
      height: 1.2rem;
      animation: spin 0.8s linear infinite;
      position: absolute; /* Position inside button */
      top: 50%;
      left: 50%;
      margin-top: -0.6rem; /* Center vertically */
      margin-left: -0.6rem; /* Center horizontally */
      display: none; /* Hidden by default */
    }
    .btn--loading .loading-spinner {
      display: block;
    }
    /* Adjust spinner color for accent button */
    .btn--accent.btn--loading .loading-spinner {
        border-top-color: var(--color-text-on-accent);
    }
    /* Hide button icon when loading */
    .btn--loading {
        background-image: none !important; /* Hide icon */
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* --- Inputs & Selects --- */
    input[type="text"],
    input[type="number"],
    select {
      padding: var(--spacing-sm) var(--spacing-md);
      font-size: 0.9rem;
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-pill);
      background-color: var(--color-surface);
      transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
      width: auto; /* Allow shrinking */
      min-width: 60px; /* Minimum width */
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3); /* Focus ring */
    }

    /* Color Inputs */
    input[type="color"] {
      appearance: none;
      -webkit-appearance: none;
      width: 28px; /* Slightly larger */
      height: 28px;
      padding: 0;
      border: none;
      border-radius: 50%; /* Circular */
      cursor: pointer;
      vertical-align: middle;
      transition: transform var(--transition-speed), box-shadow var(--transition-speed);
      box-shadow: var(--shadow-sm);
    }
    input[type="color"]:hover {
        transform: scale(1.1);
        box-shadow: var(--shadow-md);
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 50%;
    }
    input[type="color"]::-webkit-color-swatch {
      border: 1px solid rgba(0,0,0,0.1); /* Subtle border */
      border-radius: 50%;
    }
    input[type="color"]::-moz-color-swatch {
        border: 1px solid rgba(0,0,0,0.1);
        border-radius: 50%;
    }

    /* Input Groups (Color + Hex) */
    .color-input-group {
      display: inline-flex; /* Use inline-flex */
      align-items: center;
      gap: var(--spacing-sm);
      background-color: #f0f0f0; /* Keep light grey bg */
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--border-radius-pill);
    }
    .color-input-group input[type="text"] {
      border: none;
      background: transparent;
      text-align: center;
      font-size: 0.9rem;
      padding: var(--spacing-xs) 0; /* Minimal padding */
      width: 70px; /* Fixed width for hex */
      border-radius: 0; /* Remove radius */
      box-shadow: none;
    }
    .color-input-group input[type="text"]:focus {
        box-shadow: none; /* No focus ring inside group */
    }
    .color-input-group input[type="color"] {
        width: 20px; /* Smaller inside group */
        height: 20px;
        box-shadow: none;
    }
    .color-input-group input[type="color"]:hover {
        transform: none;
        box-shadow: none;
    }

    /* Select Dropdown */
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding-right: var(--spacing-xl); /* Space for arrow */
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 6'><path fill='%23999' d='M0 0l5 6 5-6z'/></svg>");
      background-repeat: no-repeat;
      background-position: right var(--spacing-md) center;
      background-size: 0.6rem 0.36rem;
    }

    /* --- Accordion Styles --- */

    #colorEditor,#stopEditor{
      margin: 0 auto;
     width: 85%;

    }

    .accordion, .gradient-accordion {
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-md);
      box-shadow: var(--shadow-sm);
      overflow: hidden; /* Contain children */
       /* Remove space between accordions */
       margin-bottom: var(--spacing-sm);

    }



    .accordion-header, .gradient-header {
      height:60px;
      padding: var(--spacing-sm) var(--spacing-md);
      background-color: #f9f9f9; /* Slightly off-white header */
      font-weight: 600; /* Bolder */
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color var(--transition-speed);
      position: relative; /* For icon positioning */
      border-bottom: 1px solid var(--color-border); /* Separator line */


    }
    .accordion-header:hover, .gradient-header:hover {
      background-color: #f0f0f0;
    }
    .accordion-header.active {
        border-bottom-color: transparent; /* Remove border when open */
    }

    /* Accordion Icon */
    .accordion-header::after, .gradient-header::after {
      content: ''; /* Required, but empty */
      display: inline-block; /* Needed for width/height */
      width: 1em;  /* Adjust size as needed */
      height: 1em; /* Adjust size as needed */
      opacity: 0.6;
      /* Placeholder Down Chevron - Replace with your actual SVG */
      background-image: url('down-chevron.svg');
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain; /* Scale SVG to fit dimensions */
      transition: transform 0.3s ease-in-out; /* Keep your transition */
      margin-left: 8px; /* Adjust spacing if needed */
      vertical-align: middle; /* Align icon nicely with text */
    }

    .accordion-header.active::after, .gradient-header.active::after {
      transform: rotate(180deg); /* Rotate the SVG */
    }

    .accordion-header-content { /* Wrapper for title and controls */
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-grow: 1; /* Take remaining space */
        margin-right: var(--spacing-sm); /* Space before icon */
    }

    .accordion-header-controls {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .accordion-body, .gradient-content {
      padding: var(--spacing-md);
      display: none; /* Hidden by default */
      flex-direction: column;
      gap: 0.2rem;
      border-top: 1px solid var(--color-border); /* Separator when open */
    }
    .accordion-body.active, .gradient-content.active {
        display: flex; /* Show when active */
    }

    .color-row, .stop-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) 0; /* Vertical padding */
      gap: var(--spacing-md);
    }
    .stop-row .label {
        flex-basis: 100px; /* Give label some space */
        flex-shrink: 0;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
    }
    .stop-row .stop-controls { /* Group controls on the right */
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }
    .color-dot {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 1px solid rgba(0,0,0,0.1);
        flex-shrink: 0; /* Prevent shrinking */
    }

    .stop-row input[type="number"] { /* Alpha input */
      appearance: none; /* Consider keeping this if you don't want default styling */
      -moz-appearance: textfield; /* Hides spinners in Firefox */
      border: none;
      border-radius: 999px;
      padding: 8px 8px 8px 10px; /* Increased right padding: top/right/bottom/left */
      background-color: #f0f0f0;
      transition: background-color 0.2s ease, border 0.2s ease;
      min-width: 68px;
      font-size: 16px;
      text-align: left; /* Align text to the left */
    }

    /* Hide spinners in WebKit browsers (Chrome, Safari) */
    .stop-row input[type="number"]::-webkit-outer-spin-button,
    .stop-row input[type="number"]::-webkit-inner-spin-button {
      margin-left: 6px; /* Optional: Adds space before spinner */
    }

    .gradient-preview {
      height: 16px; /* Taller */
      width: 80px;
      border-radius: var(--border-radius-pill);
      border: 1px solid var(--color-border);
      margin-left: var(--spacing-sm);
      pointer-events: none;
    }

    /* --- Section Cards (Preview Area) --- */
    .section-card {
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-lg); /* More rounded */
      width: 100%; /* Full width within preview area */
      max-width: 400px; /* Max width for cards */
      padding: var(--spacing-md) var(--spacing-lg);
      box-shadow: var(--shadow-md);
    }
    .section-card h3, .editor-heading {
      font-size: 0.75rem; /* Smaller heading */
      font-weight: 700; /* Bold */
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--color-text-secondary); /* Grey heading */
      margin-bottom: var(--spacing-md); /* Space below heading */
      display: block; /* Ensure it takes full width */
    }
    .editor-heading{ margin:0 auto; width: 85%;  margin-top: 2.0rem ;  margin-bottom: 1.6rem ; }

    /* Headers within cards */
    .json-header, .gif-settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gif-settings-header {  margin-bottom: var(--spacing-md); }/* Reset margin if h3 already has it */


    .json-header h3, .gif-settings-header h3 {
        margin-bottom: 0; /* Remove margin from h3 inside header */
    }
    .json-header-controls, .gif-header-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    /* GIF Settings Rows */
    .gif-settings {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: var(--spacing-md);
      gap: var(--spacing-md);
    }
    .gif-settings label {
      font-weight: 500; /* Medium weight */
      font-size: 0.9rem;
      color: var(--color-text-primary);
      flex-shrink: 0; /* Prevent label shrinking */
    }
    .gif-settings .color-input-group-bg { /* Specific styling for BG color group */
        background-color: #f0f0f0;
        padding: var(--spacing-xs);
        border-radius: var(--border-radius-pill);
        display: inline-flex; /* Changed to inline-flex */
        align-items: center;
        gap: var(--spacing-xs);
    }
    .gif-settings .color-input-group-bg input[type="text"] {
        width: 70px;
        border: none;
        background: transparent;
        text-align: center;
        padding: var(--spacing-xs) 0;
    }
    .gif-settings .color-input-group-bg input[type="color"] {
        width: 20px;
        height: 20px;
        box-shadow: none;
    }

    /* --- Toggle Switch --- */
    .switch {
      position: relative;
      display: inline-block;
      width: 44px; /* Slightly wider */
      height: 24px;
      vertical-align: middle; /* Align with labels */
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: var(--transition-speed);
      border-radius: var(--border-radius-pill);
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px; /* Larger handle */
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: var(--transition-speed);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .switch input:checked + .slider {
      background-color: var(--color-primary);
    }
    .switch input:checked + .slider:before {
      transform: translateX(20px); /* Adjusted translation */
    }
    .switch input:focus + .slider {
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3); /* Focus ring */
    }

    /* --- Speed Control Slider --- */
    .speed-control {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      width: 100%; /* Full width within its container */
      margin: var(--spacing-sm) 0; /* Vertical margin */
      background-color: white;

      border-radius: var(--border-radius-lg); /* More rounded */
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      width: 100%; /* Full width within preview area */
      max-width: 400px; /* Max width for cards */
      padding: var(--spacing-md) var(--spacing-lg);

    }
    .slider-wrapper {
      flex-grow: 1; /* Take available space */
      position: relative;
    }
    /* Range Input Base */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px; /* Track height */
      background: #ddd; /* Track background */
      border-radius: var(--border-radius-pill);
      cursor: pointer;
      outline: none;
      margin: var(--spacing-sm) 0; /* Add some vertical margin */
    }
    /* Thumb (WebKit) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px; /* Thumb size */
      height: 20px;
      background: var(--color-surface); /* Thumb color */
      border: 2px solid var(--color-primary); /* Thumb border */
      border-radius: 50%;
      cursor: pointer;
      margin-top: -15px; /* Adjust vertical position */
      box-shadow: var(--shadow-sm);
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    input[type="range"]:hover::-webkit-slider-thumb {
      background-color: var(--color-primary);
    }
    input[type="range"]:active::-webkit-slider-thumb {
        transform: scale(1.1);
    }
    input[type="range"]:focus::-webkit-slider-thumb {
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4); /* Focus ring on thumb */
    }
    /* Thumb (Mozilla) */
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--color-surface);
      border: 2px solid var(--color-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    input[type="range"]:hover::-moz-range-thumb {
      background-color: var(--color-primary);
    }
    input[type="range"]:active::-moz-range-thumb {
        transform: scale(1.1);
    }
    input[type="range"]:focus::-moz-range-thumb {
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4);
    }

    /* Speed Value Display */
    .speed-value {
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--border-radius-pill);
      font-size: 0.9rem;
      font-weight: 600;
      min-width: 60px; /* Ensure space */
      text-align: center;
      white-space: nowrap; /* Prevent wrapping */
      box-shadow: var(--shadow-sm);
    }

    /* --- Preview Window --- */
    .window-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 400px; /* Max width for preview */
      background: var(--color-surface);
      border-radius: var(--border-radius-lg); /* Match cards */
      box-shadow: var(--shadow-md); /* More prominent shadow */
      overflow: hidden;
      border: 1px solid var(--color-border);
      opacity: 0;
      z-index:98;

    }
    .window-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f2f2f2; /* Light grey header */
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--color-border);
    }
    .window-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--color-text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis; /* Handle long filenames */
      margin-right: var(--spacing-sm);
    }
    .window-close {
      width: 20px; /* Larger close button */
      height: 20px;
      line-height: 18px; /* Adjust line height */
      text-align: center;
      border: none;
      border-radius: 50%;
      background: #ff5f57; /* Mac red */
      color: rgba(0,0,0,0.6); /* Darker symbol */
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      padding: 0;
      transition: background-color var(--transition-speed);
      flex-shrink: 0; /* Prevent shrinking */
    }
    .window-close:hover {
      background: #e0483e;
    }
    .window-body {
      position: relative;
      flex: 1; /* Take remaining space */
      display: flex;
      align-items: center;
      justify-content: center;
       /* Add some padding */
    

      width: 100%; /* Ensure it fills container width */
      overflow: visible; /* Lottie might overflow slightly */
      ransition: background-color var(--transition-speed); /* Smooth color transition */
    }
    /* Checkerboard Background */
    .checkerboard {
      background-image: linear-gradient(45deg, var(--color-checkerboard-light) 25%, var(--color-checkerboard-dark) 25%),
                        linear-gradient(-45deg, var(--color-checkerboard-light) 25%, var(--color-checkerboard-dark) 25%),
                        linear-gradient(45deg, var(--color-checkerboard-dark) 75%, var(--color-checkerboard-light) 75%),
                        linear-gradient(-45deg, var(--color-checkerboard-dark) 75%, var(--color-checkerboard-light) 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
    #lottiePreview {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain; /* Ensure Lottie fits */
      display: block; /* Remove extra space below */
    }

    /* Style for the container holding the text and toggle */
  .preview-bg-toggle {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    z-index: 10;
    display: flex; /* Arrange text and switch horizontally */
    align-items: center; /* Vertically align items */
    gap: var(--spacing-sm); /* Space between text and switch */
    background-color: rgba(255, 255, 255, 0.7); /* Optional: slight white bg for contrast */
    padding: var(--spacing-xs) 10px; /* Optional: Padding */
    padding-right: 6px;
    border-radius: var(--border-radius-pill); /* Optional: Rounded corners */
    backdrop-filter: blur(2px); /* Optional: Frosted glass effect */
    box-shadow: 0 1px 2px rgba(0,0,0,0.1); /* Optional: Subtle shadow */
  }

  /* Style for the text label */
  .preview-bg-label {
    font-size: 0.75rem; /* Small text */
    font-weight: 600; /* Medium bold */
    color: var(--color-text-secondary); /* Grey text */
    white-space: nowrap; /* Prevent wrapping */
    cursor: default; /* Indicate it's just text */
  }

  /* Ensure the switch label itself doesn't add extra spacing */
  .preview-bg-toggle .switch {
    margin: 0; /* Reset margin if any */
    transform: scale(0.8); /* Keep the smaller scale if you liked it */
  }

  /* Remove checkerboard when solid background is active */
  .window-body.solid-bg-active {
    background-image: none; /* Remove the checkerboard gradient */
  }




    /* --- Overlays --- */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.6); /* Darker overlay */
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: var(--spacing-md); /* Padding for smaller screens */

    }
    .overlay.active {
        display: flex; /* Show when active */
    }
    .overlay-content {
      background: var(--color-surface);
      width: 80%;
      height: 80%;
      max-height: 80vh;
      /*padding: var(--spacing-lg);*/
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-lg);
      position: relative;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added to allow iframe to fill height */
      flex-direction: column; /* Added */

    }


    .overlay-close {
        position: absolute;
        top: 27px;
        right: 20px;
        cursor: pointer;
        width: 28px;              /* Button width */
        height: 28px;             /* Button height */
        border-radius: 50%;       /* Keep it circular */
        background-color: #ff5f57;/* Keep red background */

        /* --- SVG Icon Styling --- */
        background-image: url('close.svg'); /* Path to your SVG file */
        background-repeat: no-repeat;       /* Prevent tiling */
        background-position: center;        /* Center the SVG */
        background-size: 55%;               /* Size of SVG within button (adjust %) */
        /* --- End SVG Icon Styling --- */

        /* --- White Border --- */
        border: 3px solid white;            /* Add 3px solid white border */
        /* --- End White Border --- */

        padding: 0;                         /* Keep padding 0 */
        /* Flex properties are optional now but don't hurt */
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease, transform 0.2s ease; /* Keep transitions */
       /* Keep optional shadow */
        /* color: transparent; was removed */
    }

    /* Keep these hover and focus rules (or modify if they conflict visually) */
    .overlay-close:hover {
        background-color: #e0483e; /* Darker red on hover */
        transform: scale(1.1);    /* Slightly enlarge on hover */
    }

    .overlay-close:focus {
        outline: none;            /* Remove default outline */
        box-shadow: 0 0 0 3px rgba(255, 95, 87, 0.6); /* Keep focus ring */
    }





    }
    .overlay h3 { /* Style heading inside overlay */
        margin-bottom: var(--spacing-lg);
        font-size: 1.2rem;
        color: var(--color-text-primary);
        flex-shrink: 0; /* Prevent shrinking */
    }
    /* Settings Rows inside Overlay */
    .setting-row {
      margin-bottom: var(--spacing-lg); /* Increased spacing */
      display: flex;
      flex-direction: column; /* Stack label and controls vertically */
      align-items: flex-start; /* Align items to start */
      gap: var(--spacing-sm);
       flex-shrink: 0; /* Prevent shrinking */
    }
    .setting-row label {
      font-weight: 500;
      font-size: 0.9rem;
      color: var(--color-text-primary);
    }
    .setting-row .controls { /* Wrapper for inputs */
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }
    .setting-row input[type="text"] {
      width: 100px; /* Fixed width for hex in overlay */
    }

    /* Iframe in Overlay */
    #customContent {
      width: 100%;
      border: 1px solid var(--color-border); /* Add border */
      border-radius: var(--border-radius-md);
      flex-grow: 1; /* Added to fill remaining space */
    }

    /* Hidden GIF Container */
    #gifContainer {
      position:absolute;
      top:-9999px; left:-9999px;
      width:0; height:0;
      overflow:hidden;
    }

    /* --- Media Queries for Responsiveness --- */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        padding: var(--spacing-lg); /* Adjust padding */
      }
      #editorArea {
        max-height: none; /* Remove max-height */
        order: 2; /* Editor below preview */
        padding-right: 0; /* No padding needed */
      }
      #previewArea {
        position: static; /* Remove sticky */
        order: 1; /* Preview first */
        width: 100%;
        flex: none; /* Reset flex property */
      }
      .window-container, .section-card {
          max-width: none; /* Allow cards/preview to fill width */
      }
      .speed-control {
          flex-direction: column; /* Stack slider and value */
          align-items: stretch; /* Stretch items */
        }
      .speed-value {
          margin-top: var(--spacing-sm);
          text-align: center;
      }
       .overlay-content {
           width: 95%; /* Use more width on smaller screens */
           height: 90%;
           max-height: 90vh;
       }
    }

    /* --- Accessibility Helper --- */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    .gif-settings .color-input-group-bg {
        transition: opacity 0s ease, visibility 0s ease;
        opacity: 1;
        visibility: visible;
      }

      .gif-settings .color-input-group-bg.hidden {
        opacity: 0;
        visibility: hidden;
        position: absolute; /* Remove from layout flow */
        pointer-events: none; /* Make it non-interactive when hidden */
      }

      /* Add wrapper to maintain consistent height */
      .gif-settings > div {
        position: relative;
        min-height: 32px; /* Match your control height */
        display: flex;
        align-items: center;
      }


      /* --- Overlays --- */
      .overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.85); /* Backdrop color */
        display: flex; /* Keep flex for centering */
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: var(--spacing-md);

        /* --- BACKDROP ANIMATION (Fade only) --- */
        opacity: 0;
        pointer-events: none; /* Prevent interaction when hidden */
        /* Define backdrop closing transition */
        transition:
            /* Delay the backdrop fade-out until the content slide (350ms) is done */
            opacity 300ms linear 350ms, /* MODIFIED LINE */
            /* Delay pointer-events until near the end of the backdrop fade */
            pointer-events 0s linear 600ms; /* MODIFIED LINE */
      }

.overlay.active {
    /* --- BACKDROP ANIMATION (Fade only) --- */
    opacity: 1;
    pointer-events: auto; /* Allow interaction when visible */
    /* Define backdrop opening transition */
    transition: opacity 200ms linear; /* Faster fade in for backdrop */
}

.overlay-content {
  background: var(--color-surface);
  max-width: 1024px;
  width: 90%;
  height: 90%;
  max-height: 80vh;
  /*padding: var(--spacing-lg);*/
  border-radius: var(--border-radius-lg);
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow-y: auto;
  display: flex;
  flex-direction: column;

  /* --- CONTENT ANIMATION (Slide + Fade) --- */
  opacity: 0;
  /* Start positioned lower down */
  transform: translateY(60px);
  /* Define content closing transition */
  transition: transform 350ms cubic-bezier(0.9, 0, 0.9, 0.9), /* Slide down */
              opacity 300ms linear; /* Fade out */
}

.overlay.active .overlay-content {
    /* --- CONTENT ANIMATION (Slide + Fade) --- */
    opacity: 1;
    /* End state: original position */
    transform: translateY(0);
    /* Define content opening transition */
    /* Add a small delay (e.g., 50ms) so backdrop starts fading first */
    transition: transform 550ms cubic-bezier(0.1, 0.1, 0.1, 1) 50ms, /* Slide up */
                opacity 400ms linear 100ms; /* Fade in (slightly longer delay) */
}

/* (Keep your other overlay styles like .overlay-close, .overlay h3 etc.) */
.window-title[contenteditable="true"] {
    cursor: text;
    min-width: 50px; /* Prevent it becoming too small */
    display: inline-block; /* Needed for min-width */
    padding: 2px 4px; /* Add some internal spacing */
    margin: -2px -4px; /* Compensate for padding */
    border-radius: 3px;
}
.window-title[contenteditable="true"]:focus {
    outline: 1px solid var(--color-primary); /* Highlight border on focus */
    background-color: #f0f0f0; /* Slight background change on focus */
}
.page-logo {
  position: absolute;
  top: var(--spacing-lg);     /* adjust for your taste */
  left: 50%;
  transform: translateX(-50%);
  max-width: 700px;            /* cap its size */
  height: 36px;
  z-index: 100;                /* sit above everything else */
}

/* Add these styles to your CSS */
#emptyStateDiv {
  display: none; /* Hidden by default */
  height: 600px; /* Set the desired height */
  width: 100%;
  display: flex; /* Use flexbox for centering */
  justify-content: center; /* Center horizontally */
  align-items: center; /* Center vertically */
  text-align: center;
  padding: var(--spacing-lg);
  /* Optional visual styling */

  border-radius: var(--border-radius-md);
  margin-top: var(--spacing-lg);
  box-sizing: border-box; /* Include padding/border in height */
}

#emptyStateDiv img {
  max-width: 80%; /* Prevent image from becoming too large */
  max-height: 80%;
  object-fit: contain; /* Ensure image scales nicely */
  opacity: 0.7; /* Optional: make it slightly faded */
}

/* Optional: Hide the main heading when the empty state is shown */
#editorArea.is-empty #colorInstancesLabel {
    display: none;
}

#midsection{
  height: 100%;
  flex: 0;

}

  </style>
</head>
<body>
  <img src="mainLogo.svg" alt="Main Logo" class="page-logo" />
  <div id="uploadWrapper">
    <label for="fileInput" id="uploadLabel" class="btn btn--primary">Choose Lottie JSON</label>
    <div class="drag-drop-overlay"></div>
    <input type="file" id="fileInput" accept=".json" />
  </div>

  <div class="window-container">
    <div class="window-header">
      <span class="window-title" contenteditable="true">No file loaded</span>
      <button class="window-close" aria-label="Close Preview">&times;</button>
    </div>
    <div class="window-body checkerboard" style="flex-direction: column;">
      <div class="preview-bg-toggle" title="Toggle Background (Checkerboard/Solid)">
       <span class="preview-bg-label">GIF BG</span>
       <label class="switch"> <input type="checkbox" id="previewBgToggle">
         <span class="slider"></span>
         <span class="sr-only">Toggle Preview Background</span>
       </label>
     </div>
      <div id="lottiePreview"></div>

      <div class="speed-control" style="margin-bottom: 0;">
        <div class="slider-wrapper">
          <label for="speedSlider" class="sr-only">Animation Speed</label>
          <input
            type="range"
            id="speedSlider"
            min="0.1"
            max="3"
            step="0.1"
            value="1"
            list="speedStops"
            aria-labelledby="speedValueLabel"
          >
          <datalist id="speedStops">
            <option value="0.5"></option>
            <option value="1.0"></option>
            <option value="1.5"></option>
            <option value="2.0"></option>
            <option value="2.5"></option>
            <option value="3.0"></option>
          </datalist>
        </div>
        <span id="speedValue" class="speed-value" aria-live="polite">1.0x</span>
        <span id="speedValueLabel" class="sr-only">Current Speed:</span>
      </div>

    </div>
  </div>


  <div id="mainContent">
    <div id="editorArea">
      <h3 id="colorInstancesLabel" class="editor-heading"><span style="margin-left: 3px;">Detected Colors/Gradients</span></h3>
      <div id="colorEditor">
        </div>
      <div id="stopEditor">
        </div>
        <div id="emptyStateDiv">
        <img src="nocolor.png" alt="No colors detected">
    </div>
    </div>
<div id="midsection"></div>
    <div id="previewArea">



      <div class="section-card" id="jsonEditorCard">
        <div class="json-header">
          <h3 id="jsonExportLabel">Lottie JSON</h3>
          <div class="json-header-controls">
            <button id="openOverlayBtn" class="btn btn--icon" title="Open Trim Editor (Requires overlay.html)" disabled aria-label="Open Trim Editor">
            </button>
            <button id="openCropBtn" class="btn btn--icon" title="Open Crop Editor (Requires crop.html)" disabled aria-label="Open Crop Editor">
            </button>
            <button id="downloadJsonBtn" class="btn btn--icon btn--secondary" title="Download Modified JSON" style="display:none;" aria-label="Download Modified JSON">
            </button>
          </div>
        </div>
      </div>

      <div class="section-card" id="gifOptionsCard">
        <div class="gif-settings-header">
          <h3 id="gifExportLabel">GIF Export</h3>
           <div class="gif-header-controls">
             <button id="downloadGifBtn" class="btn btn--icon btn--accent" style="display:none;" title="Generate and Download GIF (Requires loader.json & gif.worker.js)" aria-label="Generate and Download GIF">
                <div class="loading-spinner"></div>
             </button>
          </div>
        </div>

        <div class="gif-settings">
          <label for="transparentBg">Background</label>
          <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
             <div class="color-input-group-bg" id="bgColorGroup">
                <label for="bgColorPicker" class="sr-only">Background Color</label>
                <input type="color" id="bgColorPicker" value="#ffffff">
                <label for="bgHexInput" class="sr-only">Background Hex</label>
                <input type="text" id="bgHexInput" value="#ffffff">
            </div>
            <label class="switch" title="Toggle Transparent Background">
                <input type="checkbox" id="transparentBg" checked>
                <span class="slider"></span>
            </label>
            <span class="sr-only">Transparent Background Toggle</span>
          </div>
        </div>

        <div class="gif-settings">
          <label for="gifScale">Resolution Scale</label>
          <select id="gifScale">
            <option value="0.25">0.25x</option>
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x (Default)</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
          </select>
        </div>
      </div>

    </div> </div> <div id="gifContainer"></div>

  <div class="overlay" id="renderSettingsOverlay">
    <div class="overlay-content">
      <button class="overlay-close" aria-label="Close GIF Settings">&times;</button>
      <h3>Advanced GIF Settings</h3>

      <div class="setting-row">
        <label for="keyColor">Transparency Key Color (for GIF):</label>
        <div class="controls">
            <input type="color" id="keyColor" value="#000000">
            <input type="text" id="keyHex" value="#000000">
        </div>
        <small>Color to treat as transparent (use near-black if Lottie uses pure black).</small>
      </div>

      <div class="setting-row">
        <label for="replaceColor">Replacement Color:</label>
         <div class="controls">
            <input type="color" id="replaceColor" value="#010101">
            <input type="text" id="replaceHex" value="#010101">
        </div>
         <small>Color to replace the Key Color with before rendering.</small>
      </div>

      <button onclick="closeSettings()" class="btn btn--primary" style="margin-top: var(--spacing-md);">Save Settings</button>
    </div>
  </div>

  <div class="overlay" id="customOverlay">
    <div class="overlay-content">
      <button class="overlay-close" aria-label="Close Editor Overlay"></button>
      <iframe id="customContent" title="Lottie Animation Editor Overlay"></iframe>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

  <script>
    // --- Global Variables ---
    let lottieData;         // Stores the parsed Lottie JSON
    let colorRefs = [];     // Stores references to solid color paths
    let allGradients = [];  // Stores references to gradient paths and stops
    let animationInstance;  // The main Lottie animation instance in the preview
    let currentSpeed = 1.0; // Current playback speed multiplier
    let originalFrameRate;  // Original frame rate from the Lottie JSON
    let animWidth, animHeight; // Original dimensions from the Lottie JSON
    let overlayAnimationInstance = null; // Instance for the overlay iframe

    // GIF rendering settings (can be overridden by overlay)
    let keyColor = '#000000';     // Color to make transparent in GIF
    let replaceColor = '#010101'; // Color to replace keyColor with before rendering


    // --- NEW: Undo/Redo Variables ---
    let originalLottieDataForReset; // To store a pristine copy for full reset
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STEPS = 10;
    let initialColorGroups = null;
    let preservedColorAccordionStates = {};
    let preservedGradientAccordionStates = {};
    // --- END NEW ---


    let translationtoX = null;
    let translationtoY = null;

    // --- DOM Element References ---
    const fileInput = document.getElementById('fileInput');
    const uploadWrapper = document.getElementById('uploadWrapper');
    const dragDropOverlay = document.querySelector('.drag-drop-overlay');

    const mainContent = document.getElementById('mainContent');
    const editorArea = document.getElementById('editorArea');
    const colorEditor = document.getElementById('colorEditor');
    const stopEditor = document.getElementById('stopEditor');
    const previewArea = document.getElementById('previewArea');
    const lottiePreview = document.getElementById('lottiePreview');
    const windowTitle = document.querySelector('.window-title');
    const windowCloseBtn = document.querySelector('.window-close');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const downloadJsonBtn = document.getElementById('downloadJsonBtn');
    const downloadGifBtn = document.getElementById('downloadGifBtn');
    const openOverlayBtn = document.getElementById('openOverlayBtn');
    const openCropBtn = document.getElementById('openCropBtn'); // *** NEW CROP BUTTON REF ***
    const transparentBgCheckbox = document.getElementById('transparentBg');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const bgHexInput = document.getElementById('bgHexInput');
    const bgColorGroup = document.getElementById('bgColorGroup');
    const gifScaleSelect = document.getElementById('gifScale');
    const gifContainer = document.getElementById('gifContainer'); // Hidden container for GIF rendering
    const gifExportLabel = document.getElementById('gifExportLabel');
    const renderSettingsOverlay = document.getElementById('renderSettingsOverlay');
    const customOverlay = document.getElementById('customOverlay');
    const customOverlayIframe = document.getElementById('customContent');
    const overlayCloseButtons = document.querySelectorAll('.overlay-close');





    // --- Utility Functions ---

    /**
     * Converts RGB color components (0-1 range) to a hex string.
     */
    function rgbToHex(r, g, b) {
      const rInt = Math.max(0, Math.min(255, Math.round(r * 255)));
      const gInt = Math.max(0, Math.min(255, Math.round(g * 255)));
      const bInt = Math.max(0, Math.min(255, Math.round(b * 255)));
      return "#" + [rInt, gInt, bInt].map(x => x.toString(16).padStart(2, "0")).join("");
    }

    /**
     * Converts a hex color string to RGB components (0-1 range).
     */
    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [
        ((bigint >> 16) & 255) / 255,
        ((bigint >> 8) & 255) / 255,
        (bigint & 255) / 255
      ];
    }

    /**
     * Converts RGB color components (0-255 range) to a hex string (for gradients).
     */
    function rgbToHexGr(r, g, b) {
        const rInt = Math.max(0, Math.min(255, Math.round(r)));
        const gInt = Math.max(0, Math.min(255, Math.round(g)));
        const bInt = Math.max(0, Math.min(255, Math.round(b)));
        return '#' + [rInt, gInt, bInt].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Converts a hex color string to RGB components (0-255 range) (for gradients).
     */
    function hexToRGBGr(hex) {
      const value = hex.replace('#', '');
      return {
        r: parseInt(value.substring(0, 2), 16),
        g: parseInt(value.substring(2, 4), 16),
        b: parseInt(value.substring(4, 6), 16),
      };
    }






    /**
     * Recursively finds solid color definitions (like {c: {k: [r,g,b,a]}}) in the Lottie JSON.
     */
    function findColors(obj, path = []) {
      if (Array.isArray(obj)) {
        obj.forEach((item, i) => findColors(item, [...path, i]));
      } else if (typeof obj === 'object' && obj !== null) {
        if (
          obj.hasOwnProperty('c') && typeof obj.c === 'object' && obj.c !== null &&
          obj.c.hasOwnProperty('k') && Array.isArray(obj.c.k) &&
          obj.c.k.length >= 3 && obj.c.k.length <= 4 &&
          obj.c.k.every(val => typeof val === 'number')
        ) {
          if (!obj.c.hasOwnProperty('a') || obj.c.a !== 1) {


              colorRefs.push({
                path: [...path, 'c', 'k'],
                original: [...obj.c.k]
              });
          }
        }
        for (let key in obj) {
          if (key !== 'assets' || path.length === 0) {
              findColors(obj[key], [...path, key]);
          }
        }
      }
    }

    /**
     * Retrieves a value from an object using a path array.
     */
    function getValueByPath(obj, path) {
        try {
            return path.reduce((acc, key) => acc[key], obj);
        } catch (e) {
            console.warn("Invalid path:", path, "in object:", obj);
            return undefined;
        }
    }

    /**
     * Sets a value in an object using a path array.
     */
    function setValueByPath(obj, path, newValue) {
        try {
            const lastKey = path[path.length - 1];
            const target = path.slice(0, -1).reduce((acc, key) => acc[key], obj);
            if (target && typeof target === 'object') {
                target[lastKey] = newValue;
            } else {
                 console.warn("Invalid target for path:", path, "in object:", obj);
            }
        } catch (e) {
             console.warn("Error setting value for path:", path, "in object:", obj, e);
        }
    }





    /**
     * Updates a specific solid color in the `lottieData` object.
     */
     function updateColor(ref, newHex) {
       const rgbNew = hexToRgb(newHex); // Calculate new RGB values
       const currentVal = getValueByPath(lottieData, ref.path); // Get current value (old value)

       // Ensure currentVal is an array and make a copy for oldValue
       const oldValueArray = Array.isArray(currentVal) ? [...currentVal] : [...rgbNew, 1]; // Fallback if path was invalid

       const currentAlpha = (Array.isArray(currentVal) && currentVal.length === 4) ? currentVal[3] : 1;
       const finalColorNew = [...rgbNew, currentAlpha]; // New color array

       // --- NEW: Record change (delta) ---
       recordChange({
         type: 'SOLID_COLOR',
         path: [...ref.path], // Store a copy of the path
         oldValue: oldValueArray,
         newValue: finalColorNew
       });
       // --- END NEW ---

       setValueByPath(lottieData, ref.path, finalColorNew);
       reloadLottiePreview();
     }

    /**
     * Extracts all gradient definitions from the Lottie JSON.
     */
    function extractGradientStops(json) {
        const gradients = [];
        const visited = new WeakSet();
        const stack = [json];

        try {
            while (stack.length > 0) {
                const obj = stack.pop();

                if (typeof obj !== 'object' || obj === null || visited.has(obj)) {
                    continue;
                }
                visited.add(obj);

                if (obj.ty === 'gf' && obj.g?.k?.k && Array.isArray(obj.g.k.k) && obj.g.p) {
                    const rawColorData = obj.g.k.k;
                    const numColorStops = obj.g.p;
                    const hasOpacity = rawColorData.length === numColorStops * 6;
                    const gradient = [];

                    for (let i = 0; i < numColorStops; i++) {
                        const colorBaseIndex = i * 4;
                        const offset = rawColorData[colorBaseIndex];
                        const r = rawColorData[colorBaseIndex + 1] * 255;
                        const g = rawColorData[colorBaseIndex + 2] * 255;
                        const b = rawColorData[colorBaseIndex + 3] * 255;
                        let a = 1;

                        if (hasOpacity) {
                            const opacityBaseIndex = numColorStops * 4 + i * 2;
                            a = rawColorData[opacityBaseIndex + 1];
                        }

                        gradient.push({
                            offset: Math.round(offset * 100),
                            r: Math.round(r),
                            g: Math.round(g),
                            b: Math.round(b),
                            a: parseFloat(a.toFixed(2)),
                            _path: obj // Store reference
                        });
                    }
                    gradients.push(gradient);
                }

                for (const value of Object.values(obj)) {
                    if (typeof value === 'object' && value !== null) {
                        if (Array.isArray(value)) {
                            for (let i = value.length - 1; i >= 0; i--) {
                                if (typeof value[i] === 'object' && value[i] !== null) {
                                    stack.push(value[i]);
                                }
                            }
                        } else {
                            stack.push(value);
                        }
                    }
                }
            }
            return gradients;
        } catch (error) {
            console.error('Error extracting gradients:', error);
            return [];
        }
    }


    /**
     * Updates the Lottie JSON data based on changes made in the gradient editor UI.
     */
    function updateLottieGradient() {
        if (!lottieData || allGradients.length === 0) return;

        allGradients.forEach(gradientStops => {
            const gradientObj = gradientStops[0]?._path;
            if (!gradientObj || !gradientObj.g?.k?.k) {
                console.warn("Could not find original Lottie object for gradient:", gradientStops);
                return;
            }

            const rawColorData = gradientObj.g.k.k;
            const numColorStops = gradientObj.g.p;
            const needsOpacityUpdate = gradientStops.some(s => s.a !== 1);
            const colorDataLength = numColorStops * 4;
            const newRawData = new Array(needsOpacityUpdate ? numColorStops * 6 : numColorStops * 4);

            gradientStops.forEach((stop, i) => {
                const baseIndex = i * 4;
                newRawData[baseIndex]     = stop.offset / 100;
                newRawData[baseIndex + 1] = stop.r / 255;
                newRawData[baseIndex + 2] = stop.g / 255;
                newRawData[baseIndex + 3] = stop.b / 255;
            });

            if (needsOpacityUpdate) {
                gradientStops.forEach((stop, i) => {
                    const opacityBaseIndex = colorDataLength + i * 2;
                    newRawData[opacityBaseIndex]     = stop.offset / 100;
                    newRawData[opacityBaseIndex + 1] = stop.a;
                });
            }

            gradientObj.g.k.k = newRawData;
        });

        reloadLottiePreview();
    }


    /**
     * Reloads the Lottie animation preview with the current `lottieData`.
     */
    function reloadLottiePreview() {
      if (animationInstance) {
        animationInstance.destroy();
        animationInstance = null;
      }
      if (!lottieData || !lottiePreview) return;

      const playbackData = JSON.parse(JSON.stringify(lottieData));

      if (originalFrameRate && playbackData.fr) {
          playbackData.fr = originalFrameRate * currentSpeed;
      } else {
          console.warn("Original frame rate or playback frame rate missing.");
      }

      animationInstance = lottie.loadAnimation({
        container: lottiePreview,
        renderer : 'svg',
        loop     : true,
        autoplay : true,
        animationData: playbackData,
        rendererSettings: {
   preserveAspectRatio: 'xMidYMid meet',
   fontFamily: 'Arial, Helvetica, sans-serif'
 }
      });

      animationInstance.addEventListener('data_failed', () => {
          console.error("Lottie data failed to load in preview.");
      });
       animationInstance.addEventListener('error', (error) => {
          console.error("Lottie animation error:", error);
      });
    }

    /**
     * Renders the accordion UI for editing solid colors.
     */
    function renderColorPickers() {

      colorEditor.innerHTML = "";

      if (!initialColorGroups || Object.keys(initialColorGroups).length === 0) {
       // Handle case where no solid colors were found initially or initialColorGroups isn't populated
       updateDownloadButtonsState(); // Ensure buttons are in correct state
       return;
   }



      Object.entries(initialColorGroups).forEach(([originalGroupHex, refs]) => {
        let hex;
if (refs.length > 0) {
  // Grab the current [r,g,b] from lottieData
  const [r, g, b] = getValueByPath(lottieData, refs[0].ref.path);
  hex = rgbToHex(r, g, b);
} else {
  hex = originalGroupHex;
}



        const accordion = document.createElement("div");
        accordion.className = "accordion";
        accordion.dataset.id = originalGroupHex; // <-- SET THE ID HERE

        const header = document.createElement("div");
        header.className = "accordion-header";

        const headerContent = document.createElement("div");
        headerContent.className = "accordion-header-content";

        const title = document.createElement("span");
        title.textContent = `${refs.length} Instance${refs.length > 1 ? 's' : ''}`;

        const controls = document.createElement("div");
        controls.className = "accordion-header-controls color-input-group";

        const groupHexInput = document.createElement("input");
        groupHexInput.type = "text";
        groupHexInput.value = hex;
        groupHexInput.setAttribute("aria-label", `Hex code for color group ${hex}`);

        const groupColorInput = document.createElement("input");
        groupColorInput.type = "color";
        groupColorInput.value = hex;
        groupColorInput.setAttribute("aria-label", `Color picker for color group ${hex}`);

        controls.appendChild(groupHexInput);
        controls.appendChild(groupColorInput);

        headerContent.appendChild(title);
        headerContent.appendChild(controls);
        header.appendChild(headerContent);

        const body = document.createElement("div");
        body.className = "accordion-body";
        body.id = `accordion-body-${originalGroupHex.replace('#','')}`;

        if (preservedColorAccordionStates[originalGroupHex] === true) {
         header.classList.add('active');
         body.classList.add('active'); // Your CSS might use this
         body.style.display = "flex";  // Or "block", matching your active style
         header.setAttribute('aria-expanded', 'true');
           } else {
               body.style.display = "none"; // Default to closed
               header.setAttribute('aria-expanded', 'false');
               // No need to explicitly remove 'active' class if elements are fresh
           }
           // --- END APPLY PRESERVED STATE --


           const handleHeaderInput = (newHex) => {
             if (!/^#[0-9A-F]{6}$/i.test(newHex)) return;

             const itemsToRecord = [];
             const newBaseRgb = hexToRgb(newHex); // The new RGB (0-1 range) from the header

             refs.forEach(({ ref }) => {
               const currentPath = [...ref.path]; // Ensure to use a copy of the path
               const currentValue = getValueByPath(lottieData, currentPath);

               // Determine the old RGBA value
               const oldRgbaValue = Array.isArray(currentValue) && currentValue.length >= 3 ?
                                    [...currentValue] : // Use existing value if valid
                                    [...newBaseRgb, 1]; // Fallback with new RGB and alpha 1

               // Store details for the undo record
               itemsToRecord.push({
                 path: currentPath,
                 oldValue: oldRgbaValue, // This is the RGBA before the change
               });

               // Determine the new RGBA value for this specific item
               // (new RGB from header + existing alpha of the item)
               const existingAlpha = (Array.isArray(currentValue) && currentValue.length === 4) ? currentValue[3] : 1;
               const finalColorNewWithExistingAlpha = [...newBaseRgb, existingAlpha];

               // Apply the change directly to lottieData
               setValueByPath(lottieData, currentPath, finalColorNewWithExistingAlpha);
             });

             // Record ONE change for the whole accordion group, if any items were changed
             if (itemsToRecord.length > 0) {
               recordChange({
                 type: 'SOLID_COLOR_ACCORDION', // New change type
                 items: itemsToRecord,          // Array of individual item changes (path and their oldValue)
                 newBaseRgbApplied: newBaseRgb  // Store the new base RGB that was applied to all
               });
             }

             // Update UI for accordion header and child rows to reflect the new color

             const rows = body.querySelectorAll('.color-row');
             rows.forEach(row => {
               row.querySelector('input[type="color"]').value = newHex;
               row.querySelector('input[type="text"]').value = newHex;
             });

             reloadLottiePreview(); // Refresh the Lottie animation
           };

        /*groupColorInput.addEventListener("change", (e) => handleHeaderInput(e.target.value));*/
        commitAfterIdle(groupColorInput, hex => handleHeaderInput(hex), 100);



        groupHexInput.addEventListener("change", (e) => {
            let newHex = e.target.value.trim();
            if (!newHex.startsWith("#")) newHex = "#" + newHex;
            if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                handleHeaderInput(newHex);
            } else {
                alert("Invalid hex code. Please use format #RRGGBB.");
                groupHexInput.value = groupColorInput.value;
            }
        });

        refs.forEach(({ ref, index }) => {
          const colorArray = getValueByPath(lottieData, ref.path);
          if (!colorArray || colorArray.length < 3) return;
          const [r, g, b] = colorArray;
          const colorHex = rgbToHex(r, g, b);

          const row = document.createElement("div");
          row.className = "color-row";

          const label = document.createElement("label");
          label.textContent = `Instance ${index + 1}`;
          label.htmlFor = `color-input-${index}`;

          const inputGroup = document.createElement("div");
          inputGroup.className = "color-input-group";

          const hexInput = document.createElement("input");
          hexInput.type = "text";
          hexInput.value = colorHex;
          hexInput.id = `hex-input-${index}`;
          hexInput.setAttribute("aria-label", `Hex code for instance ${index + 1}`);

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = colorHex;
          colorInput.id = `color-input-${index}`;
          colorInput.setAttribute("aria-label", `Color picker for instance ${index + 1}`);

          inputGroup.appendChild(hexInput);
          inputGroup.appendChild(colorInput);

          const handleIndividualInput = (newHex) => {
             if (!/^#[0-9A-F]{6}$/i.test(newHex)) return;
             colorInput.value = newHex;
             hexInput.value = newHex;
             updateColor(ref, newHex);
             const allMatch = Array.from(body.querySelectorAll('.color-row input[type="color"]'))
                                  .every(input => input.value === groupColorInput.value);
             if (!allMatch && groupHexInput.value !== "Multiple") {
                 // Optional: Indicate mixed state
             } else if (allMatch) {
                 groupColorInput.value = newHex;
                 groupHexInput.value = newHex;
             }
          };

          /*colorInput.addEventListener("change", (e) => handleIndividualInput(e.target.value));*/

            commitAfterIdle(colorInput, hex => handleIndividualInput(hex), 100);

          hexInput.addEventListener("change", (e) => {
                let newHex = e.target.value.trim();
                if (!newHex.startsWith("#")) newHex = "#" + newHex;
                if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                    handleIndividualInput(newHex);
                } else {
                    alert("Invalid hex code. Please use format #RRGGBB.");
                    hexInput.value = colorInput.value;
                }
          });

          row.appendChild(label);
          row.appendChild(inputGroup);
          body.appendChild(row);
        });

        header.addEventListener("click", (e) => {
          if (e.target.closest('input[type="color"], input[type="text"]')) {
            return;
          }
          const isActive = body.classList.toggle("active");
          header.classList.toggle("active", isActive);
          body.style.display = isActive ? "flex" : "none";
          header.setAttribute('aria-expanded', isActive);
        });
        header.setAttribute('aria-expanded', 'false');
        header.setAttribute('role', 'button');
        header.setAttribute('aria-controls', `accordion-body-${hex.replace('#','')}`);
        body.id = `accordion-body-${hex.replace('#','')}`;

        accordion.appendChild(header);
        accordion.appendChild(body);
        colorEditor.appendChild(accordion);
      });

      updateDownloadButtonsState();
    }

    /**
     * Renders the accordion UI for editing gradient stops.
     */
    function renderGradientEditor() {
        stopEditor.innerHTML = '';

        if (allGradients.length === 0) {
             return;
        }

        allGradients.forEach((gradientStops, index) => {
          const gradientId = String(index);
            const accordion = document.createElement('div');
            accordion.className = 'gradient-accordion';
            accordion.dataset.id = gradientId;

            const header = document.createElement('div');
            header.className = 'gradient-header';

            const headerContent = document.createElement("div");
            headerContent.className = "accordion-header-content";

            const title = document.createElement("span");
            title.textContent = `Gradient ${index + 1}`;

            const gradientPreview = document.createElement('div');
            gradientPreview.className = 'gradient-preview';
            gradientPreview.setAttribute('aria-label', `Preview for Gradient ${index + 1}`);

            headerContent.appendChild(title);
            headerContent.appendChild(gradientPreview);
            header.appendChild(headerContent);

            const contentBody = document.createElement('div');
            contentBody.className = 'gradient-content';
             contentBody.id = `gradient-body-${index}`;


             // --- APPLY PRESERVED STATE ---
              if (preservedGradientAccordionStates[gradientId] === true) {
                  header.classList.add('active');
                  contentBody.classList.add('active'); // Your CSS might use this
                  contentBody.style.display = 'flex'; // Or "block"
                  header.setAttribute('aria-expanded', 'true');
              } else {
                  contentBody.style.display = 'none'; // Default to closed
                  header.setAttribute('aria-expanded', 'false');
              }
              // --- END APPLY PRESERVED STATE ---


            gradientStops.forEach((stop, i) => {
                const row = document.createElement('div');
                row.className = 'stop-row';

                const label = document.createElement('span');
                label.className = 'label';
                label.textContent = `Stop ${i + 1} (${stop.offset}%)`;

                const stopControls = document.createElement('div');
                stopControls.className = 'stop-controls';

                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a ?? 1})`;

                const alphaInput = document.createElement('input');
                alphaInput.type = 'number';
                alphaInput.min = 0;
                alphaInput.max = 100;
                alphaInput.step = 1;
                alphaInput.value = Math.round((stop.a ?? 1) * 100);
                alphaInput.setAttribute('aria-label', `Opacity for Stop ${i + 1} in Gradient ${index + 1}`);
                alphaInput.title = `Opacity (0 to 100)`;

                const inputGroup = document.createElement("div");
                inputGroup.className = "color-input-group";

                const hexInput = document.createElement('input');
                hexInput.type = 'text';
                hexInput.value = rgbToHexGr(stop.r, stop.g, stop.b);
                hexInput.setAttribute('aria-label', `Hex code for Stop ${i + 1} in Gradient ${index + 1}`);
                hexInput.title = `Hex Color Code`;

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = rgbToHexGr(stop.r, stop.g, stop.b);
                colorInput.setAttribute('aria-label', `Color picker for Stop ${i + 1} in Gradient ${index + 1}`);
                colorInput.title = `Color Picker`;

                inputGroup.appendChild(hexInput);
                inputGroup.appendChild(colorInput);

                const updateStopColor = (hex) => {
                    if (!/^#([0-9A-Fa-f]{6})$/i.test(hex)) return;
                    const { r, g, b } = hexToRGBGr(hex);
                    stop.r = r;
                    stop.g = g;
                    stop.b = b;
                    dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${stop.a ?? 1})`;
                    colorInput.value = hex;
                    updateGradientPreviewStyle();
                    updateLottieGradient();
                };

                /*colorInput.addEventListener('change', (e) => {
                  const newHex = e.target.value;
                  const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                  // --- NEW: Record change (delta) ---
                  const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset }; // Include offset for completeness if needed for redo, though not changing it

                  const newRgb = hexToRGBGr(newHex);
                  const newStopData = { r: newRgb.r, g: newRgb.g, b: newRgb.b, a: oldA, offset: stop.offset };

                  recordChange({
                  type: 'GRADIENT_STOP',
                  gradientIndex: index, // Index of the current gradient in allGradients
                  stopIndex: i,         // Index of the current stop in gradientStops
                  oldStopData: oldStopData,
                  newStopData: newStopData
                  });
                  // --- END NEW ---

                  hexInput.value = newHex;
                  updateStopColor(newHex);
                });*/

                commitAfterIdle(colorInput, (newHex) => {
                 const { r: oldR, g: oldG, b: oldB, a: oldA } = stop;

                // Record change (delta) once per drag
                 const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };
                const { r: nr, g: ng, b: nb } = hexToRGBGr(newHex);
                 const newStopData = { r: nr, g: ng, b: nb, a: oldA, offset: stop.offset };

                 recordChange({
                  type: 'GRADIENT_STOP',
                   gradientIndex: index,
                   stopIndex: i,
                   oldStopData,
                   newStopData
                 });

                 hexInput.value = newHex;
                 updateStopColor(newHex);
               }, 150);



                hexInput.addEventListener('change', (e) => {
                  let newHexVal = e.target.value.trim();
                  if (!newHexVal.startsWith("#")) newHexVal = "#" + newHexVal;
                  if (/^#([0-9A-Fa-f]{6})$/i.test(newHexVal)) {
                    const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                    // --- NEW: Record change (delta) ---
                    const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };

                    const newRgb = hexToRGBGr(newHexVal);
                    const newStopData = { r: newRgb.r, g: newRgb.g, b: newRgb.b, a: oldA, offset: stop.offset };

                    recordChange({
                      type: 'GRADIENT_STOP',
                      gradientIndex: index,
                      stopIndex: i,
                      oldStopData: oldStopData,
                      newStopData: newStopData
                    });
                    // --- END NEW ---
                    updateStopColor(newHexVal);
                  } else {
                    alert("Invalid hex code. Please use format #RRGGBB.");
                    hexInput.value = colorInput.value;
                  }
                });

                alphaInput.addEventListener('change', (e) => {
                  let value100 = parseInt(e.target.value, 10);
                  if (isNaN(value100)) value100 = 0;
                  else value100 = Math.max(0, Math.min(100, value100));
                  e.target.value = value100; // Update input field immediately

                  const newAlpha = value100 / 100;
                  const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                  // --- NEW: Record change (delta) ---
                  const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };
                  const newStopData = { r: oldR, g: oldG, b: oldB, a: newAlpha, offset: stop.offset };

                  recordChange({
                    type: 'GRADIENT_STOP',
                    gradientIndex: index,
                    stopIndex: i,
                    oldStopData: oldStopData,
                    newStopData: newStopData
                  });
                  // --- END NEW ---

                  stop.a = newAlpha; // Apply the change to the stop object
                  dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a})`;
                  updateGradientPreviewStyle(); // This function is local to renderGradientEditor
                  updateLottieGradient(); // This updates lottieData based on allGradients
                });;

                stopControls.appendChild(dot);
                stopControls.appendChild(alphaInput);
                stopControls.appendChild(inputGroup);
                row.appendChild(label);
                row.appendChild(stopControls);
                contentBody.appendChild(row);
            });

            function updateGradientPreviewStyle() {
                const sortedStops = [...gradientStops].sort((a, b) => a.offset - b.offset);
                const gradientStyle = `linear-gradient(to right, ${sortedStops.map(stop =>
                    `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a ?? 1}) ${stop.offset}%`
                ).join(', ')})`;
                gradientPreview.style.background = gradientStyle;
            }

            updateGradientPreviewStyle();

            header.addEventListener('click', (e) => {
                 if (e.target.closest('.gradient-preview')) {
                    return;
                 }
                const isActive = contentBody.classList.toggle("active");
                header.classList.toggle("active", isActive);
                contentBody.style.display = isActive ? 'flex' : 'none';
                header.setAttribute('aria-expanded', isActive);
            });

            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('role', 'button');
            header.setAttribute('aria-controls', `gradient-body-${index}`);
            contentBody.id = `gradient-body-${index}`;

            accordion.appendChild(header);
            accordion.appendChild(contentBody);
            stopEditor.appendChild(accordion);
        });

        updateDownloadButtonsState();
    }

    /**
     * Updates the enabled/disabled state of download and editor buttons.
     */
    function updateDownloadButtonsState() {
        const isDataLoaded = !!lottieData;

        // JSON Download Button
        downloadJsonBtn.disabled = !isDataLoaded;
        downloadJsonBtn.style.display = isDataLoaded ? 'inline-flex' : 'none';

        // GIF Download Button
        downloadGifBtn.disabled = !isDataLoaded;
        downloadGifBtn.style.display = isDataLoaded ? 'inline-flex' : 'none';

        // Trim Overlay Button
        openOverlayBtn.disabled = !isDataLoaded;
        // openOverlayBtn.style.opacity = isDataLoaded ? "1" : "0.5"; // Opacity handled by :disabled state

        // *** NEW: Crop Overlay Button ***
        openCropBtn.disabled = !isDataLoaded;
        // openCropBtn.style.opacity = isDataLoaded ? "1" : "0.5"; // Opacity handled by :disabled state

        // GIF Options Card
        const gifOptionsCard = document.getElementById('gifOptionsCard');
        if (gifOptionsCard) {
            gifOptionsCard.style.display = isDataLoaded ? 'block' : 'none';
        }
        // JSON Editor Card
        const jsonEditorCard = document.getElementById('jsonEditorCard');
        if (jsonEditorCard) {
            jsonEditorCard.style.display = isDataLoaded ? 'block' : 'none';
        }
    }

    /**
     * Cleans the Lottie data object by removing internal properties before export.
     */
    function cleanForExport(obj) {
        if (Array.isArray(obj)) {
            return obj.map(cleanForExport);
        }
        if (typeof obj === 'object' && obj !== null) {
            const clean = {};
            for (const [key, value] of Object.entries(obj)) {
                if (key.startsWith('_') || key === 'completed' || key === '__complete') {
                    continue;
                }
                clean[key] = cleanForExport(value);
            }
            return clean;
        }
        return obj;
    }


    /**
     * Handles the file input change event. Reads the JSON file, parses it,
     * initializes the editors, and updates the UI.
     */

     function handleDragOver(e) {
    e.preventDefault();
    dragDropOverlay.classList.add('dragover');
}

function handleDragLeave(e) {
    e.preventDefault();
    dragDropOverlay.classList.remove('dragover');
}

function handleDrop(e) {
    e.preventDefault();
    dragDropOverlay.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        const file = files[0];
        if (file.type === "application/json" || file.name.endsWith('.json')) {
            // Create a fake FileList to reuse the existing handler
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;
            handleFileLoad({ target: fileInput });
        } else {
            alert('Please drop a JSON file');
        }
    }
}


dragDropOverlay.addEventListener('click', () => {
  fileInput.click();
});

// Add event listeners for drag and drop
dragDropOverlay.addEventListener('dragover', handleDragOver);
dragDropOverlay.addEventListener('dragleave', handleDragLeave);
dragDropOverlay.addEventListener('drop', handleDrop);





    function handleFileLoad(e) {
      const file = e.target.files[0];
      initialColorGroups = null;
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          lottieData = JSON.parse(event.target.result);

          if (!lottieData.v || !lottieData.fr || !lottieData.w || !lottieData.h || !lottieData.layers) {
              throw new Error("File does not appear to be a valid Lottie JSON.");
          }

          // --- NEW: Store original data and reset undo/redo stacks ---
          originalLottieDataForReset = JSON.parse(JSON.stringify(lottieData)); // Deep copy for reset
          undoStack = [];
          redoStack = [];
          // --- END NEW ---

          originalFrameRate = lottieData.fr;
          animWidth = lottieData.w;
          animHeight = lottieData.h;

          colorRefs = [];
          allGradients = [];


          findColors(lottieData);


          // Inside handleFileLoad, after findColors(lottieData);
          initialColorGroups = {};
          colorRefs.forEach((ref, i) => {
              const colorArray = getValueByPath(lottieData, ref.path); // Get current (initial) color
              if (!colorArray || colorArray.length < 3) return;
              const [r, g, b] = colorArray;
              const initialHex = rgbToHex(r, g, b); // This is the hex at load time
              if (!initialColorGroups[initialHex]) {
                  initialColorGroups[initialHex] = [];
              }
              // Store the reference, its original overall index, and its original hex for later use
              initialColorGroups[initialHex].push({ ref: ref, index: i, originalHex: initialHex });
          });

          // When loading a new file or resetting, ensure initialColorGroups is cleared:
          // initialColorGroups = null; // At the start of handleFileLoad or in a reset function



          allGradients = extractGradientStops(lottieData);

          // --- Add this Empty State Logic ---
      const emptyStateDiv = document.getElementById('emptyStateDiv');
      const colorInstancesLabel = document.getElementById('colorInstancesLabel');
      const editorAreaDiv = document.getElementById('editorArea'); // Get the parent

      // Check if BOTH colors and gradients are empty
      if (colorRefs.length === 0 && allGradients.length === 0) {
        // Show Empty State
        colorEditor.style.display = 'none';
        stopEditor.style.display = 'none';
        if (colorInstancesLabel) colorInstancesLabel.style.display = 'none'; // Hide heading
        if (emptyStateDiv) emptyStateDiv.style.display = 'flex'; // Show empty state (use flex for centering)
        if (editorAreaDiv) editorAreaDiv.classList.add('is-empty'); // Add class to parent
        console.log("No colors or gradients detected. Displaying empty state.");
      } else {
        // Show Editors
        colorEditor.style.display = 'block'; // Or initial display type if different
        stopEditor.style.display = 'block'; // Or initial display type if different
        if (colorInstancesLabel) colorInstancesLabel.style.display = 'block'; // Show heading
        if (emptyStateDiv) emptyStateDiv.style.display = 'none'; // Hide empty state
        if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty'); // Remove class from parent

        // Render the editors only if there's data
        renderColorPickers();
        renderGradientEditor();
        console.log(`Detected ${colorRefs.length} solid colors and ${allGradients.length} gradients.`);
      }
      // --- End Empty State Logic ---








          renderColorPickers();
          renderGradientEditor();
          reloadLottiePreview();

          windowTitle.textContent = file.name;
          updateDownloadButtonsState(); // This now enables Trim and Crop buttons too

          uploadWrapper.style.transform = 'translate(50%, -50%) scale(0.6)';
          uploadWrapper.style.opacity = '0';




          setTimeout(() => {
            uploadWrapper.style.display = 'none';
            mainContent.style.display = 'flex';
            requestAnimationFrame(() => {
              mainContent.style.transform = 'scale(1)';
              mainContent.style.opacity = '1';

              // --- START: Animation Code ---
                       const windowContainer = document.querySelector('.window-container'); // Get the element to animate
                       const previewArea = document.getElementById('previewArea'); // Get the reference area
                       const jsonSectionCard = document.getElementById('jsonEditorCard');
                       // Ensure elements exist before proceeding
                       if (windowContainer && previewArea) {
                         // Get dimensions and position of the preview area RELATIVE TO VIEWPORT
                         const previewRect = previewArea.getBoundingClientRect();
                         // Get dimensions and position of the window container RELATIVE TO VIEWPORT
                         const windowRect = windowContainer.getBoundingClientRect();

                         const jsonSectionRect = jsonSectionCard.getBoundingClientRect();

                         // Assume the root font size is 16px (change this if your base size differs)
 const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize); // Get actual root font size dynamically

 // Convert windowRect.height to rem
 const paddingTopInRem = (windowRect.height + 62) / rootFontSize;

 // Apply the rem value
 previewArea.style.paddingTop = `${paddingTopInRem}rem`;







                         // --- Log initial positions ---
                         console.log('Preview Area Rect:', previewRect);
                         console.log('Window Container Rect (Initial):', windowRect);
                         // ---


                         let targetLeft;
                         const deviceWidth = window.innerWidth;
                         if (deviceWidth>763.63){
                              let multiplier;
                           if(deviceWidth>1199){ multiplier = 1200/2; }
                           else{ multiplier=deviceWidth/2;}

                           targetLeft = previewRect.left + multiplier*(0.52) - 200;


                         }
                         else {targetLeft = previewRect.left;}


                         // Calculate target position (top-center of previewArea)
                         // Target Top: previewArea's top relative to viewport
                        const targetTop = 112; // Using viewport coordinates directly
                         // Target Left: previewArea's horizontal center (viewport) minus half the window's width





                          // --- Log target positions ---

                         // ---

                         // --- Apply animation styles ---

                         // Set transition *before* changing position
                         windowContainer.style.transition =
                              'transform 580ms cubic-bezier(0.1, 0.1, 0.1, 1), ' +
                              'opacity   450ms cubic-bezier(0.1, 0.1, 0.2, 1)';

                         // Calculate the required translation based on VIEWPORT coordinates
                         // TranslateX = Target Left (Viewport) - Current Left (Viewport)
                         // TranslateY = Target Top (Viewport) - Current Top (Viewport)
                         const translateX = targetLeft - windowRect.left;
                         console.log("windowRectleft:"+ windowRect.left+"targetLeft:"+targetLeft);
                         const translateY = targetTop - windowRect.top;

                         // --- Log calculated translation ---
                         console.log('Calculated TranslateX:', translateX);
                         console.log('Calculated TranslateY:', translateY);
                         // ---




                            // kick off the fade
                            windowContainer.style.opacity = '1';

                         // Apply the transform to trigger the animation
                         windowContainer.style.transform = `translate(${translateX-17}px, ${translateY}px)`;
                         translationtoX = translateX-17;
                         translationtoY = translateY;


                       } else {
                           console.warn("Could not find .window-container or #previewArea for animation.");
                       }
                        // --- END: Animation Code ---






            });
          }, 280);

        } catch (err) {
          console.error("Error processing Lottie file:", err);
          alert(`Error loading file: ${err.message}\nPlease ensure it's a valid Lottie JSON file.`);
          resetUI();
        }
      };

      reader.onerror = () => {
          console.error("Error reading file:", reader.error);
          alert("Error reading file. Please try again.");
          resetUI();
      };

      reader.readAsText(file);
    }

    /**
     * Resets the UI to its initial state.
     */
    function resetUI() {

      // Ensure empty state is hidden and editors/heading are visible on reset
    const emptyStateDiv = document.getElementById('emptyStateDiv');
    const colorEditor = document.getElementById('colorEditor');
    const stopEditor = document.getElementById('stopEditor');
    const colorInstancesLabel = document.getElementById('colorInstancesLabel');
    const editorAreaDiv = document.getElementById('editorArea');

    if (emptyStateDiv) emptyStateDiv.style.display = 'none';
    if (colorEditor) colorEditor.style.display = 'block'; // Or initial display
    if (stopEditor) stopEditor.style.display = 'block'; // Or initial display
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'block';
    if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty');

    // ... your existing reset logic ...
    // --- NEW: Clear history on UI reset if not a full reload ---
    originalLottieDataForReset = null;
    undoStack = [];
    redoStack = [];
    // --- END NEW ---

      location.reload();
    }


    /**
     * Handles the JSON download button click.
     */
    function handleJsonDownload() {
      if (!lottieData) return;

      const exportData = cleanForExport(JSON.parse(JSON.stringify(lottieData)));

      if (originalFrameRate && exportData.fr) {
          exportData.fr = parseFloat((originalFrameRate * currentSpeed).toFixed(3));
      }

      const jsonString = JSON.stringify(exportData, (key, value) => {
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(3));
        }
        return value;
      });

      const blob = new Blob([jsonString], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;

      /*
      const originalFilename = windowTitle.textContent || 'animation';
      const baseFilename = originalFilename.replace(/\.json$/i, '');
      a.download = `${baseFilename}.edited.json`;
      */
      let editedName = windowTitle.textContent.trim(); // Get edited name from the span
if (!editedName) {
    editedName = 'animation'; // Use a default if the user cleared the title
}
// Ensure filename ends with .json (case-insensitive)
if (!/\.json$/i.test(editedName)) {
    editedName += '.json';
}
a.download = editedName; // Use the potentially modified edited name


      a.style.display = 'none';

      document.body.appendChild(a);
      a.click();

      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }


    /**
     * Recursively replaces keyColor with replaceColor for GIF export.
     */
    function replacePureBlack(obj) {
        const keyRGB = hexToRgb(keyColor);
        const replaceRGB = hexToRgb(replaceColor);
        const COLOR_THRESHOLD = 0.01;

        function shouldReplace(r, g, b) {
            return (
            Math.abs(r - keyRGB[0]) < COLOR_THRESHOLD &&
            Math.abs(g - keyRGB[1]) < COLOR_THRESHOLD &&
            Math.abs(b - keyRGB[2]) < COLOR_THRESHOLD
            );
        }

        function processColorArray(colorArray) {
            if (!Array.isArray(colorArray) || colorArray.length < 3) return colorArray;
            const [r, g, b, a = 1] = colorArray;
            if (shouldReplace(r, g, b)) {
                return [...replaceRGB, a];
            }
            return colorArray;
        }

        function traverse(currentObj) {
            if (Array.isArray(currentObj)) {
                currentObj.forEach((item, index) => {
                    if (Array.isArray(item) && item.length >= 3 && item.length <= 4 && item.every(n => typeof n === 'number')) {
                        currentObj[index] = processColorArray(item);
                    } else if (typeof item === 'object') {
                        traverse(item);
                    }
                });
            } else if (currentObj && typeof currentObj === 'object') {
                for (const key in currentObj) {
                    if (!currentObj.hasOwnProperty(key)) continue;
                    const value = currentObj[key];
                    if (key === 'c' && value?.k && Array.isArray(value.k)) {
                        currentObj[key].k = processColorArray(value.k);
                    } else if (key === 'g' && value?.k?.k && Array.isArray(value.k.k) && value.p) {
                        const raw = value.k.k;
                        const stops = value.p;
                        for (let i = 0; i < stops; i++) {
                            const base = i * 4;
                            const r_idx = base + 1;
                            const g_idx = base + 2;
                            const b_idx = base + 3;
                            if (shouldReplace(raw[r_idx], raw[g_idx], raw[b_idx])) {
                                raw[r_idx] = replaceRGB[0];
                                raw[g_idx] = replaceRGB[1];
                                raw[b_idx] = replaceRGB[2];
                            }
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        traverse(value);
                    }
                }
            }
        }
        traverse(obj);
    }


    /**
     * Handles the GIF download button click. Generates the GIF using gif.js.
     */
     function generateGif() {
         if (!lottieData || !window.GIF) {
             alert("GIF generation requires the Lottie data and gif.js library.");
             return;
         }

         // --- UI Feedback: Start Loading ---
         downloadGifBtn.classList.add('btn--loading');
         downloadGifBtn.disabled = true;

         // Optional: Load a Lottie animation as a loading indicator
         // let loadingAnim;
         // try {
         //     loadingAnim = lottie.loadAnimation({ /* options for loader.json */ });
         // } catch(e) { console.warn("Could not load loading animation", e); }


         // --- Prepare Data and Settings ---

         // 1. Deep-clone the master data and replace key colors if needed
         const gifData = JSON.parse(JSON.stringify(lottieData));
         replacePureBlack(gifData); // Replace black/keyColor if necessary

         // 2. Set up a temporary, hidden Lottie instance for rendering frames
         gifContainer.innerHTML = ''; // Clear previous temporary instance
         const tmpAnim = lottie.loadAnimation({
             container: gifContainer,
             renderer: 'svg',
             loop: false, // Don't loop the temporary instance
             autoplay: false, // Don't autoplay
             animationData: gifData
         });

         tmpAnim.addEventListener('DOMLoaded', () => { // Wait for SVG to be ready
             // 3. Calculate GIF dimensions and frame settings
             const scaleValue = parseFloat(gifScaleSelect.value) || 1;
             const aspectRatio = animWidth / animHeight;
             // Calculate dimensions, ensuring they are integers
             const gifW = Math.max(1, Math.round(animWidth * scaleValue));
             const gifH = Math.max(1, Math.round(gifW / aspectRatio));

             const GIF_FPS = 30; // Target FPS for GIF (lower than source is often fine)
             // Calculate delay: 1000ms / FPS. gif.js uses centiseconds (1/100th s), so multiply by 10

             const FRAME_DELAY_CS = Math.round((100 / GIF_FPS) * (1 / 0.127));

             // Calculate total frames based on duration and target FPS
             // Duration = (Out Point - In Point) / Original Frame Rate
             const animDurationSec = (lottieData.op - lottieData.ip) / originalFrameRate;
             // Total frames = Duration * Target FPS (respecting current speed)
             // Limit max frames to prevent excessive generation time/size
             const totalFrames = Math.min(Math.floor((animDurationSec / currentSpeed) * GIF_FPS), 300); // Max 300 frames

             if (totalFrames <= 0) {
                  alert("Calculated duration or frame count is zero. Cannot generate GIF.");
                  cleanupGifGen(tmpAnim);
                  return;
             }


             // 4. Get background settings from UI
             const useTransparentBg = transparentBgCheckbox.checked;
             const customBgColor = bgHexInput.value; // e.g., "#ffffff"

             // 5. Configure gif.js options
             const gifOptions = {
                 workers: Math.max(1, navigator.hardwareConcurrency ? Math.floor(navigator.hardwareConcurrency / 2) : 2), // Use half available cores, min 1, default 2
                 quality: 10, // Lower quality means smaller file, 1-30 range, 10 is default
                 width: gifW,
                 height: gifH,
                 // IMPORTANT: Path to worker script relative to the HTML file or absolute URL
                 workerScript: './gif.worker.js' // Adjust if your worker is elsewhere
             };

             // Set background or transparency based on checkbox
             if (useTransparentBg) {
        // Solid background mode
                  gifOptions.background = customBgColor;
              } else {
                  // Transparent background mode
                  gifOptions.transparent = parseInt(keyColor.replace('#', '0x'), 16);
              }

             // --- Initialize GIF Encoder ---
             let gif;
             try {
                 gif = new GIF(gifOptions);
             } catch (e) {
                 console.error("Failed to initialize GIF encoder:", e);
                 alert("Failed to initialize GIF encoder. Check console and ensure gif.js/worker are loaded correctly.");
                 cleanupGifGen(tmpAnim);
                 return;
             }


             // --- Frame Capturing Loop ---
             const svgEl = gifContainer.querySelector('svg');
             if (!svgEl) {
                 alert("Could not find SVG element for GIF generation.");
                 cleanupGifGen(tmpAnim);
                 return;
             }

             let frameIndex = 0;

             function captureFrame() {
                 if (frameIndex >= totalFrames) {
                     // --- Finalize GIF Rendering ---
                     gif.render();
                     return; // Stop capturing
                 }

                 // Calculate the time and corresponding frame number in the original Lottie timeline
                 const timeSec = (frameIndex / GIF_FPS) * currentSpeed; // Time adjusted for speed
                 const lottieFrame = lottieData.ip + timeSec * originalFrameRate;

                 // Go to the calculated frame on the *temporary* animation instance
                 tmpAnim.goToAndStop(lottieFrame, true); // true = isFrame

                 // Use requestAnimationFrame to ensure the SVG has updated visually
                 requestAnimationFrame(() => {
                     // Create a new canvas for this frame
                     const canvas = document.createElement('canvas');
                     canvas.width = gifW;
                     canvas.height = gifH;
                     const ctx = canvas.getContext('2d');

                     // Draw background color OR the transparency key color onto the canvas
                     ctx.fillStyle = useTransparentBg ? customBgColor : keyColor;
                     ctx.fillRect(0, 0, gifW, gifH);

                     // Serialize the current state of the SVG element
                     // Clone the SVG to avoid potential issues with direct manipulation
                     const svgClone = svgEl.cloneNode(true);
                     // Ensure viewBox, width, and height are set correctly for rendering
                     svgClone.setAttribute('viewBox', `0 0 ${animWidth} ${animHeight}`);
                     svgClone.setAttribute('width', gifW);
                     svgClone.setAttribute('height', gifH);
                     const svgString = new XMLSerializer().serializeToString(svgClone);

                     // Create an Image object to draw the SVG onto the canvas
                     const img = new Image();
                     const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                     const url = URL.createObjectURL(svgBlob);

                     img.onload = () => {
                         // Draw the SVG image onto the canvas (over the background/key color)
                         ctx.drawImage(img, 0, 0, gifW, gifH);
                         URL.revokeObjectURL(url); // Clean up blob URL

                         // Add the canvas frame to the GIF encoder
                         try {
                             gif.addFrame(canvas, { delay: FRAME_DELAY_CS, copy: true });
                         } catch(e) {
                             console.error(`Error adding frame ${frameIndex}:`, e);
                             // Decide whether to stop or continue on error
                         }


                         // Capture the next frame
                         frameIndex++;
                         // Use setTimeout for less aggressive looping than rAF for long tasks
                         setTimeout(captureFrame, 0);
                     };
                     img.onerror = () => {
                         console.error(`Failed to load SVG frame ${frameIndex} into image.`);
                         URL.revokeObjectURL(url);
                         // Decide how to handle frame errors (skip, stop, etc.)
                         // For now, let's try skipping to the next frame
                         frameIndex++;
                          setTimeout(captureFrame, 0);
                     };
                     img.src = url; // Load the SVG blob into the image
                 });
             } // End of captureFrame function

             // --- GIF Rendering Finished Callback ---
             gif.on('finished', (blob) => {
                 // --- UI Feedback: Stop Loading ---
                 cleanupGifGen(tmpAnim); // Includes resetting button state

                 // --- Trigger Download ---
                 const downloadUrl = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = downloadUrl;
                 const originalFilename = windowTitle.textContent || 'animation';
                 const baseFilename = originalFilename.replace(/\.json$/i, '');
                 a.download = `${baseFilename}.gif`;
                 a.style.display = 'none';
                 document.body.appendChild(a);
                 a.click();

                 // Clean up
                 setTimeout(() => {
                     document.body.removeChild(a);
                     URL.revokeObjectURL(downloadUrl);
                 }, 100);
             });

              // --- GIF Rendering Progress Callback (Optional) ---
             gif.on('progress', (p) => {
                 // Update UI with progress if desired (e.g., update a progress bar)
                  console.log(`GIF rendering progress: ${Math.round(p * 100)}%`);
                  // Example: downloadGifBtn.textContent = `Generating... ${Math.round(p * 100)}%`;
             });


             // --- Start Capturing Frames ---
             captureFrame();

         }); // End of tmpAnim DOMLoaded listener

          // Error handling for temporary animation loading
         tmpAnim.addEventListener('data_failed', () => {
             console.error("Temporary Lottie data failed to load for GIF generation.");
             alert("Failed to load animation data for GIF generation.");
             cleanupGifGen(tmpAnim);
         });
         tmpAnim.addEventListener('error', (error) => {
             console.error("Temporary Lottie animation error:", error);
              alert("An error occurred with the animation instance for GIF generation.");
             cleanupGifGen(tmpAnim);
         });


     } // End of generateGif function

     /**
      * Cleans up resources used during GIF generation and resets button state.
      * @param {object} tmpAnim The temporary Lottie animation instance.
      * @param {object} [loadingAnim] Optional loading indicator animation instance.
      */
     function cleanupGifGen(tmpAnim, loadingAnim) {
          // Destroy temporary Lottie instance
         if (tmpAnim) {
             tmpAnim.destroy();
         }
         // Clear the hidden container
         gifContainer.innerHTML = '';

         // Destroy optional loading animation
         if (loadingAnim) {
             loadingAnim.destroy();
         }

         // Reset GIF button state
         downloadGifBtn.classList.remove('btn--loading');
         downloadGifBtn.disabled = false;
         // Restore icon if it was removed
         // downloadGifBtn.style.backgroundImage = "url(...)"; // Or manage via CSS
     }




    /**
     * Opens the advanced GIF render settings overlay.
     */
    function openSettings() {
        document.getElementById('keyColor').value = keyColor;
        document.getElementById('keyHex').value = keyColor;
        document.getElementById('replaceColor').value = replaceColor;
        document.getElementById('replaceHex').value = replaceColor;
        renderSettingsOverlay.classList.add('active');
    }

    /**
     * Saves settings from the overlay and closes it.
     */
    function closeSettings() {
        keyColor = document.getElementById('keyColor').value;
        replaceColor = document.getElementById('replaceColor').value;
        renderSettingsOverlay.classList.remove('active');
    }

    /**
     * Initializes the sync between color pickers and hex inputs in the settings overlay.
     */
    function initSettingsSync() {
        function setupSync(colorId, hexId) {
            const colorInput = document.getElementById(colorId);
            const hexInput = document.getElementById(hexId);
            if (!colorInput || !hexInput) return;

            colorInput.addEventListener('input', () => {
                hexInput.value = colorInput.value;
            });

            hexInput.addEventListener('change', () => {
                let newHex = hexInput.value.trim();
                 if (!newHex.startsWith("#")) newHex = "#" + newHex;
                 if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                    colorInput.value = newHex;
                 } else {
                     hexInput.value = colorInput.value;
                 }
            });
        }
        setupSync('keyColor', 'keyHex');
        setupSync('replaceColor', 'replaceHex');
    }


    // --- Event Listeners ---

    // File Input
    fileInput.addEventListener('change', handleFileLoad);

    // Window Close Button (Reset UI)
    windowCloseBtn.addEventListener('click', resetUI);

    // Speed Slider
    speedSlider.addEventListener('input', (e) => {
      currentSpeed = parseFloat(e.target.value);
      speedValue.textContent = currentSpeed.toFixed(1) + "x";
      if (animationInstance) {
        animationInstance.setSpeed(currentSpeed);
      }
    });

    // Download Buttons
    downloadJsonBtn.addEventListener('click', handleJsonDownload);
    downloadGifBtn.addEventListener('click', generateGif);

    // GIF Background Toggle and Color Picker Sync
    transparentBgCheckbox.addEventListener('change', () => {
        bgColorGroup.classList.toggle('hidden', !transparentBgCheckbox.checked);
    });
    bgColorPicker.addEventListener('input', () => {
      bgHexInput.value = bgColorPicker.value;
    });
    bgHexInput.addEventListener('change', () => {
      let newHex = bgHexInput.value.trim();
      if (!newHex.startsWith("#")) newHex = "#" + newHex;
      if (/^#[0-9A-F]{6}$/i.test(newHex)) {
        bgColorPicker.value = newHex;
      } else {
        alert('Invalid hex code. Use format #RRGGBB.');
        bgHexInput.value = bgColorPicker.value;
      }
    });

    // Open Settings Overlay (Ctrl+Click on label)
    gifExportLabel.addEventListener('click', (e) => {
      if (e.ctrlKey || e.metaKey) {
        openSettings();
      }
    });

    // Open Trim Editor Overlay Button
    openOverlayBtn.addEventListener('click', () => {
        if (!lottieData) return;

        if (overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
        }

        customOverlay.classList.add('active');
        customOverlayIframe.src = 'overlay.html'; // Load Trim editor
        console.log(windowTitle.textContent);
        customOverlayIframe.onload = () => {
            try {

                const overlayData = JSON.parse(JSON.stringify(lottieData));
                if (originalFrameRate && overlayData.fr) {
                    overlayData.fr = originalFrameRate * currentSpeed;
                }
                customOverlayIframe.contentWindow.postMessage({
                    type: 'lottieData',
                    data: overlayData,
                    filename: windowTitle.textContent,
                }, '*'); // Use specific origin in production
            } catch (error) {
                console.error("Error preparing or sending data to trim overlay:", error);
                alert("Could not load data into the trim editor overlay.");
                customOverlay.classList.remove('active');
            }
        };
         customOverlayIframe.onerror = () => {
             console.error("Failed to load trim overlay iframe:", customOverlayIframe.src);
             alert("Failed to load the trim editor overlay (overlay.html).");
             customOverlay.classList.remove('active');
         };
    });

    // *** NEW: Open Crop Editor Overlay Button ***
    openCropBtn.addEventListener('click', () => {
        if (!lottieData) return;

        if (overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
        }

        customOverlay.classList.add('active');
        customOverlayIframe.src = 'crop.html'; // Load Crop editor

        customOverlayIframe.onload = () => {
            try {
                const overlayData = JSON.parse(JSON.stringify(lottieData));
                if (originalFrameRate && overlayData.fr) {
                    overlayData.fr = originalFrameRate * currentSpeed;
                }
                customOverlayIframe.contentWindow.postMessage({
                    type: 'lottieData',
                    data: overlayData,
                    filename: windowTitle.textContent
                }, '*'); // Use specific origin in production
            } catch (error) {
                console.error("Error preparing or sending data to crop overlay:", error);
                alert("Could not load data into the crop editor overlay.");
                customOverlay.classList.remove('active');
            }
        };
         customOverlayIframe.onerror = () => {
             console.error("Failed to load crop overlay iframe:", customOverlayIframe.src);
             alert("Failed to load the crop editor overlay (crop.html).");
             customOverlay.classList.remove('active');
         };
    });
    // *** END NEW LISTENER ***

    // Close Overlay Buttons (Generic Handler)
    overlayCloseButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const overlay = e.target.closest('.overlay');
        if (overlay) {
          overlay.classList.remove('active');
          // If closing the custom editor overlay, destroy its Lottie instance
          if (overlay.id === 'customOverlay' && overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
          }
          // Clear iframe src when closing to stop potential background processes
          if (overlay.id === 'customOverlay') {
              customOverlayIframe.src = 'about:blank';
          }
        }
      });
    });




    function updatePreviewBackground() {
      const previewBgToggle = document.getElementById('previewBgToggle'); // Ref for the new toggle
const windowBody = document.querySelector('.window-body');         // Ref for the preview area body

  if (!previewBgToggle || !windowBody || !bgColorPicker) return;

  if (previewBgToggle.checked) {
    // Solid Background Mode
    windowBody.classList.add('solid-bg-active');
    windowBody.classList.remove('checkerboard'); // Explicitly remove just in case
    windowBody.style.backgroundColor = bgColorPicker.value;
  } else {
    // Checkerboard Mode
    windowBody.classList.remove('solid-bg-active');
    windowBody.classList.add('checkerboard');
    windowBody.style.backgroundColor = ''; // Remove inline style to let CSS handle it
  }
}


    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        updateDownloadButtonsState(); // Set initial button states (disabled)
        initSettingsSync(); // Setup sync for overlay color/hex inputs
        bgColorGroup.classList.toggle('hidden', !transparentBgCheckbox.checked);


        // Ensure empty state is hidden on initial load
 const emptyStateDiv = document.getElementById('emptyStateDiv');
 if (emptyStateDiv) {
     emptyStateDiv.style.display = 'none';
 }



        const previewBgToggle = document.getElementById('previewBgToggle'); // Ref for the new toggle
 const windowBody = document.querySelector('.window-body');         // Ref for the preview area body


 if (previewBgToggle && windowBody && bgColorPicker) {
     previewBgToggle.addEventListener('change', () => {
       updatePreviewBackground();
     });
   } else {
     console.warn("Could not find elements needed for preview background toggle.");
   }

   // Also update preview background if the GIF color picker changes AND solid mode is active
   if (bgColorPicker && windowBody && previewBgToggle) {
     bgColorPicker.addEventListener('input', () => {
       if (previewBgToggle.checked) { // Only update if toggle is ON
         windowBody.style.backgroundColor = bgColorPicker.value;
       }
     });
     // Sync from hex input too
      bgHexInput.addEventListener('change', () => {
       if (previewBgToggle.checked) { // Only update if toggle is ON
         windowBody.style.backgroundColor = bgColorPicker.value; // bgColorPicker is already synced
       }
     });
   }




        // >>> START: Add this block <<<
const initialPositionRef = document.querySelector('.drag-drop-overlay');
const containerToPosition = document.querySelector('.window-container');

if (initialPositionRef && containerToPosition) {
    const refRect = initialPositionRef.getBoundingClientRect();
    // Set initial position based on the drag-drop overlay's viewport position
    // Add scroll offsets in case the page is already scrolled on load

    containerToPosition.style.top = `${refRect.top + window.scrollY}px`;
    containerToPosition.style.left = `${refRect.left + window.scrollX}px`;
    containerToPosition.style.visibility = 'visible'; // Make it visible now that it's positioned
    console.log('Initial window-container position set to:', containerToPosition.style.top, containerToPosition.style.left);
} else {
    console.warn('Could not find .drag-drop-overlay or .window-container for initial positioning.');
    if (containerToPosition) containerToPosition.style.visibility = 'visible'; // Make visible anyway if found
}
// >>> END: Add this block <<<


        if (windowTitle && windowTitle.contentEditable === 'true') {

    // On FOCUS (clicking into the title)
    windowTitle.addEventListener('focus', () => {
        const currentText = windowTitle.textContent.trim();
        // If it ends with .json, remove it for editing
        if (/\.json$/i.test(currentText)) {
            windowTitle.textContent = currentText.replace(/\.json$/i, '');
        }
    });

    // On BLUR (clicking out of the title)
    windowTitle.addEventListener('blur', () => {
        let currentText = windowTitle.textContent.trim();

        // Handle if the user deleted all text
        if (!currentText) {
            currentText = 'animation'; // Default base name
            console.warn("Filename was empty on blur, resetting to 'animation.json'");
        }

        // Append .json if it's missing (case-insensitive)
        if (!/\.json$/i.test(currentText)) {
            windowTitle.textContent = currentText + '.json';
        } else {
            // If it already ends with .json, just make sure the trimmed value is set back
            windowTitle.textContent = currentText;
        }
    });

    // Optional: Prevent line breaks if user presses Enter
    windowTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault(); // Prevent new line
            windowTitle.blur();   // Trigger blur to apply formatting and save
        }
    });




}
let resizeTimer;
window.addEventListener('resize', () => {
clearTimeout(resizeTimer);
resizeTimer = setTimeout(() => {
repositionWindowContainerX();
}, 150); // adjust debounce delay if you like
});


document.addEventListener('keydown', (event) => {
const isCtrlOrCmd = event.ctrlKey || event.metaKey;

if (isCtrlOrCmd && (event.key === 'z' || event.key === 'Z')) {
  event.preventDefault(); // Prevent browser's default undo (e.g., in text fields)
  performUndo();
} else if (isCtrlOrCmd && (event.key === 'y' || event.key === 'Y')) {
  event.preventDefault(); // Prevent browser's default redo
  performRedo();
}
});



});

function repositionWindowContainerX() {



  const container = document.querySelector('.window-container');
    const previewArea = document.getElementById('previewArea');
  const card      = document.getElementById('jsonEditorCard');

  if (!container || !card) return;

  // 1. Get the bounding boxes
  const cardRect = card.getBoundingClientRect();
  const winRect  = container.getBoundingClientRect();
  const previewRect = previewArea.getBoundingClientRect();

  // 2. Compute the X coordinate so that container’s center
  //    aligns with card’s center


  let targetLeft;
  const deviceWidth = window.innerWidth;
  if (deviceWidth>763.63){
       let multiplier;
    if(deviceWidth>1199){ multiplier = 1200/2; }
    else{ multiplier=deviceWidth/2;}

    targetLeft = previewRect.left + multiplier*(0.52) - 200;


  }
  else {targetLeft = previewRect.left;}


   console.log("windowRectAfter:"+winRect.left);

   const translateX = targetLeft - winRect.left+translationtoX;
  // 3. Apply it directly (absolute positioning assumed in your CSS)
  /*container.style.left = `${targetLeft}px`;*/
  container.style.transform = `translate(${translateX}px, ${translationtoY}px)`;

  translationtoX = translateX;





}


window.addEventListener('load', () => {
const overlay   = document.querySelector('.drag-drop-overlay');
const container = document.querySelector('.window-container');
if (!overlay || !container) return;

const { top, left } = overlay.getBoundingClientRect();
container.style.top        = `${top  + window.scrollY}px`;
container.style.left       = `${left + window.scrollX}px`;
container.style.visibility = 'visible';
});

function recordChange(changeDetails) {
  if (!lottieData) return; // Don't record if no data loaded

  undoStack.push(changeDetails);

  // If undo stack exceeds max steps, remove the oldest one
  if (undoStack.length > MAX_UNDO_STEPS) {
    undoStack.shift(); // Removes the first (oldest) element
  }

  // A new change clears the redo stack (handles branching)
  redoStack = [];

  // Optional: Update UI to enable/disable undo/redo buttons if you add them
  // updateUndoRedoButtonStates();
  console.log('Change recorded. Undo stack size:', undoStack.length);
}

function performUndo() {
  if (undoStack.length === 0) {
    if (originalLottieDataForReset) {
      console.log("Undo stack empty, attempting to revert to original file state.");
      // To allow "redoing" the reset, we need to capture the current state vs original
      // This is complex for delta, so for now, reset won't be "redoable" in the same way.
      // A simpler "reset" would just load originalLottieDataForReset.
      // If you want reset to be part of the undo/redo chain, it needs its own delta type.

      // For now, a simple reset:
      lottieData = JSON.parse(JSON.stringify(originalLottieDataForReset));
      undoStack = []; // Clear undo stack after a full reset


      console.log("Reverted to original file state.");
    } else {
      console.log("Undo stack empty and no original data for reset.");
      return;
    }
  } else {
    const changeDetails = undoStack.pop();
    redoStack.push(changeDetails); // Push the change itself to redo

    console.log('Performing undo for:', changeDetails.type);

    if (changeDetails.type === 'SOLID_COLOR') {
      setValueByPath(lottieData, changeDetails.path, [...changeDetails.oldValue]); // Use a copy
    } else if (changeDetails.type === 'GRADIENT_STOP') {
      const gradStops = allGradients[changeDetails.gradientIndex];
      if (gradStops && gradStops[changeDetails.stopIndex]) {
        const stopToUpdate = gradStops[changeDetails.stopIndex];
        stopToUpdate.r = changeDetails.oldStopData.r;
        stopToUpdate.g = changeDetails.oldStopData.g;
        stopToUpdate.b = changeDetails.oldStopData.b;
        stopToUpdate.a = changeDetails.oldStopData.a;
        // Offset is not changed by user, so no need to revert it unless recorded.
        updateLottieGradient(); // This will update lottieData from allGradients
      }
    }else if (changeDetails.type === 'SOLID_COLOR_ACCORDION') { // New Handler
      changeDetails.items.forEach(item => {
        setValueByPath(lottieData, item.path, [...item.oldValue]); // Revert each item to its specific old RGBA
      });
    }
  }

  // Refresh UI (common logic after state change)
  refreshUIStateAndRender();
}



function performRedo() {
  if (redoStack.length === 0) {
    console.log("Redo stack empty, nothing to redo.");
    return;
  }

  const changeDetails = redoStack.pop();
  undoStack.push(changeDetails); // Push the change itself to undo

  console.log('Performing redo for:', changeDetails.type);

  if (changeDetails.type === 'SOLID_COLOR') {
    setValueByPath(lottieData, changeDetails.path, [...changeDetails.newValue]); // Use a copy
  } else if (changeDetails.type === 'GRADIENT_STOP') {
    const gradStops = allGradients[changeDetails.gradientIndex];
    if (gradStops && gradStops[changeDetails.stopIndex]) {
      const stopToUpdate = gradStops[changeDetails.stopIndex];
      stopToUpdate.r = changeDetails.newStopData.r;
      stopToUpdate.g = changeDetails.newStopData.g;
      stopToUpdate.b = changeDetails.newStopData.b;
      stopToUpdate.a = changeDetails.newStopData.a;
      updateLottieGradient(); // This will update lottieData from allGradients
    }
  } else if (changeDetails.type === 'SOLID_COLOR_ACCORDION') { // New Handler
    const { newBaseRgbApplied, items } = changeDetails;
    items.forEach(item => {
      // For redo, apply the newBaseRgbApplied with the original alpha of the item (stored in item.oldValue[3])
      const originalAlpha = item.oldValue.length === 4 ? item.oldValue[3] : 1;
      const newColorWithOriginalAlpha = [...newBaseRgbApplied, originalAlpha];
      setValueByPath(lottieData, item.path, newColorWithOriginalAlpha);
    });
  }

  // Refresh UI (common logic after state change)
  refreshUIStateAndRender();
}



function refreshUIStateAndRender() {


   recordAccordionStates();

  // Re-evaluate colorRefs and allGradients from the current lottieData
  // This is important because lottieData (or allGradients that affects lottieData) has changed.
  colorRefs = [];
  findColors(lottieData); // findColors populates colorRefs

  // For gradients, if updateLottieGradient() was called, lottieData is updated.
  // We need to re-extract 'allGradients' to ensure the UI renders based on the true current state
  // of the gradient structures within lottieData, which might have been reverted.
  allGradients = extractGradientStops(lottieData);

  // Apply empty state logic
  const emptyStateDiv = document.getElementById('emptyStateDiv');
  const colorInstancesLabel = document.getElementById('colorInstancesLabel');
  const editorAreaDiv = document.getElementById('editorArea'); // Get the parent

  if (colorRefs.length === 0 && allGradients.length === 0) {
    document.getElementById('colorEditor').style.display = 'none';
    document.getElementById('stopEditor').style.display = 'none';
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'none';
    if (emptyStateDiv) emptyStateDiv.style.display = 'flex';
    if (editorAreaDiv) editorAreaDiv.classList.add('is-empty');
  } else {
    document.getElementById('colorEditor').style.display = 'block';
    document.getElementById('stopEditor').style.display = 'block';
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'block';
    if (emptyStateDiv) emptyStateDiv.style.display = 'none';
    if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty');
  }

  renderColorPickers();   // Renders based on current colorRefs
  renderGradientEditor(); // Renders based on current allGradients
  reloadLottiePreview();  // Reloads Lottie player with current lottieData
  // updateUndoRedoButtonStates(); // If you have UI buttons
}

function recordAccordionStates() {
  preservedColorAccordionStates = {};
  const colorAccordions = document.querySelectorAll('#colorEditor .accordion');
  colorAccordions.forEach(accordion => {
      const id = accordion.dataset.id; // We'll add this dataset.id in renderColorPickers
      if (id) {
          const header = accordion.querySelector('.accordion-header');
          // An accordion is open if its header has the 'active' class
          preservedColorAccordionStates[id] = header ? header.classList.contains('active') : false;
      }
  });

  preservedGradientAccordionStates = {};
  const gradientAccordions = document.querySelectorAll('#stopEditor .gradient-accordion');
  gradientAccordions.forEach(accordion => {
      const id = accordion.dataset.id; // We'll add this dataset.id in renderGradientEditor
      if (id) {
          const header = accordion.querySelector('.gradient-header');
          preservedGradientAccordionStates[id] = header ? header.classList.contains('active') : false;
      }
  });
}

function commitAfterIdle(inputEl, onCommit, delay = 150) {
  let timer = null;
  inputEl.addEventListener('input', e => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      onCommit(e.target.value);
      timer = null;
    }, delay);
  });
}


  </script>
</body>
</html>
