<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lottiemon</title>
  <link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    /* --- CSS Variables for Consistency --- */
    :root {
      --font-family-base: 'Inter', sans-serif;
      --color-primary: #4CAF50; /* Green */
      --color-primary-dark: #45a049;
      --color-secondary: #2196F3; /* Blue */
      --color-secondary-dark: #1e88e5;
      --color-accent: #FFC107; /* Yellow */
      --color-accent-dark: #fbc02d;
      --color-background: #f7f7f7; /* Slightly lighter */
      --color-surface: #ffffff; /* Card/element background */
      --color-border: #e0e0e0;
      --color-text-primary: #333333;
      --color-text-secondary: #666666;
      --color-text-on-primary: #ffffff;
      --color-text-on-secondary: #ffffff;
      --color-text-on-accent: #333333; /* Dark text on yellow */
      --color-disabled: #cccccc;
      --color-disabled-bg: #eeeeee;
      --color-checkerboard-light: #f0f0f0;
      --color-checkerboard-dark: transparent;

      --spacing-xs: 0.25rem;  /* 4px */
      --spacing-sm: 0.8rem;   /* 8px */
      --spacing-md: 1rem;     /* 16px */
      --spacing-lg: 1.5rem;   /* 24px */
      --spacing-xl: 2rem;     /* 32px */

      --border-radius-sm: 4px;
      --border-radius-md: 16px;
      --border-radius-lg: 16px;
      --border-radius-pill: 999px;

      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);

      --transition-speed: 0.2s ease-in-out;


      /* ... your existing variables ... */
    --overlay-fade-duration: 0.3s; /* Duration for overlay/blur fade */
    --content-fade-delay: 0.2s;  /* Delay before content starts fading in (should be less than overlay duration) */
    --content-fade-duration: 0.4s; /* Duration for content fade */
    }

    /* --- General Reset and Body Styles --- */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-family-base);
      /* padding: var(--spacing-xl); */
      background-color: var(--color-background);
      color: var(--color-text-primary);
      display: flex;
      flex-direction: row;
      gap: 0;
      max-width: 1200px; /* Increased max-width slightly */
      height: 100vh;
      margin: auto;
      line-height: 1.6;
      justify-content: center;
      overflow-x: auto;

    }

    body::-webkit-scrollbar {
  display: none; /* Or width: 0; */
}

    /* --- Layout Areas --- */
    #editorArea, #previewArea {
      display: flex;
      flex-direction: column;
    }

    #editorArea {
      flex: 1;
      overflow-y: auto;
      min-height: 960px;
    height: 93vh; /* Adjusted max-height */
      /* Space for potential scrollbar (hidden) */
      /* Hide scrollbars */
      -ms-overflow-style: none;  /* IE 10+ */
      scrollbar-width: none;     /* Firefox */
      gap: 0;
      /*margin-top: var(--spacing-lg);*/

    }
    #editorArea::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    #previewArea {
      flex: 1.1;
      left:0;
      top: var(--spacing-xl);

      align-items: center; /* Center items in preview area */
      gap: var(--spacing-lg);
    }

    /* --- Upload Wrapper --- */
    #uploadWrapper {
      display: flex;
      gap: var(--spacing-lg);
      flex-direction: column-reverse;
      margin: auto;
      justify-content: center;
      align-items: center;

      opacity: 1;
      transition:
        transform 450ms cubic-bezier(0.8,0,0.9,0.9),
        opacity   280ms linear;
      text-align: center; /* Center the label/button */
    }

      .drag-drop-overlay {

    width: 18rem;
    height: 18rem;
    border: 2px dashed var(--color-border);
    border-radius: 3rem;
    background: rgba(255, 255, 255, 0.9);

    margin: auto;
    align-items: center;
    justify-content: center;

    cursor: pointer;
    z-index: 99;
    transition: all var(--transition-speed);

    /* --- Add these --- */
 background-image: url('dropfile.png'); /* Path to your illustration */
 background-repeat: no-repeat;         /* Don't tile the image */
 background-position: center center;     /* Center the image */
 background-size: contain; /* Or adjust like '80% auto', '150px 150px' etc. */
 /* --- End Add --- */
  }

  .drag-drop-overlay.dragover {
      border-color: var(--color-primary);
      background-color: rgba(76, 175, 80, 0.1);
      transform: scale(1.05);
    }

    @keyframes slideUpFadeIn {
from {
  opacity: 0;
  transform: translateY(40px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
}

@keyframes slideDownFadeIn {
from {
  opacity: 0;
  transform: translateY(-40px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
}

#uploadLabel {
animation: slideUpFadeIn 1350ms cubic-bezier(0.1,0.1,0.1,1) forwards;
}

.drag-drop-overlay {
animation: slideDownFadeIn 950ms cubic-bezier(0.1,0.1,0.1,1) forwards;
}




    /* Style the label like a button */
    #uploadLabel {
      display: inline-block;
      padding: var(--spacing-md) var(--spacing-lg);
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
      border: none;
      border-radius: var(--border-radius-pill);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: background-color var(--transition-speed), transform var(--transition-speed), box-shadow var(--transition-speed);
      box-shadow: var(--shadow-sm);
    }
    #uploadLabel:hover {
      background-color: var(--color-primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    /* Hide the actual file input */
    #fileInput {
      display: none;
    }

    /* --- Main Content Visibility --- */
    #mainContent {
      display: none; /* Initially hidden */
      width: 100%;
      flex-direction: row; /* Re-apply flex row for main layout */

      transform: scale(0.6);
      opacity: 0;
      transition:
        transform 450ms cubic-bezier(0.1,0.1,0.2,1),
        opacity   450ms cubic-bezier(0.1,0.1,0.2,1);
      margin-top: 80px;
    }

    /* --- Buttons --- */
    .btn {
      padding: var(--spacing-sm) var(--spacing-md);
      border: none;
      border-radius: var(--border-radius-pill); /* Pill shape */
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: background-color var(--transition-speed), transform var(--transition-speed), box-shadow var(--transition-speed), opacity var(--transition-speed); /* Added opacity transition */
      display: inline-flex; /* Align icon and text if needed */
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      text-decoration: none; /* Remove underline from potential <a> tags */
      box-shadow: var(--shadow-sm);
      position: relative; /* For loading spinner */
      overflow: hidden; /* Hide spinner overflow */
    }
    .btn:hover:not(:disabled) { /* Added :not(:disabled) */
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    .btn:active:not(:disabled) { /* Added :not(:disabled) */
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    .btn:disabled,
    .btn--loading {
      background-color: var(--color-disabled-bg);
      color: var(--color-disabled);
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
      opacity: 0.5; /* Consistent disabled opacity */
    }

    /* Specific Button Colors */
    .btn--primary {
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
    }
    .btn--primary:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-primary-dark);
    }
    .btn--secondary {
      background-color: var(--color-secondary);
      color: var(--color-text-on-secondary);
    }
    .btn--secondary:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-secondary-dark);
    }
    .btn--accent {
      background-color: var(--color-accent);
      color: var(--color-text-on-accent);
    }
    .btn--accent:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-accent-dark);
    }

    /* Icon Buttons (Download, Trim, Crop) */
    .btn--icon {
      width: 2.5rem; /* Fixed size */
      height: 2.5rem;
      padding: 0; /* Remove padding */
      background-repeat: no-repeat;
      background-position: center;
      background-size: 1.25rem 1.25rem; /* Adjust icon size */
      text-indent: -9999px; /* Hide text */
    }
    #downloadJsonBtn {
      background-color: var(--color-secondary);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>');
    }
    #downloadJsonBtn:hover:not(:disabled) {
      background-color: var(--color-secondary-dark);
    }
    #downloadGifBtn {
      background-color: var(--color-accent);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>'); /* Dark icon */
    }
    #downloadGifBtn:hover:not(:disabled):not(.btn--loading) {
      background-color: var(--color-accent-dark);
    }
    #openOverlayBtn {
      background-color: #e0e0e0; /* Neutral grey */
    background-image: url('trim.svg'); /* Trim icon */
    }
    #openOverlayBtn:not(:disabled) {
       opacity: 1;
    }
    #openOverlayBtn:hover:not(:disabled) {
      background-color: #bdbdbd;
    }

    /* --- NEW CROP BUTTON STYLE --- */
    #openCropBtn {
      background-color: #e0e0e0; /* Neutral grey */
      /* Placeholder Crop Icon - Replace with your actual SVG */
      background-image: url('crop.svg');
    }
     #openCropBtn:not(:disabled) {
       opacity: 1;
     }
    #openCropBtn:hover:not(:disabled) {
      background-color: #bdbdbd;
    }
    /* --- END NEW CROP BUTTON STYLE --- */


    /* --- Loading Spinner (integrated) --- */
    .loading-spinner {
      border: 3px solid rgba(255, 255, 255, 0.3); /* Light border */
      border-top: 3px solid var(--color-text-on-primary); /* Primary spinner color */
      border-radius: 50%;
      width: 1.2rem;
      height: 1.2rem;
      animation: spin 0.8s linear infinite;
      position: absolute; /* Position inside button */
      top: 50%;
      left: 50%;
      margin-top: -0.6rem; /* Center vertically */
      margin-left: -0.6rem; /* Center horizontally */
      display: none; /* Hidden by default */
    }
    .btn--loading .loading-spinner {
      display: block;
    }
    /* Adjust spinner color for accent button */
    .btn--accent.btn--loading .loading-spinner {
        border-top-color: var(--color-text-on-accent);
    }
    /* Hide button icon when loading */
    .btn--loading {
        background-image: none !important; /* Hide icon */
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* --- Inputs & Selects --- */
    input[type="text"],
    input[type="number"],
    select {
      padding: var(--spacing-sm) var(--spacing-md);
      font-size: 0.9rem;
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-pill);
      background-color: var(--color-surface);
      transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
      width: auto; /* Allow shrinking */
      min-width: 60px; /* Minimum width */
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3); /* Focus ring */
    }

    /* Color Inputs */
    input[type="color"] {
      appearance: none;
      -webkit-appearance: none;
      width: 28px; /* Slightly larger */
      height: 28px;
      padding: 0;
      border: none;
      border-radius: 50%; /* Circular */
      cursor: pointer;
      vertical-align: middle;
      transition: transform var(--transition-speed), box-shadow var(--transition-speed);
      box-shadow: var(--shadow-sm);
    }
    input[type="color"]:hover {
        transform: scale(1.1);
        box-shadow: var(--shadow-md);
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 50%;
    }
    input[type="color"]::-webkit-color-swatch {
      border: 1px solid rgba(0,0,0,0.1); /* Subtle border */
      border-radius: 50%;
    }
    input[type="color"]::-moz-color-swatch {
        border: 1px solid rgba(0,0,0,0.1);
        border-radius: 50%;
    }

    /* Input Groups (Color + Hex) */
    .color-input-group {
      display: inline-flex; /* Use inline-flex */
      align-items: center;
      gap: var(--spacing-sm);
      background-color: #f0f0f0; /* Keep light grey bg */
      padding: var(--spacing-xs) 8px;
      border-radius: var(--border-radius-pill);
    }
    .color-input-group input[type="text"] {
      border: none;
      background: transparent;
      text-align: center;
      font-size: 0.9rem;
      padding: var(--spacing-xs) 0; /* Minimal padding */
      width: 70px; /* Fixed width for hex */
      border-radius: 0; /* Remove radius */
      box-shadow: none;
    }
    .color-input-group input[type="text"]:focus {
        box-shadow: none; /* No focus ring inside group */
    }
    .color-input-group input[type="color"] {
        width: 20px; /* Smaller inside group */
        height: 20px;
        box-shadow: none;
    }
    .color-input-group input[type="color"]:hover {
        transform: none;
        box-shadow: none;
    }

    /* Select Dropdown */
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding-right: var(--spacing-xl); /* Space for arrow */
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 6'><path fill='%23999' d='M0 0l5 6 5-6z'/></svg>");
      background-repeat: no-repeat;
      background-position: right var(--spacing-md) center;
      background-size: 0.6rem 0.36rem;
    }

    /* --- Accordion Styles --- */

    #colorEditor,#stopEditor, #animatedColorEditor, #animatedGradientEditor, #textEditorContainer{
      margin: 0 auto;
     width: 85%;

    }

    .accordion, .gradient-accordion {
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-md);
      box-shadow: var(--shadow-sm);
      overflow: hidden; /* Contain children */
       /* Remove space between accordions */
       margin-bottom: var(--spacing-sm);

    }



    .accordion-header, .gradient-header {
      height:60px;
      padding: var(--spacing-sm) var(--spacing-md);
      background-color: #f9f9f9; /* Slightly off-white header */
      font-weight: 600; /* Bolder */
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color var(--transition-speed);
      position: relative; /* For icon positioning */
      border-bottom: 1px solid var(--color-border); /* Separator line */


    }
    .accordion-header:hover, .gradient-header:hover {
      background-color: #f0f0f0;
    }
    .accordion-header.active {
        border-bottom-color: transparent; /* Remove border when open */
    }

    /* Accordion Icon */
    .accordion-header::after, .gradient-header::after {
      content: ''; /* Required, but empty */
      display: inline-block; /* Needed for width/height */
      width: 1em;  /* Adjust size as needed */
      height: 1em; /* Adjust size as needed */
      opacity: 0.6;
      /* Placeholder Down Chevron - Replace with your actual SVG */
      background-image: url('down-chevron.svg');
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain; /* Scale SVG to fit dimensions */
      transition: transform 0.3s ease-in-out; /* Keep your transition */
      margin-left: 8px; /* Adjust spacing if needed */
      vertical-align: middle; /* Align icon nicely with text */
    }

    .accordion-header.active::after, .gradient-header.active::after {
      transform: rotate(180deg); /* Rotate the SVG */
    }

    .accordion-header-content { /* Wrapper for title and controls */
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-grow: 1; /* Take remaining space */
        margin-right: var(--spacing-sm); /* Space before icon */
    }

    .accordion-header-controls {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .accordion-body, .gradient-content {
      padding: var(--spacing-md);
      display: none; /* Hidden by default */
      flex-direction: column;
      gap: 0.2rem;
      border-top: 1px solid var(--color-border); /* Separator when open */
    }
    .accordion-body.active, .gradient-content.active {
        display: flex; /* Show when active */
    }

    .color-row, .stop-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) 0; /* Vertical padding */
      gap: var(--spacing-md);
    }
    .stop-row .label {

        flex-shrink: 0;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
    }
    .stop-row .stop-controls { /* Group controls on the right */
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }
    .color-dot {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      border: 1px solid rgb(2 2 2 / 19%);
        flex-shrink: 0; /* Prevent shrinking */
        margin-left: -5px;
    }

    .stop-row input[type="number"] { /* Alpha input */
      appearance: none; /* Consider keeping this if you don't want default styling */
      -moz-appearance: textfield; /* Hides spinners in Firefox */
      border: none;
      border-radius: 999px;
      padding: 8px 8px 8px 10px; /* Increased right padding: top/right/bottom/left */
      background-color: #f0f0f0;
      transition: background-color 0.2s ease, border 0.2s ease;
      min-width: 68px;
      font-size: 16px;
      text-align: left; /* Align text to the left */
    }

    /* Hide spinners in WebKit browsers (Chrome, Safari) */
    .stop-row input[type="number"]::-webkit-outer-spin-button,
    .stop-row input[type="number"]::-webkit-inner-spin-button {
      margin-left: 6px; /* Optional: Adds space before spinner */
    }

    .gradient-preview {
      height: 16px; /* Taller */
      width: 80px;
      border-radius: var(--border-radius-pill);
      border: 1px solid var(--color-border);
      margin-left: var(--spacing-sm);
      pointer-events: none;
    }

    /* --- Section Cards (Preview Area) --- */
    .section-card {
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-lg); /* More rounded */
      width: 100%; /* Full width within preview area */
      max-width: 400px; /* Max width for cards */
      padding: var(--spacing-md) var(--spacing-lg);
      box-shadow: var(--shadow-md);
    }
    .section-card h3, .editor-heading {
      font-size: 0.75rem; /* Smaller heading */
      font-weight: 700; /* Bold */
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--color-text-secondary); /* Grey heading */
      margin-bottom: var(--spacing-md); /* Space below heading */
      display: block; /* Ensure it takes full width */
    }
    .editor-heading{ margin:0 auto; width: 85%;  margin-top: 2.0rem ;  margin-bottom: 1.6rem ; }

    /* Headers within cards */
    .json-header, .gif-settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gif-settings-header {  margin-bottom: var(--spacing-md); }/* Reset margin if h3 already has it */


    .json-header h3, .gif-settings-header h3 {
        margin-bottom: 0; /* Remove margin from h3 inside header */
    }
    .json-header-controls, .gif-header-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    /* GIF Settings Rows */
    .gif-settings {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: var(--spacing-md);
      gap: var(--spacing-md);
    }
    .gif-settings label {
      font-weight: 500; /* Medium weight */
      font-size: 0.9rem;
      color: var(--color-text-primary);
      flex-shrink: 0; /* Prevent label shrinking */
    }
    .gif-settings .color-input-group-bg { /* Specific styling for BG color group */
        background-color: #f0f0f0;
        padding: var(--spacing-xs);
	    padding-left: 8px;
        border-radius: var(--border-radius-pill);
        display: inline-flex; /* Changed to inline-flex */
        align-items: center;
        gap: var(--spacing-xs);
    }
    .gif-settings .color-input-group-bg input[type="text"] {
        width: 70px;
        border: none;
        background: transparent;
        text-align: center;
        padding: var(--spacing-xs) 0;
    }
    .gif-settings .color-input-group-bg input[type="color"] {
        width: 20px;
        height: 20px;
        box-shadow: none;
    }

    /* --- Toggle Switch --- */
    .switch {
      position: relative;
      display: inline-block;
      width: 44px; /* Slightly wider */
      height: 24px;
      vertical-align: middle; /* Align with labels */
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: var(--transition-speed);
      border-radius: var(--border-radius-pill);
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px; /* Larger handle */
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: var(--transition-speed);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .switch input:checked + .slider {
      background-color: var(--color-primary);
    }
    .switch input:checked + .slider:before {
      transform: translateX(20px); /* Adjusted translation */
    }
    .switch input:focus + .slider {
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3); /* Focus ring */
    }

    /* --- Speed Control Slider --- */
    .speed-control {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      width: 100%; /* Full width within its container */
      margin: var(--spacing-sm) 0; /* Vertical margin */
      background-color: white;

      border-radius: var(--border-radius-lg); /* More rounded */
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      width: 100%; /* Full width within preview area */
      max-width: 400px; /* Max width for cards */
      padding: var(--spacing-md) var(--spacing-lg);

    }
    .slider-wrapper {
      flex-grow: 1; /* Take available space */
      position: relative;
    }
    /* Range Input Base */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px; /* Track height */
      background: #ddd; /* Track background */
      border-radius: var(--border-radius-pill);
      cursor: pointer;
      outline: none;
      margin: var(--spacing-sm) 0; /* Add some vertical margin */
    }
    /* Thumb (WebKit) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px; /* Thumb size */
      height: 20px;
      background: var(--color-surface); /* Thumb color */
      border: 2px solid var(--color-primary); /* Thumb border */
      border-radius: 50%;
      cursor: pointer;
      margin-top: -15px; /* Adjust vertical position */
      box-shadow: var(--shadow-sm);
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    input[type="range"]:hover::-webkit-slider-thumb {
      background-color: var(--color-primary);
    }
    input[type="range"]:active::-webkit-slider-thumb {
        transform: scale(1.1);
    }
    input[type="range"]:focus::-webkit-slider-thumb {
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4); /* Focus ring on thumb */
    }
    /* Thumb (Mozilla) */
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--color-surface);
      border: 2px solid var(--color-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }
    input[type="range"]:hover::-moz-range-thumb {
      background-color: var(--color-primary);
    }
    input[type="range"]:active::-moz-range-thumb {
        transform: scale(1.1);
    }
    input[type="range"]:focus::-moz-range-thumb {
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4);
    }

    /* Speed Value Display */
    .speed-value {
      background-color: var(--color-primary);
      color: var(--color-text-on-primary);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--border-radius-pill);
      font-size: 0.9rem;
      font-weight: 600;
      min-width: 60px; /* Ensure space */
      text-align: center;
      white-space: nowrap; /* Prevent wrapping */
      box-shadow: var(--shadow-sm);
    }

    /* --- Preview Window --- */
    .window-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 400px; /* Max width for preview */
      background: var(--color-surface);
      border-radius: var(--border-radius-lg); /* Match cards */
      box-shadow: var(--shadow-md); /* More prominent shadow */
      overflow: hidden;
      border: 1px solid var(--color-border);
      opacity: 0;
      z-index:98;

    }
    .window-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f2f2f2; /* Light grey header */
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--color-border);
    }
    .window-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--color-text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis; /* Handle long filenames */
      margin-right: var(--spacing-sm);
    }
    .window-close {
      width: 20px; /* Larger close button */
      height: 20px;
      line-height: 18px; /* Adjust line height */
      text-align: center;
      border: none;
      border-radius: 50%;
      background: #ff5f57; /* Mac red */
      color: rgba(0,0,0,0.6); /* Darker symbol */
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      padding: 1px 0 0 1px;
      transition: background-color var(--transition-speed);
      flex-shrink: 0; /* Prevent shrinking */
    }
    .window-close:hover {
      background: #e0483e;
    }
    .window-body {
      position: relative;
      flex: 1; /* Take remaining space */
      display: flex;
      align-items: center;
      justify-content: center;
       /* Add some padding */


      width: 100%; /* Ensure it fills container width */
      overflow: visible; /* Lottie might overflow slightly */
      ransition: background-color var(--transition-speed); /* Smooth color transition */
    }
    /* Checkerboard Background */
    .checkerboard {
      background-image: linear-gradient(45deg, var(--color-checkerboard-light) 25%, var(--color-checkerboard-dark) 25%),
                        linear-gradient(-45deg, var(--color-checkerboard-light) 25%, var(--color-checkerboard-dark) 25%),
                        linear-gradient(45deg, var(--color-checkerboard-dark) 75%, var(--color-checkerboard-light) 75%),
                        linear-gradient(-45deg, var(--color-checkerboard-dark) 75%, var(--color-checkerboard-light) 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
    #lottiePreview {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain; /* Ensure Lottie fits */
      display: block; /* Remove extra space below */
    }

    /* Style for the container holding the text and toggle */
  .preview-bg-toggle {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-sm);
    z-index: 10;
    display: flex; /* Arrange text and switch horizontally */
    align-items: center; /* Vertically align items */
    gap: var(--spacing-sm); /* Space between text and switch */
    background-color: rgba(255, 255, 255, 0.7); /* Optional: slight white bg for contrast */
    padding: var(--spacing-xs) 10px; /* Optional: Padding */
    padding-right: 6px;
    border-radius: var(--border-radius-pill); /* Optional: Rounded corners */
    backdrop-filter: blur(2px); /* Optional: Frosted glass effect */
    box-shadow: 0 1px 2px rgba(0,0,0,0.1); /* Optional: Subtle shadow */
  }

  /* Style for the text label */
  .preview-bg-label {
    font-size: 0.75rem; /* Small text */
    font-weight: 600; /* Medium bold */
    color: var(--color-text-secondary); /* Grey text */
    white-space: nowrap; /* Prevent wrapping */
    cursor: default; /* Indicate it's just text */
  }

  /* Ensure the switch label itself doesn't add extra spacing */
  .preview-bg-toggle .switch {
    margin: 0; /* Reset margin if any */
    transform: scale(0.8); /* Keep the smaller scale if you liked it */
  }

  /* Remove checkerboard when solid background is active */
  .window-body.solid-bg-active {
    background-image: none; /* Remove the checkerboard gradient */
  }




    /* --- Overlays --- */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.6); /* Darker overlay */
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: var(--spacing-md); /* Padding for smaller screens */

    }
    .overlay.active {
        display: flex; /* Show when active */
    }
    .overlay-content {
      background: var(--color-surface);
      width: 80%;
      height: 80%;
      max-height: 80vh;
      /*padding: var(--spacing-lg);*/
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-lg);
      position: relative;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added to allow iframe to fill height */
      flex-direction: column; /* Added */

    }


    .overlay-close {
        position: absolute;
        top: 27px;
        right: 20px;
        cursor: pointer;
        width: 28px;              /* Button width */
        height: 28px;             /* Button height */
        border-radius: 50%;       /* Keep it circular */
        background-color: #ff5f57;/* Keep red background */

        /* --- SVG Icon Styling --- */
        background-image: url('close.svg'); /* Path to your SVG file */
        background-repeat: no-repeat;       /* Prevent tiling */
        background-position: center;        /* Center the SVG */
        background-size: 55%;               /* Size of SVG within button (adjust %) */
        /* --- End SVG Icon Styling --- */

        /* --- White Border --- */
        border: 3px solid white;            /* Add 3px solid white border */
        /* --- End White Border --- */

        padding: 0;                         /* Keep padding 0 */
        /* Flex properties are optional now but don't hurt */
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease, transform 0.2s ease; /* Keep transitions */
       /* Keep optional shadow */
        /* color: transparent; was removed */
    }

    /* Keep these hover and focus rules (or modify if they conflict visually) */
    .overlay-close:hover {
        background-color: #e0483e; /* Darker red on hover */
        transform: scale(1.1);    /* Slightly enlarge on hover */
    }

    .overlay-close:focus {
        outline: none;            /* Remove default outline */
        box-shadow: 0 0 0 3px rgba(255, 95, 87, 0.6); /* Keep focus ring */
    }





    }
    .overlay h3 { /* Style heading inside overlay */
        margin-bottom: var(--spacing-lg);
        font-size: 1.2rem;
        color: var(--color-text-primary);
        flex-shrink: 0; /* Prevent shrinking */
    }
    /* Settings Rows inside Overlay */
    .setting-row {
      margin-bottom: var(--spacing-lg); /* Increased spacing */
      display: flex;
      flex-direction: column; /* Stack label and controls vertically */
      align-items: flex-start; /* Align items to start */
      gap: var(--spacing-sm);
       flex-shrink: 0; /* Prevent shrinking */
    }
    .setting-row label {
      font-weight: 500;
      font-size: 0.9rem;
      color: var(--color-text-primary);
    }
    .setting-row .controls { /* Wrapper for inputs */
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }
    .setting-row input[type="text"] {
      width: 100px; /* Fixed width for hex in overlay */
    }

    /* Iframe in Overlay */
    #customContent {
      width: 100%;
      border: 1px solid var(--color-border); /* Add border */
      border-radius: var(--border-radius-md);
      flex-grow: 1; /* Added to fill remaining space */
    }

    /* Hidden GIF Container */
    #gifContainer {
      position:absolute;
      top:-9999px; left:-9999px;
      width:0; height:0;
      overflow:hidden;
    }

    /* --- Media Queries for Responsiveness --- */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        padding: var(--spacing-lg); /* Adjust padding */
      }
      #editorArea {
        max-height: none; /* Remove max-height */
        order: 2; /* Editor below preview */
        padding-right: 0; /* No padding needed */
      }
      #previewArea {
        position: static; /* Remove sticky */
        order: 1; /* Preview first */
        width: 100%;
        flex: none; /* Reset flex property */
      }
      .window-container, .section-card {
          max-width: none; /* Allow cards/preview to fill width */
      }
      .speed-control {
          flex-direction: column; /* Stack slider and value */
          align-items: stretch; /* Stretch items */
        }
      .speed-value {
          margin-top: var(--spacing-sm);
          text-align: center;
      }
       .overlay-content {
           width: 95%; /* Use more width on smaller screens */
           height: 90%;
           max-height: 90vh;
       }
    }

    /* --- Accessibility Helper --- */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    .gif-settings .color-input-group-bg {
        transition: opacity 0s ease, visibility 0s ease;
        opacity: 1;
        visibility: visible;
      }

      .gif-settings .color-input-group-bg.hidden {
        opacity: 0;
        visibility: hidden;
        position: absolute; /* Remove from layout flow */
        pointer-events: none; /* Make it non-interactive when hidden */
      }

      /* Add wrapper to maintain consistent height */
      .gif-settings > div {
        position: relative;
        min-height: 32px; /* Match your control height */
        display: flex;
        align-items: center;
      }


      /* --- Overlays --- */
      .overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.85); /* Backdrop color */
        display: flex; /* Keep flex for centering */
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: var(--spacing-md);

        /* --- BACKDROP ANIMATION (Fade only) --- */
        opacity: 0;
        pointer-events: none; /* Prevent interaction when hidden */
        /* Define backdrop closing transition */
        transition:
            /* Delay the backdrop fade-out until the content slide (350ms) is done */
            opacity 300ms linear 350ms, /* MODIFIED LINE */
            /* Delay pointer-events until near the end of the backdrop fade */
            pointer-events 0s linear 600ms; /* MODIFIED LINE */
      }

.overlay.active {
    /* --- BACKDROP ANIMATION (Fade only) --- */
    opacity: 1;
    pointer-events: auto; /* Allow interaction when visible */
    /* Define backdrop opening transition */
    transition: opacity 200ms linear; /* Faster fade in for backdrop */
}

.overlay-content {
  background: var(--color-surface);
  max-width: 1024px;
  width: 90%;
  height: 90%;
  max-height: 80vh;
  /*padding: var(--spacing-lg);*/
  border-radius: var(--border-radius-lg);
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow-y: auto;
  display: flex;
  flex-direction: column;

  /* --- CONTENT ANIMATION (Slide + Fade) --- */
  opacity: 0;
  /* Start positioned lower down */
  transform: translateY(60px);
  /* Define content closing transition */
  transition: transform 350ms cubic-bezier(0.9, 0, 0.9, 0.9), /* Slide down */
              opacity 300ms linear; /* Fade out */
}

.overlay.active .overlay-content {
    /* --- CONTENT ANIMATION (Slide + Fade) --- */
    opacity: 1;
    /* End state: original position */
    transform: translateY(0);
    /* Define content opening transition */
    /* Add a small delay (e.g., 50ms) so backdrop starts fading first */
    transition: transform 550ms cubic-bezier(0.1, 0.1, 0.1, 1) 50ms, /* Slide up */
                opacity 400ms linear 100ms; /* Fade in (slightly longer delay) */
}

/* (Keep your other overlay styles like .overlay-close, .overlay h3 etc.) */
.window-title[contenteditable="true"] {
    cursor: text;
    min-width: 50px; /* Prevent it becoming too small */
    display: inline-block; /* Needed for min-width */
    padding: 2px 4px; /* Add some internal spacing */
    margin: -2px -4px; /* Compensate for padding */
    border-radius: 3px;
}
.window-title[contenteditable="true"]:focus {
    outline: 1px solid var(--color-primary); /* Highlight border on focus */
    background-color: #f0f0f0; /* Slight background change on focus */
}


/* Add these styles to your CSS */
#emptyStateDiv {
  display: none; /* Hidden by default */
  height: 100%; /* Set the desired height */
  max-height: 900px;
  width: 100%;
  display: flex; /* Use flexbox for centering */
  justify-content: center; /* Center horizontally */
  align-items: center; /* Center vertically */
  text-align: center;
  padding: var(--spacing-lg);
  /* Optional visual styling */
  pointer-events: none;
  border-radius: var(--border-radius-md);
  margin-top: -22%;
  box-sizing: border-box; /* Include padding/border in height */
}

#emptyStateDiv img {
  max-width: 68%; /* Prevent image from becoming too large */
  max-height: 68%;
  object-fit: contain; /* Ensure image scales nicely */
  opacity: 0.7; /* Optional: make it slightly faded */
}

/* Optional: Hide the main heading when the empty state is shown */
#editorArea.is-empty #colorInstancesLabel {
    display: none;
}

#midsection{
  height: 100%;
  flex: 0;

}


.text-accordion .gradient-header { /* Or your specific header class */
  /* Potentially adjust padding or item alignment if text input makes it crowded */
}

.text-editor-input {
  border: 1px solid var(--color-border);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-pill);
  font-size: 0.9rem;
  /* Add any other specific styles */
}

.text-instance-row {
    display: flex;
    align-items: center;
    gap: var(--spacing-md); /* Or your preferred gap */
    padding: var(--spacing-sm) 0; /* Vertical padding, no horizontal */

}
.text-instance-row:last-child {
    border-bottom: none; /* Remove border from last item */
}

.text-instance-row .label {

    flex-shrink: 0;
    font-size: 0.9rem;
    color: var(--color-text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.text-instance-row .text-editor-input {
    flex-grow: 1;
    /* Add any other specific styles from your previous .text-editor-input */
    border: 1px solid var(--color-border);
    padding: 0.44rem var(--spacing-sm);
    border-radius: var(--border-radius-pill);
    font-size: 0.9rem;
}

.right-side-of-header{
max-width: 150px;
  display: flex;
  align-items: right;

}


/* --- Layer Name Pill Label --- */
.layer-name-pill {
display: inline-flex; /* Align icon and text */

gap: var(--spacing-xs); /* Space between icon and text */
color: var(--color-text-secondary); /* Darker grey text */
padding: 0rem 0.5rem;
border-radius: var(--border-radius-pill); /* Fully rounded */
font-size: 0.7rem; /* Smaller text size */
font-weight: 500;
 /* Space from the main label */
vertical-align: middle; /* Align nicely with the main label */
cursor: default; /* Indicate it's not directly interactive (hover provides info) */
white-space: nowrap; /* Prevent text wrapping */
max-width: 150px; /* Prevent overly long pills */
height: 25px;
overflow: hidden;
text-overflow: ellipsis;
align-items: center;
padding-top: 0.1rem;
}

.layer-name-pill img {
  width: 0.8rem;
      height: 0.8rem;
      fill: currentColor;
      flex-shrink: 0;
      opacity: 0.4;
      margin-right: 0.1rem;
    }

.title-wrapper{
  display: flex;
  width: 250px;
  gap: 0.4rem;
}

.layer-name-pill {
  transition: background-color var(--transition-speed), color var(--transition-speed);
}
/* when hd=true (i.e. “toggled on”/hidden), make it soft-red */
.layer-name-pill.hidden {
  background-color: #ffe6e6;
  color: #a00;
}
/* optional: slightly dim when off */
.layer-name-pill.hidden img {
  opacity: 0.2;
}

.layer-name-pill:hover {
  background-color: rgba(0, 0, 0, 0.05);   /* subtle highlight */
  color: rgba(0, 0, 0, 0.2);             /* or another accent color */
}


#openAssetReplacerBtn {
  background-color: #e0e0e0; /* Neutral grey or another color */
  /* Replace with your actual SVG icon for assets */
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>'); /* Example placeholder icon */
}
#openAssetReplacerBtn:not(:disabled) {
   opacity: 1;
}
#openAssetReplacerBtn:hover:not(:disabled) {
  background-color: #bdbdbd;
}

#headerLottie{
  cursor: pointer;
  width:150px; height:50px;
}


.coffeeRoast-hidden, .coffeeRoast-visible { /* Consolidate common styles */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.0); /* Start transparent */
    backdrop-filter: blur(0px); /* Start with no blur */
    -webkit-backdrop-filter: blur(0px);
    z-index: 1000;
    display: flex; /* Keep flex for centering */
    justify-content: center;
    align-items: center;
    opacity: 0; /* Start fully transparent */
    visibility: hidden; /* Start hidden */
    transition: background-color var(--overlay-fade-duration) ease-in-out,
                backdrop-filter var(--overlay-fade-duration) ease-in-out,
                -webkit-backdrop-filter var(--overlay-fade-duration) ease-in-out,
                opacity var(--overlay-fade-duration) ease-in-out,
                visibility 0s linear var(--overlay-fade-duration); /* Hide after fade out */
}


.coffeeRoast-visible {
    background-color: rgba(0, 0, 0, 0.65); /* Target background */
    backdrop-filter: blur(8px);            /* Target blur */
    -webkit-backdrop-filter: blur(8px);
    opacity: 1;                            /* Target opacity */
    visibility: visible;                   /* Make visible */
    transition-delay: 0s; /* Ensure visibility transition doesn't delay fade-in */
     transition: background-color var(--overlay-fade-duration) ease-in-out,
                backdrop-filter var(--overlay-fade-duration) ease-in-out,
                -webkit-backdrop-filter var(--overlay-fade-duration) ease-in-out,
                opacity var(--overlay-fade-duration) ease-in-out,
                visibility 0s linear 0s; /* Show immediately for fade in */
}

#baristaViewContainer {
    background: none;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
    width: 80%;
    max-width: 600px;
    height: 70%;
    max-height: 500px;
    display: flex;
    flex-direction: column;
    opacity: 0; /* Initially hidden */
    transform: scale(0.95); /* Optional: slight scale effect */
    transition: opacity var(--content-fade-duration) ease-in-out var(--content-fade-delay),
                transform var(--content-fade-duration) ease-in-out var(--content-fade-delay);
}

.coffeeRoast-visible #baristaViewContainer {
    opacity: 1;
    transform: scale(1);
}
#freshBrewFrame {
  width: 400px;
  height: 600px;
  border: none;
}

#closeEspressoShotBtn {
  margin-top: 10px;
  padding: 8px 15px;
  cursor: pointer;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 4px;
  align-self: flex-end;
}





#top-bar{
max-width: 1200px;
  position: absolute;
  display: flex;
  left: 50%;
  top: 0;
  width: 100%;
  height: 80px;
  transform: translateX(-50%);

}

.page-logo {



  max-width: 700px;            /* cap its size */
  height: 36px;
  z-index: 100;
  margin-top: 3px;
  margin-left: 4px;              /* sit above everything else */
}

.visibility-toggle{
  height: 18px;
  display: flex;
}

.textVisibility{
  margin: auto;
  height: 16px;
  width: 16px;
  margin-top: 2px;
  opacity: 0.6;
}


.lottie-player-controls {
       display: flex;
       align-items: center;
       gap: var(--spacing-sm);
       padding: var(--spacing-sm) var(--spacing-md);
       background-color: rgba(255, 255, 255, 1); /* Semi-transparent white */
       backdrop-filter: blur(5px); /* Frosted glass effect */
       border-top: 1px solid var(--color-border);
       width: 100%;
       position: relative; /* For speed slider pop-up */
   }

   .control-button {
       background: none;
       border: none;
       cursor: pointer;
       padding: var(--spacing-xs);
       display: flex;
       align-items: center;
       justify-content: center;
       color: var(--color-text-primary);
       transition: color var(--transition-speed);
   }
   .control-button:hover {
       color: var(--color-primary);
   }
   .control-button svg {
       width: 20px;
       height: 20px;
       fill: currentColor;
   }

   #lottieSeekbar {
       flex-grow: 1;
       height: 8px;
       -webkit-appearance: none;
       appearance: none;
       background: var(--color-border);
       border-radius: var(--border-radius-pill);
       cursor: pointer;
       outline: none;
   }
   #lottieSeekbar::-webkit-slider-thumb {
       -webkit-appearance: none;
       appearance: none;
       width: 16px;
       height: 16px;
       background: var(--color-primary);
       border-radius: 50%;
       cursor: pointer;
       box-shadow: var(--shadow-sm);
       margin-top: 0px; /* Adjust to center on track */
   }
   #lottieSeekbar::-moz-range-thumb {
       width: 16px;
       height: 16px;
       background: var(--color-primary);
       border-radius: 50%;
       border: none;
       cursor: pointer;
       box-shadow: var(--shadow-sm);
   }

   .speed-control-pill {
       display: flex;
       align-items: center;
       gap: var(--spacing-xs);
       padding: var(--spacing-xs) var(--spacing-sm);
       background-color: var(--color-surface);
       border: 1px solid var(--color-border);
       border-radius: var(--border-radius-pill);
       font-size: 0.8rem;
       font-weight: 500;
       cursor: pointer;
       transition: background-color var(--transition-speed), box-shadow var(--transition-speed);

   }
   .speed-control-pill:hover {
       background-color: #f0f0f0;

   }
   .speed-control-pill svg {
       width: 16px;
       height: 16px;
       fill: var(--color-text-secondary);
   }
   #speedValuePill {
       color: var(--color-text-primary);
   }

   .speed-slider-popup {
       position: absolute;
       bottom: calc(100% + var(--spacing-sm)); /* Position above the control bar */
       right: var(--spacing-md); /* Align with the speed pill or adjust as needed */
       background-color: var(--color-surface);
       padding: var(--spacing-md);
       border-radius: var(--border-radius-md);
       box-shadow: var(--shadow-lg);
       z-index: 10;
       display: none; /* Hidden by default */
       flex-direction: column;
       align-items: center;
       gap: var(--spacing-sm);
       width: 250px; /* Adjust width as needed */
   }
   .speed-slider-popup.active {
       display: flex;
       flex-direction: row;
   }
   .speed-slider-popup input[type="range"] { /* Re-style existing speed slider for popup */
     -webkit-appearance: none;
     appearance: none;
     width: 100%;
     height: 8px;
     background: #ddd;
     border-radius: var(--border-radius-pill);
     cursor: pointer;
     outline: none;
     margin: 0; /* Remove default margins */
   }
   .speed-slider-popup input[type="range"]::-webkit-slider-thumb {
     -webkit-appearance: none;
     appearance: none;
     width: 20px;
     height: 20px;
     background: var(--color-surface);
     border: 2px solid var(--color-primary);
     border-radius: 50%;
     cursor: pointer;
     margin-top: -14px; /* Adjust vertical position */
     box-shadow: var(--shadow-sm);
     transition: background-color var(--transition-speed), transform var(--transition-speed);
   }
   .speed-slider-popup input[type="range"]:hover::-webkit-slider-thumb { background-color: var(--color-primary); }
   .speed-slider-popup input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.1); }
   .speed-slider-popup input[type="range"]:focus::-webkit-slider-thumb { box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4); }
   .speed-slider-popup input[type="range"]::-moz-range-thumb {
     width: 20px; height: 20px; background: var(--color-surface);
     border: 2px solid var(--color-primary); border-radius: 50%;
     cursor: pointer; box-shadow: var(--shadow-sm);
     transition: background-color var(--transition-speed), transform var(--transition-speed);
   }
   .speed-slider-popup input[type="range"]:hover::-moz-range-thumb { background-color: var(--color-primary); }
   .speed-slider-popup input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }
   .speed-slider-popup input[type="range"]:focus::-moz-range-thumb { box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.4); }

   .dismiss-speed-popup {
       background: none;
       border: none;
       cursor: pointer;
       padding: var(--spacing-xs);
       align-self: flex-end; /* Position to the right */
   }
   .dismiss-speed-popup svg {
       width: 16px;
       height: 16px;
       fill: var(--color-text-secondary);
   }
   .dismiss-speed-popup:hover svg {
       fill: var(--color-text-primary);
   }
   /* --- END NEW VIDEO PLAYER CONTROLS --- */


   /* Add some basic styling for the new elements if needed */
   .preview-controls-top-left {
       /* Adjust positioning as needed */
   }

   #filterInfoPill {
       /* Styles are mostly inline for now, can be moved to CSS */
       box-shadow: var(--shadow-sm);
	    border: 2px solid rgb(255, 174, 170);
	   cursor: pointer;
   }
#filterInfoPill:hover {

    border: 2px solid #F7837D;
    
}
   /* Class to hide elements during filtering */
   .hidden-by-filter {
       display: none !important;
   }

   .accordion.hidden-by-filter,
   .gradient-accordion.hidden-by-filter {
       display: none !important;
   }

   /* For accordions that were part of the initial filter but don't currently match */
   .accordion-filtered-nomatch .accordion-header,
   .accordion-filtered-nomatch .gradient-header {
       opacity: 1;
       /* background-color: #f8f8f8; */ /* Optional: subtle background change for the header */
   }

   /* Hide the actual content rows within an accordion that's visible but doesn't currently match the filter */


   /* Style for individual rows if you decide to show them but mark as non-matching (alternative to hiding) */
   /*
   .row-filtered-nomatch {
       opacity: 0.5;
       pointer-events: none;
   }
   */

   .info-pill {
     position: absolute;
     bottom: var(--spacing-sm); /* Adjust if it overlaps with seekbar controls */
     left: var(--spacing-sm);
     z-index: 10;
     background-color: rgba(255, 255, 255, 0.75); /* Slightly more opaque for readability */
     padding: var(--spacing-xs) var(--spacing-sm);
     border-radius: var(--border-radius-pill);
     backdrop-filter: blur(3px);
     box-shadow: var(--shadow-sm);
     font-size: 0.7rem; /* Slightly smaller */
     font-weight: 600;
     color: #292929;
     white-space: nowrap;
     pointer-events: none; /* So it doesn't interfere with controls underneath */
   }

   /* Adjust positioning relative to the new player controls */
   .lottie-player-controls + #animationDurationPill {
       bottom: calc(var(--spacing-sm) + 60px); /* Example: 40px is roughly height of player-controls */
       /* Or adjust 'bottom' directly in .info-pill if player controls height is consistent */
   }


  </style>
</head>
<body>


  <div id="top-bar">
   <div style="flex: 1; justify-content:center; margin:auto;"  >
     <div style="width:85%; display: flex;  margin:auto; justify-content: flex-start;">
     <img src="mainLogo.svg" alt="Main Logo" class="page-logo" /></div>
   </div>

   <div style="flex: 1.1; margin: auto; justify-content:center;">
     <div style="max-width: 400px; display: flex;  margin:auto; justify-content: flex-end;">
       <div id="headerLottie"></div>
     </div>
   </div>
 </div>

  <div id="uploadWrapper">
    <label for="fileInput" id="uploadLabel" class="btn btn--primary">Choose Lottie JSON</label>
    <div class="drag-drop-overlay"></div>
    <input type="file" id="fileInput" accept=".json" />
  </div>

  <div class="window-container">
    <div class="window-header">
      <span class="window-title" contenteditable="true">No file loaded</span>
  <button class="window-close" aria-label="Close Preview">&times;</button>
    </div>


    <div class="window-body checkerboard" style="flex-direction: column;">
      <div class="preview-controls-top-left" style="position: absolute; top: 10px; left: 10px; z-index: 10;">
        <button id="activateColorPickerBtn" class="control-button" title="Pick color from animation"
          style="padding: 5px; background: #fff; border: 1px solid #ccc; border-radius: 10px; cursor: pointer;">
          <img src="assets/target.svg" alt="Pick color" width="24" height="24">
      </button>
</div>
      <div class="preview-bg-toggle" title="Toggle Background (Checkerboard/Solid)">
       <span class="preview-bg-label">GIF BG</span>
       <label class="switch"> <input type="checkbox" id="previewBgToggle">
         <span class="slider"></span>
         <span class="sr-only">Toggle Preview Background</span>
       </label>
     </div>

    <div id="lottiePreview"></div>

     <div class="lottie-player-controls">
       <button id="playPauseBtn" class="control-button" aria-label="Pause">
     <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> </button>
      <input type="range" id="lottieSeekbar" value="0" min="0" step="1" aria-label="Animation progress">
      <div class="speed-control-pill" id="speedControlPillBtn" role="button" tabindex="0" aria-haspopup="true" aria-expanded="false" aria-controls="speedSliderPopup">
        <img src="assets/speed.svg" alt="Speed Icon" width="18" height="18"> <span id="speedValuePill" style="width: 1.4rem;margin: auto;text-align: center;">1.0x</span>
      </div>

      <div class="speed-slider-popup" id="speedSliderPopup">

        <label for="speedSliderMain" class="sr-only">Animation Speed</label>
        <input
          type="range"
          id="speedSliderMain"
          min="0.1"
          max="3"
          step="0.1"
          value="1"
          list="speedStopsMain"
          aria-labelledby="speedValuePill"
        >
        <button class="dismiss-speed-popup" id="dismissSpeedPopupBtn" aria-label="Dismiss speed control" style="display: none;">
          <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg> </button>
        <datalist id="speedStopsMain">
          <option value="0.5"></option><option value="1.0"></option><option value="1.5"></option>
          <option value="2.0"></option><option value="2.5"></option><option value="3.0"></option>
        </datalist>
        </div>
    </div>

    <div id="animationDurationPill" class="info-pill" style="display: none;">0.00s</div>

    </div>
  </div>


  <div id="mainContent">
    <div id="editorArea">


      <div id="filterInfoPill" style="display: none; align-items: center; gap: 6px; padding: 8px 12px; padding-left:16px; background-color: rgb(255 174 170); border-radius: 999px; margin: 30px auto 10px; width: fit-content; max-width: 90%;">
   <span style="font-size: 0.9em;">Dismiss Color Search</span>
   <span id="filterPillColorSwatch" style="display: none; width: 20px; height: 20px; border: 1px solid #777; border-radius: 4px; vertical-align: middle;"></span>
   <span id="filterPillHexDisplay" style="font-size: 0.9em; font-family: monospace; display: none;">#XXXXXX</span>
<button id="resetFilterBtn" title="Clear filter and show all colors" style="background: none; border: none; font-size: 1.2em; cursor: pointer; padding: 0 5px; padding-top:3px;">×</button>
</div>



      <h3 id="colorInstancesLabel" class="editor-heading"><span style="margin-left: 6px;">Color Instance Clusters</span></h3>
      <div id="colorEditor">
        </div>


                <h3 id="gradientInstancesLabel" class="editor-heading" style="display: none;"><span style="margin-left: 6px;">Gradient Instances</span></h3>
              <div id="stopEditor">
                </div>

                <h3 id="textEditorLabel" class="editor-heading" style="display: none;"><span style="margin-left: 6px;">Text Instances</span></h3>
        <div id="textEditorContainer">

        </div>


        <h3 id="animatedColorLabel" class="editor-heading"><span style="margin-left: 6px;">Animated Color Instances</span></h3>
<div id="animatedColorEditor"></div>

        <h3 id="animatedGradientLabel" class="editor-heading"><span style="margin-left: 6px;">Animated Gradient Instances</span></h3>
        <div id="animatedGradientEditor"></div>






        <div id="emptyStateDiv">
        <img src="nocolor.png" alt="No colors detected">
    </div>
    </div>
<div id="midsection"></div>
    <div id="previewArea">



      <div class="section-card" id="jsonEditorCard">
        <div class="json-header">
          <h3 id="jsonExportLabel">Lottie JSON</h3>
          <div class="json-header-controls">
            <button id="openAssetReplacerBtn" class="btn btn--icon" title="Open Asset Replacer (Requires asset_replacer.html)" disabled aria-label="Open Asset Replacer">
    </button>
            <button id="openOverlayBtn" class="btn btn--icon" title="Open Trim Editor (Requires overlay.html)" disabled aria-label="Open Trim Editor">
            </button>
            <button id="openCropBtn" class="btn btn--icon" title="Open Crop Editor (Requires crop.html)" disabled aria-label="Open Crop Editor">
            </button>
            <button id="downloadJsonBtn" class="btn btn--icon btn--secondary" title="Download Modified JSON" style="display:none;" aria-label="Download Modified JSON">
            </button>
          </div>
        </div>
      </div>

      <div class="section-card" id="gifOptionsCard">
        <div class="gif-settings-header">
          <h3 id="gifExportLabel">GIF Export</h3>
           <div class="gif-header-controls">
             <button id="downloadGifBtn" class="btn btn--icon btn--accent" style="display:none;" title="Generate and Download GIF (Requires loader.json & gif.worker.js)" aria-label="Generate and Download GIF">
                <div class="loading-spinner"></div>
             </button>
          </div>
        </div>

        <div class="gif-settings">
          <label for="transparentBg">Background</label>
          <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
             <div class="color-input-group-bg" id="bgColorGroup">
                <label for="bgColorPicker" class="sr-only">Background Color</label>
                <input type="color" id="bgColorPicker" value="#000000">
                <label for="bgHexInput" class="sr-only">Background Hex</label>
                <input type="text" id="bgHexInput" value="#000000">
            </div>
            <label class="switch" title="Toggle Transparent Background">
                <input type="checkbox" id="transparentBg" checked>
                <span class="slider"></span>
            </label>
            <span class="sr-only">Transparent Background Toggle</span>
          </div>
        </div>

        <div class="gif-settings">
          <label for="gifScale">Resolution Scale</label>
          <select id="gifScale">
            <option value="0.25">0.25x</option>
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x (Default)</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
             <option value="4" id="gifScale4x" hidden>4x</option> <option value="8" id="gifScale8x" hidden>8x</option>
          </select>
        </div>
      </div>

    </div> </div> <div id="gifContainer"></div>

  <div class="overlay" id="renderSettingsOverlay">
    <div class="overlay-content">
      <button class="overlay-close" aria-label="Close GIF Settings">&times;</button>
      <h3>Advanced GIF Settings</h3>

      <div class="setting-row">
        <label for="keyColor">Transparency Key Color (for GIF):</label>
        <div class="controls">
            <input type="color" id="keyColor" value="#000000">
            <input type="text" id="keyHex" value="#000000">
        </div>
        <small>Color to treat as transparent (use near-black if Lottie uses pure black).</small>
      </div>

      <div class="setting-row">
        <label for="replaceColor">Replacement Color:</label>
         <div class="controls">
            <input type="color" id="replaceColor" value="#010101">
            <input type="text" id="replaceHex" value="#010101">
        </div>
         <small>Color to replace the Key Color with before rendering.</small>
      </div>

      <button onclick="closeSettings()" class="btn btn--primary" style="margin-top: var(--spacing-md);">Save Settings</button>
    </div>
  </div>

  <div class="overlay" id="customOverlay">
    <div class="overlay-content">
      <button class="overlay-close" aria-label="Close Editor Overlay"></button>
      <iframe id="customContent" title="Lottie Animation Editor Overlay"></iframe>
    </div>
  </div>

  <div id="coffeeRoastOverlay" class="coffeeRoast-hidden">

    <iframe id="freshBrewFrame" src="" frameborder="0"></iframe>
</div>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

  <script>

    const layerIconSvg = `<img src="layers.svg" alt="Layers Icon">`;

  const EYE_OPEN_SVG = `<img src="visible.svg" alt="Layers Icon" class="textVisibility">`;

const EYE_CLOSED_SVG = `<img src="invisible.svg" alt="Layers Icon" class="textVisibility">`;


  // Coffee-themed variables and functions
let coffeeAnimation;
const coffeeSegments = { idle: [], hover: [], loop: [], back: [] };
let coffeeCurrentSegment = null;
let coffeeIsMouseOn = false;

const coffeeContainer = document.getElementById('headerLottie');

// Load the coffee animation
coffeeAnimation = lottie.loadAnimation({
container: coffeeContainer,
renderer: 'svg',
loop: false,
autoplay: false,
path: 'buyme.json'
});

coffeeAnimation.addEventListener('DOMLoaded', () => {
initCoffeeSegments();
attachCoffeeListeners();
playCoffeeSegment('idle', true);
});
coffeeAnimation.addEventListener('complete', onCoffeeSegmentComplete);

function initCoffeeSegments() {
const markers = coffeeAnimation.animationData.markers || [];
markers.forEach(marker => {
  coffeeSegments[marker.cm] = [marker.tm, marker.tm + marker.dr];
});
}

function playCoffeeSegment(name, loop = false) {
const range = coffeeSegments[name];
if (!range) return;
const [start, end] = range;
coffeeCurrentSegment = name;
// set speed: coffeeSlow for idle & loop
const speed = (name === 'idle' || name === 'loop') ? 0.65 : 1;
coffeeAnimation.setSpeed(speed);
coffeeAnimation.loop = !!loop;
coffeeAnimation.playSegments([start, end], true);
}

function onCoffeeMouseEnterDefault() {
coffeeIsMouseOn = true;
playCoffeeSegment('hover', false);
swapInCoffeeListeners();
}

function onCoffeeMouseLeaveDefault() {
coffeeIsMouseOn = false;
playCoffeeSegment('back', false);
swapInCoffeeListeners();
}

function onCoffeeMouseEnterSwapped() {
coffeeIsMouseOn = true;
}

function onCoffeeMouseLeaveSwapped() {
coffeeIsMouseOn = false;
}

function attachCoffeeListeners() {
coffeeContainer.addEventListener('mouseenter', onCoffeeMouseEnterDefault);
coffeeContainer.addEventListener('mouseleave', onCoffeeMouseLeaveDefault);
}

function detachCoffeeListeners() {
coffeeContainer.removeEventListener('mouseenter', onCoffeeMouseEnterDefault);
coffeeContainer.removeEventListener('mouseleave', onCoffeeMouseLeaveDefault);
}

function swapInCoffeeListeners() {
detachCoffeeListeners();
coffeeContainer.addEventListener('mouseenter', onCoffeeMouseEnterSwapped);
coffeeContainer.addEventListener('mouseleave', onCoffeeMouseLeaveSwapped);
}

function restoreCoffeeListeners() {
coffeeContainer.removeEventListener('mouseenter', onCoffeeMouseEnterSwapped);
coffeeContainer.removeEventListener('mouseleave', onCoffeeMouseLeaveSwapped);
attachCoffeeListeners();
}

function onCoffeeSegmentComplete() {
switch (coffeeCurrentSegment) {
  case 'hover':
    if (coffeeIsMouseOn) {
      restoreCoffeeListeners();
      playCoffeeSegment('loop', true);
    } else {
      playCoffeeSegment('back', false);
    }
    break;
  case 'back':
    if (coffeeIsMouseOn) {
      playCoffeeSegment('hover', false);
    } else {
      restoreCoffeeListeners();
      playCoffeeSegment('idle', true);
    }
    break;
  case 'loop':
    if (!coffeeIsMouseOn) {
      swapInCoffeeListeners();
      playCoffeeSegment('back', false);
    }
    break;
  case 'idle':
    // idle loops automatically
    break;
}
}






    // --- Global Variables ---
    let lottieData;         // Stores the parsed Lottie JSON
    let colorRefs = [];     // Stores references to solid color paths
    let allGradients = [];  // Stores references to gradient paths and stops
    let animationInstance;  // The main Lottie animation instance in the preview
    let currentSpeed = 1.0; // Current playback speed multiplier
    let originalFrameRate;  // Original frame rate from the Lottie JSON
    let animWidth, animHeight; // Original dimensions from the Lottie JSON
    let overlayAnimationInstance = null; // Instance for the overlay iframe
     let anyContent =null;
     let originalAnimationDuration = 0;
    // GIF rendering settings (can be overridden by overlay)
    let keyColor = '#000000';     // Color to make transparent in GIF
    let replaceColor = '#010101'; // Color to replace keyColor with before rendering


    // --- NEW: Undo/Redo Variables ---
    let originalLottieDataForReset; // To store a pristine copy for full reset
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STEPS = 10;
    let initialColorGroups = null;
    let initialAnimatedColorGroupsByHex = null;

    let preservedColorAccordionStates = {};
    let preservedGradientAccordionStates = {};




    let preservedAnimatedColorAccordionStates = {};    // <<< NEW
   let preservedAnimatedGradientAccordionStates = {}; // <<< NEW
    // --- END NEW ---





    let translationtoX = null;
    let translationtoY = null;



    //text properties
    let detectedTextElements = []; // To store found text layers and their keyframes
let preservedTextAccordionStates = {}; // To preserve open/closed states of text accordions



    // --- DOM Element References ---
    const fileInput = document.getElementById('fileInput');
    const uploadWrapper = document.getElementById('uploadWrapper');
    const dragDropOverlay = document.querySelector('.drag-drop-overlay');

    const mainContent = document.getElementById('mainContent');
    const editorArea = document.getElementById('editorArea');
    const colorEditor = document.getElementById('colorEditor');
    const stopEditor = document.getElementById('stopEditor');
    const previewArea = document.getElementById('previewArea');
    const lottiePreview = document.getElementById('lottiePreview');
    const windowTitle = document.querySelector('.window-title');
    const windowCloseBtn = document.querySelector('.window-close');

    const downloadJsonBtn = document.getElementById('downloadJsonBtn');
    const downloadGifBtn = document.getElementById('downloadGifBtn');
    const openOverlayBtn = document.getElementById('openOverlayBtn');
    const openCropBtn = document.getElementById('openCropBtn'); // *** NEW CROP BUTTON REF ***
    const transparentBgCheckbox = document.getElementById('transparentBg');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const bgHexInput = document.getElementById('bgHexInput');
    const bgColorGroup = document.getElementById('bgColorGroup');
    const gifScaleSelect = document.getElementById('gifScale');
    const gifContainer = document.getElementById('gifContainer'); // Hidden container for GIF rendering
    const gifExportLabel = document.getElementById('gifExportLabel');
    const renderSettingsOverlay = document.getElementById('renderSettingsOverlay');
    const customOverlay = document.getElementById('customOverlay');
    const customOverlayIframe = document.getElementById('customContent');
    const overlayCloseButtons = document.querySelectorAll('.overlay-close');
    const openAssetReplacerBtn = document.getElementById('openAssetReplacerBtn');

    const animatedColorEditor = document.getElementById('animatedColorEditor');

	const pillPropertyGroupMap = new WeakMap();


    // --- (Place near other global variables or utility functions) ---



    // Will hold { path: [...,'c','k'], keyframePaths: [ [...,'c','k',i,'s'], … ] } for solids
    // and similar for grads
    let animatedColorRefs = [];

    let animatedGradientRefs = [];


    // --- NEW DOM Element References for Player Controls ---
    const playPauseBtn = document.getElementById('playPauseBtn');
    const lottieSeekbar = document.getElementById('lottieSeekbar');
    const speedControlPillBtn = document.getElementById('speedControlPillBtn');
    const speedValuePill = document.getElementById('speedValuePill'); // Span inside the pill
    const speedSliderPopup = document.getElementById('speedSliderPopup');
    const speedSliderMain = document.getElementById('speedSliderMain'); // The new main speed slider
    const dismissSpeedPopupBtn = document.getElementById('dismissSpeedPopupBtn');
    const durationpill= document.getElementById('animationDurationPill');
    let isPlaying = true; // To track play/pause state
    let speedPopupTimer = null; // Timer for auto-dismissing speed popup


    const PLAY_ICON_SVG = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
   const PAUSE_ICON_SVG = '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';




   // Add these near your other global variables
   let isColorPickerActive = false;
   let activePickedColor = null; // Stores the hex of the currently filtered color
   let originalDisplayStates = new Map(); // To store original display states of editor items
   let elementsToManageVisibility = []; // Array to store all relevant editor items

   // DOM Refs for new elements
   const activateColorPickerBtn = document.getElementById('activateColorPickerBtn');
   const filterInfoPill = document.getElementById('filterInfoPill');
   const filterPillColorPicker = document.getElementById('filterPillColorPicker');
   const filterPillHexInput = document.getElementById('filterPillHexInput');
   const resetFilterBtn = document.getElementById('filterInfoPill');
   const previewBgToggleContainer = document.querySelector('.preview-bg-toggle'); // Get the container of the GIF BG toggle



   let initialFilteredAccordionIds = new Set();
let isUserInitiatedFilter = false;




   /**
    * Converts a hex color string to an array of RGB components [R, G, B].
    * @param {string} hex - The hex color string (e.g., "#FF0000" or "FF0000").
    * @returns {Array<number>} - An array [R, G, B] with values between 0 and 255.
    */
   function hexToRgbComponents(hex) {
       const h = hex.replace('#', '');
       if (h.length === 3) { // Expand 3-digit hex
           const r = parseInt(h[0] + h[0], 16);
           const g = parseInt(h[1] + h[1], 16);
           const b = parseInt(h[2] + h[2], 16);
           return [r, g, b];
       }
       if (h.length === 6) {
           const bigint = parseInt(h, 16);
           const r = (bigint >> 16) & 255;
           const g = (bigint >> 8) & 255;
           const b = bigint & 255;
           return [r, g, b];
       }
       console.warn("Invalid hex string for RGB conversion:", hex);
       return [0, 0, 0]; // Default to black for invalid hex
   }

   /**
    * Calculates the Euclidean distance between two RGB colors.
    * @param {Array<number>} rgb1 - First color as [R, G, B] (0-255).
    * @param {Array<number>} rgb2 - Second color as [R, G, B] (0-255).
    * @returns {number} - The distance between the two colors.
    */
   function colorDistance(rgb1, rgb2) {
       if (!rgb1 || !rgb2 || rgb1.length < 3 || rgb2.length < 3) {
           return Infinity; // Or handle error appropriately
       }
       const rDiff = rgb1[0] - rgb2[0];
       const gDiff = rgb1[1] - rgb2[1];
       const bDiff = rgb1[2] - rgb2[2];
       return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
   }

   // Define your tolerance for color matching. Adjust this value as needed.
   // A lower value means stricter matching, a higher value is more lenient.
   const COLOR_DISTANCE_TOLERANCE = 10; // Example tolerance

   function initializeElementsToManageVisibility() {
       elementsToManageVisibility = [
           ...document.querySelectorAll('#colorEditor .accordion'),
           ...document.querySelectorAll('#stopEditor .gradient-accordion'),
           ...document.querySelectorAll('#animatedColorEditor .gradient-accordion'),
           ...document.querySelectorAll('#animatedGradientEditor .gradient-accordion'),
           // For text, decide if you filter rows or the main text accordion
           document.getElementById('detected-text-main-accordion'), // If filtering the whole section
           // ... or document.querySelectorAll('#textEditorContainer .text-instance-row') if filtering individual rows
       ].filter(el => el); // Filter out nulls if some sections aren't populated
   }



	function pathToGroupId(pathArray) {
  if (!Array.isArray(pathArray)) return '';
  return pathArray.join('-');
}


    function getNodeByPath(root, path) {
  return path.reduce((obj, key) => obj && obj[key], root);
}




    function getValueByPath(obj, path) {
        try {
            return path.reduce((acc, key) => acc[key], obj);
        } catch (e) {
            console.warn("Invalid path:", path, "in object:", obj);
            return undefined;
        }
    }

    /**
     * Sets a value in an object using a path array.
     */
    function setValueByPath(obj, path, newValue) {
        try {
            const lastKey = path[path.length - 1];
            const target = path.slice(0, -1).reduce((acc, key) => acc[key], obj);
            if (target && typeof target === 'object') {
                target[lastKey] = newValue;
            } else {
                 console.warn("Invalid target for path:", path, "in object:", obj);
            }
        } catch (e) {
             console.warn("Error setting value for path:", path, "in object:", obj, e);
        }
    }






    /**
 * Converts a Lottie normalized RGB array (0-1 range) for text fill color to a hex color string.
 * @param {Array<number>} rgbNormalized - An array [r, g, b] with values between 0 and 1.
 * @returns {string} - The hex color string (e.g., "#FF0000").
 */
function rgbTextNormalizedToHex(rgbNormalized) {
    if (!rgbNormalized || rgbNormalized.length < 3) return "#000000"; // Default to black
    const r = Math.max(0, Math.min(255, Math.round(rgbNormalized[0] * 255)));
    const g = Math.max(0, Math.min(255, Math.round(rgbNormalized[1] * 255)));
    const b = Math.max(0, Math.min(255, Math.round(rgbNormalized[2] * 255)));
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
}

/**
 * Converts a hex color string to a Lottie-compatible normalized RGB array (0-1 range) for text fill color.
 * @param {string} hex - The hex color string (e.g., "#FF0000").
 * @returns {Array<number>} - An array [r, g, b] with values between 0 and 1.
 */
function hexToRgbTextNormalized(hex) {
    let r = 0, g = 0, b = 0;
    hex = hex.replace('#', '');
    if (hex.length === 3) {
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length === 6) {
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    }
    // Ensure values are clamped between 0 and 1 and have a fixed precision
    return [
        parseFloat((r / 255).toFixed(3)),
        parseFloat((g / 255).toFixed(3)),
        parseFloat((b / 255).toFixed(3))
    ];
}





    function findTextLayersRecursive(layers, assetIdPrefix = '', currentPath = []) {
    if (!layers || !Array.isArray(layers)) return;

    layers.forEach((layer, layerIndex) => {
        const layerPath = [...currentPath, 'layers', layerIndex];
        // Standard text layer type is 5
        if (layer.ty === 5 && layer.t && layer.t.d && layer.t.d.k) {
            // Iterate through keyframes of the text property ('k')
            layer.t.d.k.forEach((keyframe, keyframeIndex) => {
                if (keyframe.s) { // 's' (sourceText) contains the style properties including text and color
                    const textObject = keyframe.s; // This is the object holding 't' (text) and 'fc' (fillColor)
                    if (typeof textObject.t === 'string') { // 't' is the actual text string
                        detectedTextElements.push({
                            textNodeRef: textObject, // Direct reference to the 's' object in lottieData
                            originalText: textObject.t,
                            // 'fc' is fill color [r,g,b] (0-1 normalized), default to black if not present
                            originalColor: textObject.fc || [0, 0, 0], // Lottie text color is [0-1, 0-1, 0-1]
                            layerName: layer.nm || `Text Layer <span class="math-inline">\{assetIdPrefix\}</span>{layerIndex + 1}`,
                            keyframeIndex: keyframeIndex, // Index of this keyframe within layer.t.d.k
                            // Store paths for undo/redo if needed, e.g., path to textObject.t and textObject.fc
                            textPath: [...layerPath, 't', 'd', 'k', keyframeIndex, 's', 't'],
                            colorPath: [...layerPath, 't', 'd', 'k', keyframeIndex, 's', 'fc']
                        });
                    }
                }
            });
        }
        // If the layer is a pre-composition and has its own layers array, recurse.
        // Pre-compositions are often defined in `assets` and then referenced by `refId`.
        // This basic recursion handles layers directly nested. For assets, you'd call this function on asset.layers.
        if (layer.layers && Array.isArray(layer.layers)) {
            findTextLayersRecursive(layer.layers, assetIdPrefix + (layer.nm || `comp${layerIndex}`) + '_', [...layerPath]);
        }
    });
}



/**
 * Renders the accordion UI for editing detected text elements (content and color).
 */
 /**
  * Renders a single accordion UI for "Detected Text".
  * The accordion body will contain rows for each editable text instance.
  * The header will show color dots as a preview.
  */
 function renderTextEditorUI() {
     const container = document.getElementById('textEditorContainer');
     const mainLabel = document.getElementById('textEditorLabel'); // The H3 heading "Detected Text"
     container.innerHTML = ''; // Clear previous UI

     if (detectedTextElements.length === 0) {
         if (mainLabel) mainLabel.style.display = 'none';
         // Optionally, display a message like "No text elements found." in the container
         return;
     }

     if (mainLabel) mainLabel.style.display = 'block';

     const mainAccordionId = 'detected-text-main-accordion';

     const accordion = document.createElement('div');
     accordion.className = 'gradient-accordion'; // Reuse existing styling
     accordion.dataset.id = mainAccordionId;
     accordion.id = mainAccordionId; // <<< ADD THIS LINE

     const header = document.createElement('div');
     header.className = 'gradient-header';

     const headerContent = document.createElement('div'); // To hold title and dots
     headerContent.className = 'accordion-header-content'; // Use existing class for layout

     const title = document.createElement('span');
     title.innerHTML = ` <span class="math-inline">${detectedTextElements.length} Instance${detectedTextElements.length === 1 ? '' : 's'}</span>`;


     const rightSide = document.createElement('div');
     rightSide.className = 'right-side-of-header';



     headerContent.appendChild(title);
     headerContent.appendChild(rightSide);


     // --- Add Color Dots to Header ---
     const MAX_DOTS_IN_HEADER = 10; // Limit number of dots for visual clarity
     detectedTextElements.slice(0, MAX_DOTS_IN_HEADER).forEach(element => {
         const dot = document.createElement('div');
         dot.className = 'color-dot'; // Reuse existing styling for dots
         const currentColorArray = Array.isArray(element.textNodeRef.fc) ? element.textNodeRef.fc : [0,0,0];
         dot.style.backgroundColor = rgbTextNormalizedToHex(currentColorArray);
         dot.title = `${element.layerName} (KF ${element.keyframeIndex + 1}): ${element.textNodeRef.t}`; // Tooltip
        rightSide.appendChild(dot); // Add dots after the title
     });
     if (detectedTextElements.length > MAX_DOTS_IN_HEADER) {
         const moreDotsIndicator = document.createElement('span');
         moreDotsIndicator.textContent = ` +${detectedTextElements.length - MAX_DOTS_IN_HEADER} more`;
         moreDotsIndicator.style.fontSize = '0.8em';
         moreDotsIndicator.style.marginLeft = 'var(--spacing-xs)';
        rightSide.appendChild(moreDotsIndicator);
     }
     // --- End Color Dots ---

     header.appendChild(headerContent); // Add content (title + dots) to header

     const body = document.createElement('div');
     body.className = 'gradient-content'; // Reuse existing styling for accordion body
     body.id = `detected-text-main-body`;

     // Apply preserved accordion state for the main accordion
     if (preservedTextAccordionStates[mainAccordionId] === true) {
         header.classList.add('active');
         body.classList.add('active');
         body.style.display = "flex"; // Or "block"
         header.setAttribute('aria-expanded', 'true');
     } else {
         body.style.display = "none";
         header.setAttribute('aria-expanded', 'false');
     }

     // Populate the body with rows for each text instance
     detectedTextElements.forEach((element, index) => {
         const textInstanceRow = document.createElement('div');
         textInstanceRow.className = 'text-instance-row stop-row'; // Reuse 'stop-row' for layout or create a new class
         textInstanceRow.style.display = 'flex';
         textInstanceRow.style.alignItems = 'center';
         textInstanceRow.style.gap = 'var(--spacing-md)';
         textInstanceRow.style.padding = 'var(--spacing-sm) 0';


         const instanceLabel = document.createElement('span');
         instanceLabel.className = 'label'; // Reuse 'label' class
         instanceLabel.textContent = `${element.layerName}`;
         instanceLabel.title = `Original: "${element.originalText}"`;

         instanceLabel.style.flexShrink = '0';

         const textInput = document.createElement('input');
         textInput.type = 'text';
         textInput.value = element.textNodeRef.t;
         textInput.className = 'text-editor-input'; // Your specific class for text inputs
         textInput.style.flexGrow = '1';
         textInput.setAttribute('aria-label', `Edit text for ${element.layerName}`);

         textInput.addEventListener('change', (e) => {
             const oldText = element.textNodeRef.t;
             const newText = e.target.value;
             element.textNodeRef.t = newText;

             recordChange({
                 type: 'TEXT_PROPERTY',
                 path: [...element.textPath],
                 oldValue: oldText,
                 newValue: newText,
                 textElementIndex: index
             });
             reloadLottiePreview();
         });

         const colorInputGroup = document.createElement('div');
         colorInputGroup.className = 'color-input-group';

         const colorPicker = document.createElement('input');
         colorPicker.type = 'color';
         const currentColorArray = Array.isArray(element.textNodeRef.fc) ? element.textNodeRef.fc : [0,0,0];
         colorPicker.value = rgbTextNormalizedToHex(currentColorArray);
         colorPicker.setAttribute('aria-label', `Edit color for ${element.layerName}`);

         const hexInput = document.createElement('input');
         hexInput.type = 'text';
         hexInput.value = colorPicker.value;
         hexInput.style.width = '70px';
         hexInput.setAttribute('aria-label', `Hex color for ${element.layerName}`);

         commitAfterIdle(colorPicker, (newHexValue) => {
             const oldColor = [...(element.textNodeRef.fc || [0,0,0])];
             const newColorArray = hexToRgbTextNormalized(newHexValue);
             element.textNodeRef.fc = newColorArray;
             hexInput.value = newHexValue;

             // Update the corresponding dot in the main accordion header
             const headerDots = header.querySelectorAll('.color-dot');
             if (index < headerDots.length) { // Check if this text instance has a dot in the header
                 headerDots[index].style.backgroundColor = newHexValue;
             }

             recordChange({
                 type: 'TEXT_PROPERTY',
                 path: [...element.colorPath],
                 oldValue: oldColor,
                 newValue: newColorArray,
                 textElementIndex: index
             });
             reloadLottiePreview();
         }, 150);

         hexInput.addEventListener('change', (e) => {
             let newHex = e.target.value.trim();
             if (!newHex.startsWith("#")) newHex = "#" + newHex;
             if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                 const oldColor = [...(element.textNodeRef.fc || [0,0,0])];
                 const newColorArray = hexToRgbTextNormalized(newHex);
                 element.textNodeRef.fc = newColorArray;
                 colorPicker.value = newHex;

                 const headerDots = header.querySelectorAll('.color-dot');
                 if (index < headerDots.length) {
                     headerDots[index].style.backgroundColor = newHex;
                 }

                 recordChange({
                     type: 'TEXT_PROPERTY',
                     path: [...element.colorPath],
                     oldValue: oldColor,
                     newValue: newColorArray,
                     textElementIndex: index
                 });
                 reloadLottiePreview();
             } else {
                 alert("Invalid hex code. Please use #RRGGBB format.");
                 hexInput.value = colorPicker.value;
             }
         });

         colorInputGroup.append(hexInput, colorPicker);


         let fullPath = element.colorPath;

// 2) drop any leading junk before the first 'layers'
const firstLayersIdx = fullPath.indexOf('layers');
if (firstLayersIdx > 0) {
  fullPath = fullPath.slice(firstLayersIdx);
}

// 3) now fullPath starts exactly ['layers', layerIdx, …]
//    find where the 't' text prop begins
const firstTIndex = fullPath.indexOf('t');

// 4) slice up to that to get ['layers', layerIdx]
const layerPath = fullPath.slice(0, firstTIndex);

// 5) finally look up the layer object
const layerNode = getValueByPath(lottieData, layerPath);
   // now build your eye-toggle off layerNode exactly as before
   const eyeBtn = document.createElement('span');
   eyeBtn.className = 'visibility-toggle';
   eyeBtn.innerHTML = layerNode.hd ? EYE_CLOSED_SVG : EYE_OPEN_SVG;
   eyeBtn.addEventListener('click', e => {
     e.stopPropagation();
     layerNode.hd = !layerNode.hd;
     eyeBtn.innerHTML = layerNode.hd ? EYE_CLOSED_SVG : EYE_OPEN_SVG;
     reloadLottiePreview();
   });

           // group eye + label, then append everything
           const labelWrapper = document.createElement('div');
           labelWrapper.className = 'title-wrapper';
           labelWrapper.style.display = 'flex';
           labelWrapper.style.alignItems = 'center';
            labelWrapper.appendChild(eyeBtn);
           labelWrapper.appendChild(instanceLabel);


           textInstanceRow.append(labelWrapper, textInput, colorInputGroup);
           body.appendChild(textInstanceRow);
     });

     header.addEventListener('click', (e) => {
         if (e.target.closest('input, .color-dot')) { // Prevent toggle if click is on inputs or dots
             return;
         }
         const isActive = body.classList.toggle('active');
         header.classList.toggle('active', isActive);
         body.style.display = isActive ? 'flex' : 'none';
         header.setAttribute('aria-expanded', isActive);
     });
     header.setAttribute('role', 'button');
     header.setAttribute('aria-controls', body.id);

     accordion.appendChild(header);
     accordion.appendChild(body);
     container.appendChild(accordion);
 }







    function findAnimatedGradients(obj, path = [], out = []) {
  if (obj && typeof obj === 'object') {
    // look for Lottie gradient fill with keyframes in .g.k.k
    if (
      obj.ty === 'gf' &&
      obj.g?.k?.k?.length &&
      Array.isArray(obj.g.k.k[0].s)
    ) {
      const basePath   = path.concat('g','k','k');
      const stopPaths  = obj.g.k.k.map((_, i) => basePath.concat(i, 's'));
      out.push({ basePath, stopPaths });
    }
    // recurse
    for (let key in obj) {
      findAnimatedGradients(obj[key], path.concat(key), out);
    }
  }
  return out;
}


function renderAnimatedGradientEditor() {
  const container = document.getElementById('animatedGradientEditor');
  container.innerHTML = '';

  // detect against the in‐memory lottieData
  animatedGradientRefs = findAnimatedGradients(lottieData); // Assuming this is called before or at the start

  if (!animatedGradientRefs || animatedGradientRefs.length === 0) {
    // container.textContent = 'No animated gradients found.'; // Keep or remove as you prefer
    // Hide the label if no animated gradients

    const animatedGradientLabel = document.getElementById('animatedGradientLabel');
    if (animatedGradientLabel) {
        animatedGradientLabel.style.display = 'none';
    }
    return;
  } else {
    // Show the label if there are animated gradients
    const animatedGradientLabel = document.getElementById('animatedGradientLabel');
    if (animatedGradientLabel) {
        animatedGradientLabel.style.display = 'block'; // Or your default display type
    }
  }

  animatedGradientRefs.forEach((grp, gi) => {

     const accordionId = `anim-grad-${gi}`; // <<< NEW: Define an ID

    const accordion = document.createElement('div');
    accordion.className = 'gradient-accordion';
    accordion.dataset.id = accordionId;

    const header = document.createElement('div');
    header.className = 'gradient-header';







       const rightSide = document.createElement('div');
       rightSide.className = 'right-side-of-header';

       const accordionHeaderContent = document.createElement('div');
       accordionHeaderContent.className = 'accordion-header-content';


       // Left part: Title and Pill
    const titlePillWrapper = document.createElement('div');
    titlePillWrapper.className =  'title-wrapper';



    const title = document.createElement('span');
    title.textContent = `Instance ${gi + 1}`;
    titlePillWrapper.appendChild(title);

    if (grp.basePath && lottieData) {
	const propertyGroupIdentifier = pathToGroupId(grp.basePath);
        // 1. Derive the exact gradient-fill object path
    const propPath = grp.basePath.slice(0, -3);           // drop ['g','k','k']
    // 2. Get the layer name and the JSON node for just that gradient fill
    const layerName = getLayerNameFromPath(lottieData, propPath);
    const shapeItem = getValueByPath(lottieData, propPath);

if (shapeItem) { // Ensure shapeItem is valid
      pillPropertyGroupMap.set(shapeItem, propertyGroupIdentifier); // <<< SET IN WEAKMAP
  }
    // 3. Create a pill that toggles only this gradient fill
    const layerPill = createLayerNamePill(layerName, shapeItem);
    if (layerPill) {
      // prevent the pill click bubbling up to the accordion header
     layerPill.addEventListener('click', e => e.stopPropagation());
      titlePillWrapper.appendChild(layerPill);
    }
    }
    accordionHeaderContent.appendChild(titlePillWrapper);








    accordionHeaderContent.appendChild(rightSide);
      header.appendChild(accordionHeaderContent);
    // --- Determine P (number of stops) ---
    const g_object_path = grp.basePath.slice(0, -2); // Path to the 'g' object
    const P_from_gradient_prop = getValueByPath(lottieData, g_object_path.concat('p'));

    if (typeof P_from_gradient_prop !== 'number' || P_from_gradient_prop <= 0) {
      console.warn(`Could not determine number of stops (P) for animated gradient #${gi + 1}. Skipping. Path to 'g':`, g_object_path.join('.'));
      // Add a message to UI for this specific accordion if P is invalid
      const errorMsg = document.createElement('span');
      errorMsg.textContent = ' (Error: Invalid stop data)';
      errorMsg.style.color = 'red';
      errorMsg.style.fontSize = '0.8em';
      titleElement.appendChild(errorMsg);
      accordion.appendChild(header); // Add header even if body is empty/error
      container.appendChild(accordion);
      return; // Skip rendering body for this gradient
    }
    const P = P_from_gradient_prop;

    // --- Updated Header Dots ---
    grp.stopPaths.forEach(sp_dot => { // sp_dot is path to a keyframe's 's' array
      const rawS_dot = getValueByPath(lottieData, sp_dot);
      const dot = document.createElement('div');
      dot.className = 'color-dot';

      if (Array.isArray(rawS_dot) && P > 0) {
        // Ensure there's enough data for the first color stop
        if (rawS_dot.length >= (0 * 4 + 4)) {
          const r_norm_dot = rawS_dot[0 * 4 + 1]; // R of first stop
          const g_norm_dot = rawS_dot[0 * 4 + 2]; // G of first stop
          const b_norm_dot = rawS_dot[0 * 4 + 3]; // B of first stop
          let a_norm_dot = 1.0;

          if (rawS_dot.length === P * 6 && rawS_dot.length >= (P * 4 + 0 * 2 + 2) ) { // Full P*6 structure
            a_norm_dot = rawS_dot[P * 4 + 0 * 2 + 1]; // Alpha of first stop
          } else if (rawS_dot.length === P * 4) { // P*4 structure (color only)
            a_norm_dot = 1.0;
          }
          // Add handling for P*5 if that's a case you expect, though less standard for complex gradients
          // else if (rawS_dot.length === P * 5 && rawS_dot.length >= (0 * 5 + 5)) {
          //    a_norm_dot = rawS_dot[0 * 5 + 4] ?? 1.0;
          // }

          dot.style.backgroundColor = `rgba(${Math.round(r_norm_dot * 255)}, ${Math.round(g_norm_dot * 255)}, ${Math.round(b_norm_dot * 255)}, ${a_norm_dot})`;
        } else {
            dot.style.backgroundColor = 'rgba(200,200,200,0.7)'; // Default if not enough data for first stop
        }
      } else {
        dot.style.backgroundColor = 'rgba(200,200,200,0.7)'; // Default if rawS_dot is not as expected
      }
      rightSide.appendChild(dot);
    });

    const body = document.createElement('div');
    body.className = 'gradient-content';
    body.id = `anim-grad-body-${gi}`; // Give body an ID for aria-controls


    // --- APPLY PRESERVED STATE (NEW) ---
    if (preservedAnimatedGradientAccordionStates[accordionId] === true) {
        header.classList.add('active');
        body.classList.add('active');
        body.style.display = "flex"; // Or "block", matching your active style
        header.setAttribute('aria-expanded', 'true');
    } else {
        body.style.display = "none"; // Default to closed
        header.setAttribute('aria-expanded', 'false');
    }
    // --- END APPLY PRESERVED STATE ---


    grp.stopPaths.forEach((sp, kfIndex) => { // sp is path to keyframe's 's' array
      const rawS = getValueByPath(lottieData, sp);

      if (!Array.isArray(rawS)) {
        console.warn(`Keyframe ${kfIndex} for gradient ${gi+1} has invalid 's' array. Path:`, sp.join('.'));
        const kfErrorRow = document.createElement('div');
        kfErrorRow.textContent = `Keyframe ${kfIndex + 1}: Error loading data.`;
        kfErrorRow.style.padding = 'var(--spacing-sm)';
        kfErrorRow.style.color = 'var(--color-text-secondary)';
        body.appendChild(kfErrorRow);
        return; // Skip this keyframe
      }

      // Check expected length based on P. Lottie gradients can be P*4 (colors only) or P*6 (colors + opacity)
      // Or sometimes a simplified P*5 [offset,r,g,b,a] but this is less common for complex tools.
      const expectedLengthP6 = P * 6;
      const expectedLengthP4 = P * 4;
      // const expectedLengthP5 = P * 5; // If you need to support this specific non-standard variant

      if (rawS.length !== expectedLengthP4 && rawS.length !== expectedLengthP6 /* && rawS.length !== expectedLengthP5 */) {
        console.warn(`Keyframe ${kfIndex} (Grad ${gi+1}): 's' array length ${rawS.length} is unexpected for ${P} stops. Expected ${expectedLengthP4} or ${expectedLengthP6}. Path:`, sp.join('.'));
        // Optionally add a message in the UI for this keyframe
      }

      for (let si = 0; si < P; si++) { // Loop P times for P stops
        // Ensure we don't read out of bounds for color part
        if (si * 4 + 3 >= rawS.length) {
            console.warn(`Keyframe ${kfIndex} (Grad ${gi+1}), Stop ${si+1}: Not enough data in 's' array for color. Length: ${rawS.length}`);
            continue; // Skip this stop if not enough data
        }

        const offset = rawS[si * 4 + 0]; // Color offset
        const r_norm = rawS[si * 4 + 1];
        const g_norm = rawS[si * 4 + 2];
        const b_norm = rawS[si * 4 + 3];
        let current_a_norm = 1.0; // Default alpha

        if (rawS.length === expectedLengthP6) {
            // Ensure we don't read out of bounds for opacity part
            if ((P * 4 + si * 2 + 1) < rawS.length) {
                current_a_norm = rawS[P * 4 + si * 2 + 1];
            } else {
                console.warn(`Keyframe ${kfIndex} (Grad ${gi+1}), Stop ${si+1}: Not enough data in 's' (P*6 structure) for alpha. Length: ${rawS.length}`);
            }
        } else if (rawS.length === expectedLengthP4) {
            current_a_norm = 1.0; // No separate alpha data, so it's 1
        }
        // else if (rawS.length === expectedLengthP5) { // If supporting P*5 explicitly
        //     if (si * 5 + 4 < rawS.length) {
        //        current_a_norm = rawS[si * 5 + 4] ?? 1.0;
        //     } else {
        //        console.warn(`Keyframe ${kfIndex} (Grad ${gi+1}), Stop ${si+1}: Not enough data in 's' (P*5 structure) for alpha. Length: ${rawS.length}`);
        //     }
        // }
        // For other lengths, current_a_norm remains 1.0 or could log an error.

        const hex = rgbToHex(r_norm, g_norm, b_norm); // rgbToHex expects 0-1 normalized inputs

        const row = document.createElement('div');
        row.className = 'stop-row';
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `KF ${kfIndex + 1} • Stop ${si + 1}`; // Offset: ${Math.round(offset*100)}%

        const inputGroup = document.createElement('div');
        inputGroup.className = 'color-input-group'; // Re-using existing style

        const hexInput = document.createElement('input'); // Create hex input
        hexInput.type = 'text';
        hexInput.value = hex;
        hexInput.setAttribute('aria-label', `Hex for KF ${kfIndex + 1} Stop ${si + 1}`);
        hexInput.style.width = '70px'; // Match styling of other hex inputs

        const picker = document.createElement('input');
        picker.type = 'color';
        picker.value = hex;
        picker.setAttribute('aria-label', `Color Picker for KF ${kfIndex + 1} Stop ${si + 1}`);


        // Event listener for color picker (RGB only)
        // Using commitAfterIdle for better performance during color dragging
        commitAfterIdle(picker, (newHexValue) => {
           const oldKeyframeSArray = [...getValueByPath(lottieData, sp)]; // Capture entire 's' array BEFORE change

           const [nr, ng, nb] = hexToRgb(newHexValue); // Converts hex from picker (RGB) to normalized 0-1 r,g,b

           // Update color part in the rawS array (which is a reference into lottieData)
           rawS[si * 4 + 1] = nr;
           rawS[si * 4 + 2] = ng;
           rawS[si * 4 + 3] = nb;
           // Alpha is preserved as it's not changed by this picker

           hexInput.value = newHexValue; // Sync hex input
           reloadLottiePreview();

           const newKeyframeSArray = [...rawS]; // Capture entire 's' array AFTER change
           recordChange({
               type: 'ANIMATED_GRADIENT_KEYFRAME', // Note: Storing the whole keyframe 's' array
               path: [...sp],                     // Path to the keyframe's 's' array
               oldValue: oldKeyframeSArray,
               newValue: newKeyframeSArray
           });
       }, 150);


       hexInput.addEventListener('change', (e) => { // Handle direct hex input
                   let newHexFromText = e.target.value.trim();
                   if (!newHexFromText.startsWith("#")) newHexFromText = "#" + newHexFromText;

                   if (/^#[0-9A-F]{6}$/i.test(newHexFromText)) {
                       const oldKeyframeSArray = [...getValueByPath(lottieData, sp)]; // Capture BEFORE

                       picker.value = newHexFromText; // Sync color picker

                       const [nr, ng, nb] = hexToRgb(newHexFromText);
                       rawS[si * 4 + 1] = nr;
                       rawS[si * 4 + 2] = ng;
                       rawS[si * 4 + 3] = nb;
                       // Alpha preserved

                       reloadLottiePreview();

                       const newKeyframeSArray = [...rawS]; // Capture AFTER
                       recordChange({
                           type: 'ANIMATED_GRADIENT_KEYFRAME',
                           path: [...sp],
                           oldValue: oldKeyframeSArray,
                           newValue: newKeyframeSArray
                       });
                   } else {
                       alert("Invalid hex code. Please use format #RRGGBB.");
                       e.target.value = picker.value; // Revert to picker's value
                   }
               });

        // UI Assembly
        inputGroup.append(picker, hexInput); // Order: picker then hex, or as you prefer
        row.append(label, inputGroup);
        body.appendChild(row);
      }
    });

    header.addEventListener('click', () => {
      const open = body.classList.toggle('active');
      header.classList.toggle('active', open);
      body.style.display = open ? 'flex' : 'none'; // Or 'block' depending on your CSS for .gradient-content
      header.setAttribute('aria-expanded', open);
    });

    // Set initial aria attributes for the header
    header.setAttribute('role', 'button');
    header.setAttribute('aria-controls', body.id);


    accordion.append(header, body);
    container.appendChild(accordion);
  });


}




    // --- Utility Functions ---

    /**
     * Converts RGB color components (0-1 range) to a hex string.
     */
    function rgbToHex(r, g, b) {
      const rInt = Math.max(0, Math.min(255, Math.round(r * 255)));
      const gInt = Math.max(0, Math.min(255, Math.round(g * 255)));
      const bInt = Math.max(0, Math.min(255, Math.round(b * 255)));
      return "#" + [rInt, gInt, bInt].map(x => x.toString(16).padStart(2, "0")).join("");
    }

    /**
     * Converts a hex color string to RGB components (0-1 range).
     */
    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [
        ((bigint >> 16) & 255) / 255,
        ((bigint >> 8) & 255) / 255,
        (bigint & 255) / 255
      ];
    }

    /**
     * Converts RGB color components (0-255 range) to a hex string (for gradients).
     */
    function rgbToHexGr(r, g, b) {
        const rInt = Math.max(0, Math.min(255, Math.round(r)));
        const gInt = Math.max(0, Math.min(255, Math.round(g)));
        const bInt = Math.max(0, Math.min(255, Math.round(b)));
        return '#' + [rInt, gInt, bInt].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Converts a hex color string to RGB components (0-255 range) (for gradients).
     */
    function hexToRGBGr(hex) {
      const value = hex.replace('#', '');
      return {
        r: parseInt(value.substring(0, 2), 16),
        g: parseInt(value.substring(2, 4), 16),
        b: parseInt(value.substring(4, 6), 16),
      };
    }


   function createLayerNamePill(layerName, shapeItem) { // Signature remains unchanged
  if (!layerName || !shapeItem) return null;

  // Retrieve the propertyGroupIdentifier from the WeakMap
  const propertyGroupIdentifier = pillPropertyGroupMap.get(shapeItem);

  const pill = document.createElement('span');
  pill.className = 'layer-name-pill';

  if (propertyGroupIdentifier) { // Store the group identifier on the pill if found
    pill.dataset.propertyGroupId = propertyGroupIdentifier;
  } else {
    // Fallback or legacy behavior: if no propertyGroupIdentifier is found,
    // you might want to use the old layerId logic or log a warning.
    // For now, we'll assume it should ideally always be found.
    // If not, the pill's toggle might not group correctly with others.
    console.warn("Pill created for shapeItem without a propertyGroupIdentifier in WeakMap. Layer:", layerName, "ShapeItem:", shapeItem);
    // Optionally, generate a less specific ID for fallback:
    // const layerId = layerName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    // pill.dataset.layerId = layerId; // Old way for fallback
  }

  const iconWrapper = document.createElement('span');
  iconWrapper.className = 'pill-icon';
  iconWrapper.innerHTML = layerIconSvg.trim();
  pill.appendChild(iconWrapper.firstChild);
  pill.appendChild(document.createTextNode(layerName));

  pill.classList.toggle('hidden', !!shapeItem.hd);
  pill.title = 'Click to toggle visibility of this property';
  pill.setAttribute('aria-label', 'Click to toggle visibility of this property');

  pill.addEventListener('click', e => {
    e.stopPropagation();
    shapeItem.hd = !shapeItem.hd; // Toggle the Lottie object's visibility

    const groupId = e.currentTarget.dataset.propertyGroupId; // Try to use the specific group ID
    if (groupId) {
      // Toggle all pills that share this specific property group ID
      document.querySelectorAll(`.layer-name-pill[data-property-group-id="${groupId}"]`)
        .forEach(el => el.classList.toggle('hidden', shapeItem.hd));
    } else {
      // Fallback: if no group ID on the pill, just toggle the clicked pill.
      // This might happen if the WeakMap entry wasn't set.
      e.currentTarget.classList.toggle('hidden', shapeItem.hd);
      console.warn("Pill clicked without a data-property-group-id:", e.currentTarget);
    }
    reloadLottiePreview();
  });

  return pill;
}

    function getLayerNameFromPath(lottieDataObject, objectPathArray) {
       let layerName = null;

       // Iterate upwards from the object's path to find its containing layer
       // We need to find a 'layers' segment in the path.
       for (let i = 0; i < objectPathArray.length -1; i++) { // Iterate up to path.length - 1 to safely access path[i+1]
           if (objectPathArray[i] === 'layers' && typeof objectPathArray[i + 1] === 'number') {
               // This segment of the path looks like '...layers[index]...'
               const pathToLayerObject = objectPathArray.slice(0, i + 2); // e.g., ['layers', 0] or ['assets', 0, 'layers', 1]
               try {
                   const layerObject = getValueByPath(lottieDataObject, pathToLayerObject);
                   if (layerObject && layerObject.nm) {
                       layerName = layerObject.nm;
                       // We take the *first* layer name encountered when going down the path.
                       // If a color is in a shape group within a layer, this will get the layer name.
                       break;
                   } else if (layerObject) {
                       // layerName = `Layer ${objectPathArray[i + 1]}`; // Fallback, but we prefer named layers
                       break; // Stop if we found a layer, even unnamed, to avoid picking up shape names later
                   }
               } catch (e) {
                   // console.warn("Could not get layer object for naming from path:", pathToLayerObject, e);
               }
           }
       }
        // If no layer name found through 'layers' array (e.g. color directly on a named root shape/group)
       if (!layerName && objectPathArray.length > 0) {
           try {
               // Path to the direct container of the property (e.g., shape item holding 'c' or 'g')
               const propertyContainerObject = getValueByPath(lottieDataObject, objectPathArray);
               if (propertyContainerObject && propertyContainerObject.nm) {
                   // This could be a shape group name. Only use if no layer name was found.
                   layerName = propertyContainerObject.nm;
               }
           } catch (e) { /* ignore */ }
       }
       return layerName;
   }


   function findPathToObject(root, target, currentPath = [], visited = new WeakSet()) {
       if (root === target) {
           return currentPath;
       }

       if (!root || typeof root !== 'object' || visited.has(root)) {
           return null;
       }
       visited.add(root);

       if (Array.isArray(root)) {
           for (let i = 0; i < root.length; i++) {
               const result = findPathToObject(root[i], target, [...currentPath, i], visited);
               if (result) return result;
           }
       } else {
           for (const key in root) {
               if (Object.prototype.hasOwnProperty.call(root, key)) {
                   // Skip purely internal/helper properties if any, though usually not needed for clean Lottie data
                   // if (key.startsWith('_') && key !== '_path') continue;
                   const result = findPathToObject(root[key], target, [...currentPath, key], visited);
                   if (result) return result;
               }
           }
       }
       return null;
   }





    /**
     * Recursively finds solid color definitions (like {c: {k: [r,g,b,a]}}) in the Lottie JSON.
     */
     function findColors(obj, path = []) {
          if (Array.isArray(obj)) {
            obj.forEach((item, i) => findColors(item, [...path, i]));
          } else if (typeof obj === 'object' && obj !== null) {
            // Check for solid color property: obj.c.k = [r,g,b,a] (and not animated: obj.c.a is 0 or not present)
            if (
              obj.hasOwnProperty('c') && typeof obj.c === 'object' && obj.c !== null &&
              obj.c.hasOwnProperty('k') && Array.isArray(obj.c.k) &&
              obj.c.k.length >= 3 && obj.c.k.length <= 4 && // [r,g,b] or [r,g,b,a]
              obj.c.k.every(val => typeof val === 'number') &&
              (!obj.c.hasOwnProperty('a') || obj.c.a === 0) // 'a':0 means static, 'a':1 means animated. No 'a' also means static.
            ) {
              // --- MODIFIED: Use getLayerNameFromPath ---
              // 'path' here is the path to the object containing the 'c' property.
              // getLayerNameFromPath expects the path to the object itself or its direct parent.
              // If 'c' is directly on a layer item, `path` is correct.
              // If 'c' is on a shape within a layer, `path` will lead to that shape.
              let layerName = getLayerNameFromPath(lottieData, path); // lottieData must be accessible

              if (!layerName || layerName === 'Unnamed Layer' || layerName === 'Unknown Layer') {
                  layerName = 'Unnamed Element'; // A more generic fallback if no good name is found
              }
              // --- END MODIFICATION ---

              colorRefs.push({
                path: [...path, 'c', 'k'], // Path to the color array itself
                original: [...obj.c.k],    // Original [r,g,b,a] values
                layerName: layerName       // Determined layer name
              });
            }

            // Recursively search child properties
            for (let key in obj) {
              // Avoid re-processing assets from root level, only from initial call
              if (key !== 'assets' || path.length === 0) {
                findColors(obj[key], [...path, key]);
              }
            }
          }
        }
    /**
     * Retrieves a value from an object using a path array.
     */





    /**
     * Updates a specific solid color in the `lottieData` object.
     */
     function updateColor(ref, newHex) {
       const rgbNew = hexToRgb(newHex); // Calculate new RGB values
       const currentVal = getValueByPath(lottieData, ref.path); // Get current value (old value)

       // Ensure currentVal is an array and make a copy for oldValue
       const oldValueArray = Array.isArray(currentVal) ? [...currentVal] : [...rgbNew, 1]; // Fallback if path was invalid

       const currentAlpha = (Array.isArray(currentVal) && currentVal.length === 4) ? currentVal[3] : 1;
       const finalColorNew = [...rgbNew, currentAlpha]; // New color array

       // --- NEW: Record change (delta) ---
       recordChange({
         type: 'SOLID_COLOR',
         path: [...ref.path], // Store a copy of the path
         oldValue: oldValueArray,
         newValue: finalColorNew
       });
       // --- END NEW ---

       setValueByPath(lottieData, ref.path, finalColorNew);
       reloadLottiePreview();
     }

    /**
     * Extracts all gradient definitions from the Lottie JSON.
     */
     function extractGradientStops(json) {
         const gradients = [];
         const visited = new WeakSet();
         const stack = [json];

         try {
             while (stack.length > 0) {
                 const obj = stack.pop();

                 if (typeof obj !== 'object' || obj === null || visited.has(obj)) {
                     continue;
                 }
                 visited.add(obj);

                 // Check if it's a gradient fill (gf) and has gradient color data
                 if (obj.ty === 'gf' && obj.g?.k?.k && Array.isArray(obj.g.k.k) && obj.g.p) {

                     // 🚫 Ignore animated gradients:
                     if (obj.g.k.a === 1) {
                         console.log("Skipping animated gradient:", obj);
                         continue; // Skip processing this gradient since it's animated
                     }

                     const rawColorData = obj.g.k.k;
                     const numColorStops = obj.g.p;
                     const hasOpacity = rawColorData.length === numColorStops * 6;
                     const gradient = [];

                     for (let i = 0; i < numColorStops; i++) {
                         const colorBaseIndex = i * 4;
                         const offset = rawColorData[colorBaseIndex];
                         const r = rawColorData[colorBaseIndex + 1] * 255;
                         const g = rawColorData[colorBaseIndex + 2] * 255;
                         const b = rawColorData[colorBaseIndex + 3] * 255;
                         let a = 1;

                         if (hasOpacity) {
                             const opacityBaseIndex = numColorStops * 4 + i * 2;
                             a = rawColorData[opacityBaseIndex + 1];
                         }

                         gradient.push({
                             offset: Math.round(offset * 100),
                             r: Math.round(r),
                             g: Math.round(g),
                             b: Math.round(b),
                             a: parseFloat(a.toFixed(2)),
                             _path: obj // Store reference
                         });
                     }
                     gradients.push(gradient);
                 }

                 // Traverse deeper into the object tree
                 for (const value of Object.values(obj)) {
                     if (typeof value === 'object' && value !== null) {
                         if (Array.isArray(value)) {
                             for (let i = value.length - 1; i >= 0; i--) {
                                 if (typeof value[i] === 'object' && value[i] !== null) {
                                     stack.push(value[i]);
                                 }
                             }
                         } else {
                             stack.push(value);
                         }
                     }
                 }
             }
             return gradients;
         } catch (error) {
             console.error('Error extracting gradients:', error);
             return [];
         }
     }

    /**
     * Updates the Lottie JSON data based on changes made in the gradient editor UI.
     */
    function updateLottieGradient() {
        if (!lottieData || allGradients.length === 0) return;

        allGradients.forEach(gradientStops => {
            const gradientObj = gradientStops[0]?._path;
            if (!gradientObj || !gradientObj.g?.k?.k) {
                console.warn("Could not find original Lottie object for gradient:", gradientStops);
                return;
            }

            const rawColorData = gradientObj.g.k.k;
            const numColorStops = gradientObj.g.p;
            const needsOpacityUpdate = gradientStops.some(s => s.a !== 1);
            const colorDataLength = numColorStops * 4;
            const newRawData = new Array(needsOpacityUpdate ? numColorStops * 6 : numColorStops * 4);

            gradientStops.forEach((stop, i) => {
                const baseIndex = i * 4;
                newRawData[baseIndex]     = stop.offset / 100;
                newRawData[baseIndex + 1] = stop.r / 255;
                newRawData[baseIndex + 2] = stop.g / 255;
                newRawData[baseIndex + 3] = stop.b / 255;
            });

            if (needsOpacityUpdate) {
                gradientStops.forEach((stop, i) => {
                    const opacityBaseIndex = colorDataLength + i * 2;
                    newRawData[opacityBaseIndex]     = stop.offset / 100;
                    newRawData[opacityBaseIndex + 1] = stop.a;
                });
            }

            gradientObj.g.k.k = newRawData;
        });

        reloadLottiePreview();
    }


    /**
     * Reloads the Lottie animation preview with the current `lottieData`.
     */

     // Ensure 'isPlaying' is globally accessible and correctly maintained by playPauseBtn and seekbar interactions.
// For example, if you want the default to be playing (from a previous request):
// let isPlaying = true;

// No new global variable for 'lastInteractedFrame' is strictly needed with this approach,
// as currentFrame is read directly if paused.

function reloadLottiePreview() {
    let targetFrameForLoad = 0; // Default to frame 0

    if (animationInstance) {
        // If the animation was paused, we want to remember which frame it was on.
        // If it was playing, the new requirement is to restart from frame 0.
        if (!isPlaying) { // If the animation state was "paused"
            targetFrameForLoad = animationInstance.currentFrame;
        }
        // If isPlaying is true, targetFrameForLoad remains 0, as we'll play from the start.

        animationInstance.destroy();
        animationInstance = null;
    }
    // If there was no previous animationInstance, targetFrameForLoad remains 0.

    if (!lottieData || !lottiePreview) return;

    const playbackData = JSON.parse(JSON.stringify(lottieData));

    // The 'autoplay' option will reflect the 'isPlaying' state.
    // If isPlaying is true, Lottie might attempt to autoplay. We'll refine this in DOMLoaded.
    animationInstance = lottie.loadAnimation({
        container: lottiePreview,
        renderer: 'svg',
        loop: true,
        autoplay: isPlaying, // Set autoplay based on the desired state
        animationData: playbackData,
        rendererSettings: {
            preserveAspectRatio: 'xMidYMid meet',
            fontFamily: 'Arial, Helvetica, sans-serif'
        }
    });

    animationInstance.setSpeed(currentSpeed);

    animationInstance.addEventListener('DOMLoaded', () => {
        if (animationInstance) {
            lottieSeekbar.max = animationInstance.totalFrames > 0 ? animationInstance.totalFrames - 1 : 0;

            if (isPlaying) {
                // If the desired state is "playing", start playing from the first frame.
                animationInstance.goToAndPlay(0, true);
                lottieSeekbar.value = 0;
            } else {
                // If the desired state is "paused", go to the target frame and stop.
                animationInstance.goToAndStop(targetFrameForLoad, true);
                lottieSeekbar.value = targetFrameForLoad;
            }
        }
    });

    animationInstance.addEventListener('enterFrame', () => {
        if (animationInstance && !lottieSeekbar.matches(':active')) { // Don't update if user is dragging
            lottieSeekbar.value = animationInstance.currentFrame;
        }
    });

    animationInstance.addEventListener('loopComplete', () => {
        if (isPlaying) { // if it is playing, it should continue to play after loop (from frame 0)
            animationInstance.goToAndPlay(0, true);
        }
        // If !isPlaying, it's paused, so on loopComplete, it should remain paused at the end frame.
        // The Lottie player usually stops at the last frame on loopComplete if loop is false.
        // Since loop is true here, this handler for isPlaying=true ensures it restarts.
        // If isPlaying=false, it should ideally stay at the currentFrame (which would be the end).
    });

    animationInstance.addEventListener('data_failed', () => { console.error("Lottie data failed to load in preview."); });
    animationInstance.addEventListener('error', (error) => { console.error("Lottie animation error:", error); });
}



     function renderColorPickers() {

    colorEditor.innerHTML = "";

    if (!initialColorGroups || Object.keys(initialColorGroups).length === 0) {
     updateDownloadButtonsState();
     return;
    }

    Object.entries(initialColorGroups).forEach(([originalGroupHex, refsInGroup]) => { // Renamed 'refs' to 'refsInGroup' for clarity
      let currentGroupHexDisplay; // This will be the hex shown in the accordion header
      if (refsInGroup.length > 0) {
        // Get the color from the first instance in the group as it currently exists in lottieData
        const [r, g, b] = getValueByPath(lottieData, refsInGroup[0].ref.path); // refsInGroup[0].ref is the actual colorRef object
        currentGroupHexDisplay = rgbToHex(r, g, b);
      } else {
        currentGroupHexDisplay = originalGroupHex; // Should not happen if group exists
      }

      const accordion = document.createElement("div");
      accordion.className = "accordion";
      accordion.dataset.id = originalGroupHex;

      const header = document.createElement("div");
      header.className = "accordion-header";

      const headerContent = document.createElement("div");
      headerContent.className = "accordion-header-content";

      const title = document.createElement("span");
      title.textContent = `${refsInGroup.length} Instance${refsInGroup.length > 1 ? 's' : ''}`;

      const controls = document.createElement("div");
      controls.className = "accordion-header-controls color-input-group";

      const groupHexInput = document.createElement("input");
      groupHexInput.type = "text";
      groupHexInput.value = currentGroupHexDisplay; // Use the current hex for display
      groupHexInput.setAttribute("aria-label", `Hex code for color group ${currentGroupHexDisplay}`);

      const groupColorInput = document.createElement("input");
      groupColorInput.type = "color";
      groupColorInput.value = currentGroupHexDisplay; // Use the current hex for display
      groupColorInput.setAttribute("aria-label", `Color picker for color group ${currentGroupHexDisplay}`);

      // ... (rest of header setup, event listeners for groupHexInput, groupColorInput remain the same) ...
      controls.appendChild(groupHexInput);
      controls.appendChild(groupColorInput);

      headerContent.appendChild(title);
      headerContent.appendChild(controls);
      header.appendChild(headerContent);

      const body = document.createElement("div");
      body.className = "accordion-body";
      body.id = `accordion-body-${originalGroupHex.replace('#','')}`;

      // --- Apply Preserved State ---
      if (preservedColorAccordionStates[originalGroupHex] === true) {
       header.classList.add('active');
       body.classList.add('active');
       body.style.display = "flex";
       header.setAttribute('aria-expanded', 'true');
      } else {
         body.style.display = "none";
         header.setAttribute('aria-expanded', 'false');
      }
      // --- End Apply Preserved State ---

      const handleHeaderInput = (newHex) => {
           if (!/^#[0-9A-F]{6}$/i.test(newHex)) return;

           const itemsToRecord = [];
           const newBaseRgb = hexToRgb(newHex);

           refsInGroup.forEach(({ ref }) => { // ref here is the actual colorRef object {path, original, layerName}
             const currentPath = [...ref.path];
             const currentValue = getValueByPath(lottieData, currentPath);
             const oldRgbaValue = Array.isArray(currentValue) && currentValue.length >= 3 ?
                                  [...currentValue] :
                                  [...newBaseRgb, 1];
             itemsToRecord.push({
               path: currentPath,
               oldValue: oldRgbaValue,
             });
             const existingAlpha = (Array.isArray(currentValue) && currentValue.length === 4) ? currentValue[3] : 1;
             const finalColorNewWithExistingAlpha = [...newBaseRgb, existingAlpha];
             setValueByPath(lottieData, currentPath, finalColorNewWithExistingAlpha);
           });

           if (itemsToRecord.length > 0) {
             recordChange({
               type: 'SOLID_COLOR_ACCORDION',
               items: itemsToRecord,
               newBaseRgbApplied: newBaseRgb
             });
           }
           // Update UI for accordion header and child rows
           groupColorInput.value = newHex; // Update header picker
           groupHexInput.value = newHex;   // Update header hex input

           const rows = body.querySelectorAll('.color-row');
           rows.forEach(row => {
             row.querySelector('input[type="color"]').value = newHex;
             row.querySelector('input[type="text"]').value = newHex;
           });
           reloadLottiePreview();
      };

      commitAfterIdle(groupColorInput, hex => handleHeaderInput(hex), 100);

      groupHexInput.addEventListener("change", (e) => {
          let newHex = e.target.value.trim();
          if (!newHex.startsWith("#")) newHex = "#" + newHex;
          if (/^#[0-9A-F]{6}$/i.test(newHex)) {
              handleHeaderInput(newHex);
          } else {
              alert("Invalid hex code. Please use format #RRGGBB.");
              groupHexInput.value = groupColorInput.value;
          }
      });

      // Iterate over instances within this color group
      refsInGroup.forEach((groupedItem, groupLocalIndex) => {
        const actualColorRef = groupedItem.ref; // This is { path, original, layerName }
        const globalOriginalIndex = groupedItem.index; // Original index from colorRefs array

        const colorArray = getValueByPath(lottieData, actualColorRef.path);
        if (!colorArray || colorArray.length < 3) return; // Should not happen if data is consistent

        const [r, g, b] = colorArray;
        const currentColorHex = rgbToHex(r, g, b); // Get current hex of this specific instance

        const row = document.createElement("div");
        row.className = "color-row";

        const labelWrapper = document.createElement('div');
          labelWrapper.className = 'title-wrapper';// Create a wrapper for main label and pill
         labelWrapper.style.display = 'flex';
         labelWrapper.style.alignItems = 'center';

         const mainLabel = document.createElement("label");
         let instanceLabelText = `Instance ${groupLocalIndex + 1}`;
         mainLabel.textContent = instanceLabelText;
         mainLabel.htmlFor = `color-input-${globalOriginalIndex}`;
         labelWrapper.appendChild(mainLabel);

         // --- NEW: Create and append layer name pill ---
         const fullPath = actualColorRef.path;
const shapePath = fullPath.slice(0, -2);
// getValueByPath is your helper that walks lottieData by path
const shapeItem = getValueByPath(lottieData, shapePath);

const propertyGroupIdentifier = pathToGroupId(actualColorRef.path);
if (shapeItem) { // Ensure shapeItem is valid before setting in WeakMap
    pillPropertyGroupMap.set(shapeItem, propertyGroupIdentifier); // <<< SET IN WEAKMAP
}

const layerPill = createLayerNamePill(
  actualColorRef.layerName,
  shapeItem
);
if (layerPill) {
  labelWrapper.appendChild(layerPill);
}
         // --- END NEW ---

        const inputGroup = document.createElement("div");
        inputGroup.className = "color-input-group";

        const hexInput = document.createElement("input");
        hexInput.type = "text";
        hexInput.value = currentColorHex; // Display current hex of this instance
        hexInput.id = `hex-input-${globalOriginalIndex}`;
        hexInput.setAttribute("aria-label", `Hex code for ${instanceLabelText}`);

        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = currentColorHex; // Display current hex of this instance
        colorInput.id = `color-input-${globalOriginalIndex}`;
        colorInput.setAttribute("aria-label", `Color picker for ${instanceLabelText}`);

        inputGroup.appendChild(hexInput); // Changed order to hex then picker, or keep as is
        inputGroup.appendChild(colorInput);

        const handleIndividualInput = (newHex) => {
           if (!/^#[0-9A-F]{6}$/i.test(newHex)) return;
           // Update this specific instance
           updateColor(actualColorRef, newHex); // updateColor handles recording and uses actualColorRef.path

           // Sync this row's inputs
           colorInput.value = newHex;
           hexInput.value = newHex;

           // Check if all instances in this group now match the newHex
           // If so, update the accordion header. Otherwise, header might show 'Multiple' or first item.
           // For simplicity, let's re-evaluate the header's display color based on the first item after this change.
           const firstItemInGroupPath = refsInGroup[0].ref.path;
           const [firstR, firstG, firstB] = getValueByPath(lottieData, firstItemInGroupPath);
           groupColorInput.value = rgbToHex(firstR, firstG, firstB);
           groupHexInput.value = rgbToHex(firstR, firstG, firstB);
           // A more sophisticated approach would be to check if ALL items in `refsInGroup` are `newHex`.
        };

        commitAfterIdle(colorInput, hex => handleIndividualInput(hex), 100);

        hexInput.addEventListener("change", (e) => {
              let newHex = e.target.value.trim();
              if (!newHex.startsWith("#")) newHex = "#" + newHex;
              if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                  handleIndividualInput(newHex);
              } else {
                  alert("Invalid hex code. Please use format #RRGGBB.");
                  hexInput.value = colorInput.value;
              }
        });

        row.appendChild(labelWrapper);
        row.appendChild(inputGroup);
        body.appendChild(row);
      });

      header.addEventListener("click", (e) => {
        if (e.target.closest('input[type="color"], input[type="text"]')) {
          return;
        }
        const isActive = body.classList.toggle("active");
        header.classList.toggle("active", isActive);
        body.style.display = isActive ? "flex" : "none";
        header.setAttribute('aria-expanded', isActive);
      });
      header.setAttribute('aria-expanded', 'false');
      header.setAttribute('role', 'button');
      header.setAttribute('aria-controls', body.id);

      accordion.appendChild(header);
      accordion.appendChild(body);
      colorEditor.appendChild(accordion);
    });

    updateDownloadButtonsState();
  }
    /**
     * Renders the accordion UI for editing gradient stops.
     */
    function renderGradientEditor() {


      const mainLabel = document.getElementById('gradientInstancesLabel'); // The H3 heading "Detected Text"




        stopEditor.innerHTML = '';

        if (allGradients.length === 0) {
                if (mainLabel) mainLabel.style.display = 'none';
             return;
        }

          if (mainLabel) mainLabel.style.display = 'block';

        allGradients.forEach((gradientStops, index) => {
          const gradientId = String(index);
            const accordion = document.createElement('div');
            accordion.className = 'gradient-accordion';
            accordion.dataset.id = gradientId;

            const header = document.createElement('div');
            header.className = 'gradient-header';

            const headerContent = document.createElement("div");
            headerContent.className = "accordion-header-content";

            // Left part of header: Title and Pill
                      const titlePillWrapper = document.createElement('div');
                        titlePillWrapper.className =  'title-wrapper';


                      const title = document.createElement("span");
                      title.textContent = `Gradient ${index + 1}`;
                      titlePillWrapper.appendChild(title);

                      const gradientObjRef = gradientStops[0]?._path;
      if (gradientObjRef && lottieData) {
        const pathToObject = findPathToObject(lottieData, gradientObjRef);
        if (pathToObject) {
          const layerName = getLayerNameFromPath(lottieData, pathToObject);
          // Grab the exact gradient object from the JSON
          const shapeItem = getValueByPath(lottieData, pathToObject);

	const propertyGroupIdentifier = pathToGroupId(pathToObject);

    pillPropertyGroupMap.set(shapeItem, propertyGroupIdentifier);

          // Pass shapeItem into your pill so its click‐handler can toggle only this property
          const layerPill = createLayerNamePill(layerName, shapeItem);
          if (layerPill) {
            titlePillWrapper.appendChild(layerPill);
          }
        }
      }
                      headerContent.appendChild(titlePillWrapper); // Add title+pill group to left



            const gradientPreview = document.createElement('div');
            gradientPreview.className = 'gradient-preview';
            gradientPreview.setAttribute('aria-label', `Preview for Gradient ${index + 1}`);


            headerContent.appendChild(gradientPreview);
            header.appendChild(headerContent);

            const contentBody = document.createElement('div');
            contentBody.className = 'gradient-content';
             contentBody.id = `gradient-body-${index}`;


             // --- APPLY PRESERVED STATE ---
              if (preservedGradientAccordionStates[gradientId] === true) {
                  header.classList.add('active');
                  contentBody.classList.add('active'); // Your CSS might use this
                  contentBody.style.display = 'flex'; // Or "block"
                  header.setAttribute('aria-expanded', 'true');
              } else {
                  contentBody.style.display = 'none'; // Default to closed
                  header.setAttribute('aria-expanded', 'false');
              }
              // --- END APPLY PRESERVED STATE ---


            gradientStops.forEach((stop, i) => {
                const row = document.createElement('div');
                row.className = 'stop-row';

                const label = document.createElement('span');
                label.className = 'label';
                label.textContent = `Stop ${i + 1} (${stop.offset}%)`;

                const stopControls = document.createElement('div');
                stopControls.className = 'stop-controls';

                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a ?? 1})`;

                const alphaInput = document.createElement('input');
                alphaInput.type = 'number';
                alphaInput.min = 0;
                alphaInput.max = 100;
                alphaInput.step = 1;
                alphaInput.value = Math.round((stop.a ?? 1) * 100);
                alphaInput.setAttribute('aria-label', `Opacity for Stop ${i + 1} in Gradient ${index + 1}`);
                alphaInput.title = `Opacity (0 to 100)`;

                const inputGroup = document.createElement("div");
                inputGroup.className = "color-input-group";

                const hexInput = document.createElement('input');
                hexInput.type = 'text';
                hexInput.value = rgbToHexGr(stop.r, stop.g, stop.b);
                hexInput.setAttribute('aria-label', `Hex code for Stop ${i + 1} in Gradient ${index + 1}`);
                hexInput.title = `Hex Color Code`;

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = rgbToHexGr(stop.r, stop.g, stop.b);
                colorInput.setAttribute('aria-label', `Color picker for Stop ${i + 1} in Gradient ${index + 1}`);
                colorInput.title = `Color Picker`;

                inputGroup.appendChild(hexInput);
                inputGroup.appendChild(colorInput);

                const updateStopColor = (hex) => {
                    if (!/^#([0-9A-Fa-f]{6})$/i.test(hex)) return;
                    const { r, g, b } = hexToRGBGr(hex);
                    stop.r = r;
                    stop.g = g;
                    stop.b = b;
                    dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${stop.a ?? 1})`;
                    colorInput.value = hex;
                    updateGradientPreviewStyle();
                    updateLottieGradient();
                };

                /*colorInput.addEventListener('change', (e) => {
                  const newHex = e.target.value;
                  const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                  // --- NEW: Record change (delta) ---
                  const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset }; // Include offset for completeness if needed for redo, though not changing it

                  const newRgb = hexToRGBGr(newHex);
                  const newStopData = { r: newRgb.r, g: newRgb.g, b: newRgb.b, a: oldA, offset: stop.offset };

                  recordChange({
                  type: 'GRADIENT_STOP',
                  gradientIndex: index, // Index of the current gradient in allGradients
                  stopIndex: i,         // Index of the current stop in gradientStops
                  oldStopData: oldStopData,
                  newStopData: newStopData
                  });
                  // --- END NEW ---

                  hexInput.value = newHex;
                  updateStopColor(newHex);
                });*/

                commitAfterIdle(colorInput, (newHex) => {
                 const { r: oldR, g: oldG, b: oldB, a: oldA } = stop;

                // Record change (delta) once per drag
                 const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };
                const { r: nr, g: ng, b: nb } = hexToRGBGr(newHex);
                 const newStopData = { r: nr, g: ng, b: nb, a: oldA, offset: stop.offset };

                 recordChange({
                  type: 'GRADIENT_STOP',
                   gradientIndex: index,
                   stopIndex: i,
                   oldStopData,
                   newStopData
                 });

                 hexInput.value = newHex;
                 updateStopColor(newHex);
               }, 150);



                hexInput.addEventListener('change', (e) => {
                  let newHexVal = e.target.value.trim();
                  if (!newHexVal.startsWith("#")) newHexVal = "#" + newHexVal;
                  if (/^#([0-9A-Fa-f]{6})$/i.test(newHexVal)) {
                    const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                    // --- NEW: Record change (delta) ---
                    const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };

                    const newRgb = hexToRGBGr(newHexVal);
                    const newStopData = { r: newRgb.r, g: newRgb.g, b: newRgb.b, a: oldA, offset: stop.offset };

                    recordChange({
                      type: 'GRADIENT_STOP',
                      gradientIndex: index,
                      stopIndex: i,
                      oldStopData: oldStopData,
                      newStopData: newStopData
                    });
                    // --- END NEW ---
                    updateStopColor(newHexVal);
                  } else {
                    alert("Invalid hex code. Please use format #RRGGBB.");
                    hexInput.value = colorInput.value;
                  }
                });

                alphaInput.addEventListener('change', (e) => {
                  let value100 = parseInt(e.target.value, 10);
                  if (isNaN(value100)) value100 = 0;
                  else value100 = Math.max(0, Math.min(100, value100));
                  e.target.value = value100; // Update input field immediately

                  const newAlpha = value100 / 100;
                  const { r: oldR, g: oldG, b: oldB, a: oldA } = stop; // Capture old stop data

                  // --- NEW: Record change (delta) ---
                  const oldStopData = { r: oldR, g: oldG, b: oldB, a: oldA, offset: stop.offset };
                  const newStopData = { r: oldR, g: oldG, b: oldB, a: newAlpha, offset: stop.offset };

                  recordChange({
                    type: 'GRADIENT_STOP',
                    gradientIndex: index,
                    stopIndex: i,
                    oldStopData: oldStopData,
                    newStopData: newStopData
                  });
                  // --- END NEW ---

                  stop.a = newAlpha; // Apply the change to the stop object
                  dot.style.backgroundColor = `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a})`;
                  updateGradientPreviewStyle(); // This function is local to renderGradientEditor
                  updateLottieGradient(); // This updates lottieData based on allGradients
                });;

                stopControls.appendChild(dot);
                stopControls.appendChild(alphaInput);
                stopControls.appendChild(inputGroup);
                row.appendChild(label);
                row.appendChild(stopControls);
                contentBody.appendChild(row);
            });

            function updateGradientPreviewStyle() {
                const sortedStops = [...gradientStops].sort((a, b) => a.offset - b.offset);
                const gradientStyle = `linear-gradient(to right, ${sortedStops.map(stop =>
                    `rgba(${stop.r}, ${stop.g}, ${stop.b}, ${stop.a ?? 1}) ${stop.offset}%`
                ).join(', ')})`;
                gradientPreview.style.background = gradientStyle;
            }

            updateGradientPreviewStyle();

            header.addEventListener('click', (e) => {
                 if (e.target.closest('.gradient-preview')) {
                    return;
                 }
                const isActive = contentBody.classList.toggle("active");
                header.classList.toggle("active", isActive);
                contentBody.style.display = isActive ? 'flex' : 'none';
                header.setAttribute('aria-expanded', isActive);
            });

            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('role', 'button');
            header.setAttribute('aria-controls', `gradient-body-${index}`);
            contentBody.id = `gradient-body-${index}`;

            accordion.appendChild(header);
            accordion.appendChild(contentBody);
            stopEditor.appendChild(accordion);
        });

        updateDownloadButtonsState();
    }

    /**
     * Updates the enabled/disabled state of download and editor buttons.
     */
    function updateDownloadButtonsState() {
        const isDataLoaded = !!lottieData;

        // JSON Download Button
        downloadJsonBtn.disabled = !isDataLoaded;
        downloadJsonBtn.style.display = isDataLoaded ? 'inline-flex' : 'none';

        // GIF Download Button
        downloadGifBtn.disabled = !isDataLoaded;
        downloadGifBtn.style.display = isDataLoaded ? 'inline-flex' : 'none';

        // Trim Overlay Button
        openOverlayBtn.disabled = !isDataLoaded;
        // openOverlayBtn.style.opacity = isDataLoaded ? "1" : "0.5"; // Opacity handled by :disabled state

        // *** NEW: Crop Overlay Button ***
        openCropBtn.disabled = !isDataLoaded;
        // openCropBtn.style.opacity = isDataLoaded ? "1" : "0.5"; // Opacity handled by :disabled state

      openAssetReplacerBtn.disabled = !isDataLoaded;
        // GIF Options Card
        const gifOptionsCard = document.getElementById('gifOptionsCard');
        if (gifOptionsCard) {
            gifOptionsCard.style.display = isDataLoaded ? 'block' : 'none';
        }
        // JSON Editor Card
        const jsonEditorCard = document.getElementById('jsonEditorCard');
        if (jsonEditorCard) {
            jsonEditorCard.style.display = isDataLoaded ? 'block' : 'none';
        }
    }

    /**
     * Cleans the Lottie data object by removing internal properties before export.
     */
    function cleanForExport(obj) {
        if (Array.isArray(obj)) {
            return obj.map(cleanForExport);
        }
        if (typeof obj === 'object' && obj !== null) {
            const clean = {};
            for (const [key, value] of Object.entries(obj)) {
                if (key.startsWith('_') || key === 'completed' || key === '__complete') {
                    continue;
                }
                clean[key] = cleanForExport(value);
            }
            return clean;
        }
        return obj;
    }


    /**
     * Handles the file input change event. Reads the JSON file, parses it,
     * initializes the editors, and updates the UI.
     */

     function handleDragOver(e) {
    e.preventDefault();
    dragDropOverlay.classList.add('dragover');
}

function handleDragLeave(e) {
    e.preventDefault();
    dragDropOverlay.classList.remove('dragover');
}

function handleDrop(e) {
    e.preventDefault();
    dragDropOverlay.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        const file = files[0];
        if (file.type === "application/json" || file.name.endsWith('.json')) {
            // Create a fake FileList to reuse the existing handler
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;
            handleFileLoad({ target: fileInput });
        } else {
            alert('Please drop a JSON file');
        }
    }
}


dragDropOverlay.addEventListener('click', () => {
  fileInput.click();
});

// Add event listeners for drag and drop
dragDropOverlay.addEventListener('dragover', handleDragOver);
dragDropOverlay.addEventListener('dragleave', handleDragLeave);
dragDropOverlay.addEventListener('drop', handleDrop);





    function handleFileLoad(e) {
      const file = e.target.files[0];
      initialColorGroups = null;
initialAnimatedColorGroupsByHex = null;
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          lottieData = JSON.parse(event.target.result);

          if (!lottieData.v || !lottieData.fr || !lottieData.w || !lottieData.h || !lottieData.layers) {
              throw new Error("File does not appear to be a valid Lottie JSON.");
          }

          // --- NEW: Store original data and reset undo/redo stacks ---
          originalLottieDataForReset = JSON.parse(JSON.stringify(lottieData)); // Deep copy for reset
          undoStack = [];
          redoStack = [];
          // --- END NEW ---

          originalFrameRate = lottieData.fr;
          animWidth = lottieData.w;
          animHeight = lottieData.h;
          originalAnimationDuration = (lottieData.op - lottieData.ip) / lottieData.fr; // Calculate duration

          // --- START: Add this conditional logic ---
      const gifScale4xOption = document.getElementById('gifScale4x');
      const gifScale8xOption = document.getElementById('gifScale8x');

      if (gifScale4xOption && gifScale8xOption) {
          if (animWidth < 101 || animHeight < 101) {
              // If width or height is small, show the options
              gifScale4xOption.hidden = false;
              gifScale8xOption.hidden = false;
              // Optionally, you could enable them if they were disabled:
              // gifScale4xOption.disabled = false;
              // gifScale8xOption.disabled = false;
          } else {
              // Otherwise, ensure they are hidden (or disabled)
              gifScale4xOption.hidden = true;
              gifScale8xOption.hidden = true;
              // gifScale4xOption.disabled = true;
              // gifScale8xOption.disabled = true;

              // If the currently selected value is 4x or 8x, reset to 1x
              const gifScaleSelect = document.getElementById('gifScale');
              if (gifScaleSelect.value === '4' || gifScaleSelect.value === '8') {
                  gifScaleSelect.value = '1';
              }
          }
      }
      // --- END: Add this conditional logic ---

          colorRefs = [];
          allGradients = [];

          preservedTextAccordionStates = {};

          findColors(lottieData);


          detectedTextElements = [];
          findTextLayersRecursive(lottieData.layers, '', ['lottieData']); // Search root layers
if (lottieData.assets) { // Also search within assets if they exist
    lottieData.assets.forEach((asset, assetIndex) => {
        if (asset.layers) {
            findTextLayersRecursive(asset.layers, asset.id || `asset${assetIndex}_`, ['lottieData', 'assets', assetIndex]);
        }
    });
}


          // Inside handleFileLoad, after findColors(lottieData);
          initialColorGroups = {};
          colorRefs.forEach((ref, i) => {
              const colorArray = getValueByPath(lottieData, ref.path); // Get current (initial) color
              if (!colorArray || colorArray.length < 3) return;
              const [r, g, b] = colorArray;
              const initialHex = rgbToHex(r, g, b); // This is the hex at load time
              if (!initialColorGroups[initialHex]) {
                  initialColorGroups[initialHex] = [];
              }
              // Store the reference, its original overall index, and its original hex for later use
              initialColorGroups[initialHex].push({ ref: ref, index: i, originalHex: initialHex });
          });

          // When loading a new file or resetting, ensure initialColorGroups is cleared:
          // initialColorGroups = null; // At the start of handleFileLoad or in a reset function



	animatedColorRefs = [];
          findAnimatedColors(lottieData);


	// --- Build initialAnimatedColorGroupsByHex for animated colors ---
      initialAnimatedColorGroupsByHex = {};
      if (Array.isArray(animatedColorRefs)) {
        animatedColorRefs.forEach(animProperty => {
          if (!Array.isArray(animProperty.keyframePaths) || animProperty.keyframePaths.length === 0) {
            return;
          }
          const propertyContainerPath = animProperty.path.slice(0, -2);
          const layerName = getLayerNameFromPath(lottieData, propertyContainerPath) || 'Unknown Layer';

          animProperty.keyframePaths.forEach(kfPath => {
            const rawKeyframeColorArray = getValueByPath(lottieData, kfPath);
            if (!Array.isArray(rawKeyframeColorArray) || rawKeyframeColorArray.length < 3) {
              return;
            }
            const [r_norm, g_norm, b_norm, a_norm = 1] = rawKeyframeColorArray;
            const initialHexForGrouping = rgbToHex(r_norm, g_norm, b_norm); // Hex at load time

            if (!initialAnimatedColorGroupsByHex[initialHexForGrouping]) {
              initialAnimatedColorGroupsByHex[initialHexForGrouping] = [];
            }
            const keyframeIndex = kfPath[kfPath.length - 2];
            initialAnimatedColorGroupsByHex[initialHexForGrouping].push({
              kfPath: [...kfPath],
              layerName: layerName,
              originalPropertyPath: [...animProperty.path],
              keyframeIndex: keyframeIndex,
              initialAlpha: a_norm, // Store alpha at load time
              originalHexGroup: initialHexForGrouping // The hex this instance was grouped under
            });
          });
        });
      }
      // --- End building initialAnimatedColorGroupsByHex ---




          allGradients = extractGradientStops(lottieData);
          renderAnimatedColorEditor();


          const hasSolidColors = colorRefs.length > 0;
       const hasGradients = allGradients.length > 0;
       const hasAnimatedSolidColors = animatedColorRefs.length > 0;
      const hasText = detectedTextElements.length > 0;
        ////
       const animatedGradientLabel = document.getElementById('animatedGradientLabel');
       const container = document.getElementById('animatedGradientEditor');
       const editableItemsRendered = container.querySelectorAll('.stop-row');
       ////
       const hasAnimatedGradients = editableItemsRendered.length > 0;
      anyContent = hasSolidColors || hasGradients || hasAnimatedSolidColors || hasAnimatedGradients || hasText;



          // --- Add this Empty State Logic ---
      const emptyStateDiv = document.getElementById('emptyStateDiv');
      const colorInstancesLabel = document.getElementById('colorInstancesLabel');
      const editorAreaDiv = document.getElementById('editorArea'); // Get the parent

      // Check if BOTH colors and gradients are empty
      if (!anyContent) {
        // Show Empty State
        colorEditor.style.display = 'none';
        stopEditor.style.display = 'none';
        if (colorInstancesLabel) colorInstancesLabel.style.display = 'none'; // Hide heading
        if(animatedGradientLabel) animatedGradientLabel.style.display = 'none';
        if (emptyStateDiv) emptyStateDiv.style.display = 'flex'; // Show empty state (use flex for centering)
        if (editorAreaDiv) editorAreaDiv.classList.add('is-empty'); // Add class to parent
        console.log("No colors or gradients detected. Displaying empty state.");
      } else {
        // Show Editors
        colorEditor.style.display = 'block'; // Or initial display type if different
        stopEditor.style.display = 'block'; // Or initial display type if different
        if (colorInstancesLabel) colorInstancesLabel.style.display = 'block'; // Show heading
        if (emptyStateDiv) emptyStateDiv.style.display = 'none'; // Hide empty state
        if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty'); // Remove class from parent

        // Render the editors only if there's data
        renderColorPickers();
        renderGradientEditor();
        renderAnimatedColorEditor();
        renderAnimatedGradientEditor();
        renderTextEditorUI();



        console.log(`Detected ${colorRefs.length} solid colors and ${allGradients.length} gradients.`);
      }
      // --- End Empty State Logic ---











          reloadLottiePreview();
          updateDurationPillDisplay();
            initializeElementsToManageVisibility();

            if(!anyContent){
              document.getElementById('activateColorPickerBtn').style.display = 'none';
            }



          windowTitle.textContent = file.name;
          updateDownloadButtonsState(); // This now enables Trim and Crop buttons too

          uploadWrapper.style.transform = 'translate(50%, -50%) scale(0.6)';
          uploadWrapper.style.opacity = '0';




          setTimeout(() => {
            uploadWrapper.style.display = 'none';
            mainContent.style.display = 'flex';
            requestAnimationFrame(() => {
              mainContent.style.transform = 'scale(1)';
              mainContent.style.opacity = '1';

              // --- START: Animation Code ---
                       const windowContainer = document.querySelector('.window-container'); // Get the element to animate
                       const previewArea = document.getElementById('previewArea'); // Get the reference area
                       const jsonSectionCard = document.getElementById('jsonEditorCard');
                       // Ensure elements exist before proceeding
                       if (windowContainer && previewArea) {
                         // Get dimensions and position of the preview area RELATIVE TO VIEWPORT
                         const previewRect = previewArea.getBoundingClientRect();
                         // Get dimensions and position of the window container RELATIVE TO VIEWPORT
                         const windowRect = windowContainer.getBoundingClientRect();

                         const jsonSectionRect = jsonSectionCard.getBoundingClientRect();

                         // Assume the root font size is 16px (change this if your base size differs)
 const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize); // Get actual root font size dynamically

 // Convert windowRect.height to rem
 const paddingTopInRem = (windowRect.height + 62) / rootFontSize;

 // Apply the rem value
 previewArea.style.paddingTop = `${paddingTopInRem}rem`;







                         // --- Log initial positions ---
                         console.log('Preview Area Rect:', previewRect);
                         console.log('Window Container Rect (Initial):', windowRect);
                         // ---


                         let targetLeft;
                         const deviceWidth = window.innerWidth;
                         if (deviceWidth>763.63){
                              let multiplier;
                           if(deviceWidth>1199){ multiplier = 1200/2; }
                           else{ multiplier=deviceWidth/2;}

                           targetLeft = previewRect.left + multiplier*(0.52) - 200;


                         }
                         else {targetLeft = previewRect.left;}


                         // Calculate target position (top-center of previewArea)
                         // Target Top: previewArea's top relative to viewport
                        const targetTop = 112; // Using viewport coordinates directly
                         // Target Left: previewArea's horizontal center (viewport) minus half the window's width





                          // --- Log target positions ---

                         // ---

                         // --- Apply animation styles ---

                         // Set transition *before* changing position
                         windowContainer.style.transition =
                              'transform 580ms cubic-bezier(0.1, 0.1, 0.1, 1), ' +
                              'opacity   450ms cubic-bezier(0.1, 0.1, 0.2, 1)';

                         // Calculate the required translation based on VIEWPORT coordinates
                         // TranslateX = Target Left (Viewport) - Current Left (Viewport)
                         // TranslateY = Target Top (Viewport) - Current Top (Viewport)
                         const translateX = targetLeft - windowRect.left;
                         console.log("windowRectleft:"+ windowRect.left+"targetLeft:"+targetLeft);
                         const translateY = targetTop - windowRect.top;

                         // --- Log calculated translation ---
                         console.log('Calculated TranslateX:', translateX);
                         console.log('Calculated TranslateY:', translateY);
                         // ---




                            // kick off the fade
                            windowContainer.style.opacity = '1';

                         // Apply the transform to trigger the animation
                         windowContainer.style.transform = `translate(${translateX-10}px, ${translateY}px)`;
                         translationtoX = translateX-10;
                         translationtoY = translateY;


                       } else {
                           console.warn("Could not find .window-container or #previewArea for animation.");
                       }
                        // --- END: Animation Code ---






            });
          }, 280);

        } catch (err) {
          console.error("Error processing Lottie file:", err);
          alert(`Error loading file: ${err.message}\nPlease ensure it's a valid Lottie JSON file.`);
          resetUI();
        }
      };

      reader.onerror = () => {
          console.error("Error reading file:", reader.error);
          alert("Error reading file. Please try again.");
          resetUI();
      };

      reader.readAsText(file);
    }


    function updateDurationPillDisplay() {
  const durationPill = document.getElementById('animationDurationPill');
  if (!durationPill) return;

  if (!lottieData || originalAnimationDuration === 0) {
    durationPill.style.display = 'none';
    return;
  }

  const currentDisplayDuration = originalAnimationDuration / currentSpeed;
  durationPill.textContent = currentDisplayDuration.toFixed(2) + 's';
  durationPill.style.display = 'block'; // Show the pill
}

    /**
     * Resets the UI to its initial state.
     */
    function resetUI() {

      // Ensure empty state is hidden and editors/heading are visible on reset
    const emptyStateDiv = document.getElementById('emptyStateDiv');
    const colorEditor = document.getElementById('colorEditor');
    const stopEditor = document.getElementById('stopEditor');
    const colorInstancesLabel = document.getElementById('colorInstancesLabel');
    const editorAreaDiv = document.getElementById('editorArea');

    if (emptyStateDiv) emptyStateDiv.style.display = 'none';
    if (colorEditor) colorEditor.style.display = 'block'; // Or initial display
    if (stopEditor) stopEditor.style.display = 'block'; // Or initial display
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'block';
    if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty');

    // ... your existing reset logic ...
    // --- NEW: Clear history on UI reset if not a full reload ---
    originalLottieDataForReset = null;
    undoStack = [];
    redoStack = [];
    // --- END NEW ---



      location.reload();
    }


    /**
     * Handles the JSON download button click.
     */
    function handleJsonDownload() {
      if (!lottieData) return;

      const exportData = cleanForExport(JSON.parse(JSON.stringify(lottieData)));

      if (originalFrameRate && exportData.fr) {
          exportData.fr = parseFloat((originalFrameRate * currentSpeed).toFixed(3));
      }

      const jsonString = JSON.stringify(exportData, (key, value) => {
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(3));
        }
        return value;
      });

      const blob = new Blob([jsonString], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;

      /*
      const originalFilename = windowTitle.textContent || 'animation';
      const baseFilename = originalFilename.replace(/\.json$/i, '');
      a.download = `${baseFilename}.edited.json`;
      */
      let editedName = windowTitle.textContent.trim(); // Get edited name from the span
if (!editedName) {
    editedName = 'animation'; // Use a default if the user cleared the title
}
// Ensure filename ends with .json (case-insensitive)
if (!/\.json$/i.test(editedName)) {
    editedName += '.json';
}
a.download = editedName; // Use the potentially modified edited name


      a.style.display = 'none';

      document.body.appendChild(a);
      a.click();

      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }


    /**
     * Recursively replaces keyColor with replaceColor for GIF export.
     */
    function replacePureBlack(obj) {
        const keyRGB = hexToRgb(keyColor);
        const replaceRGB = hexToRgb(replaceColor);
        const COLOR_THRESHOLD = 0.01;

        function shouldReplace(r, g, b) {
            return (
            Math.abs(r - keyRGB[0]) < COLOR_THRESHOLD &&
            Math.abs(g - keyRGB[1]) < COLOR_THRESHOLD &&
            Math.abs(b - keyRGB[2]) < COLOR_THRESHOLD
            );
        }

        function processColorArray(colorArray) {
            if (!Array.isArray(colorArray) || colorArray.length < 3) return colorArray;
            const [r, g, b, a = 1] = colorArray;
            if (shouldReplace(r, g, b)) {
                return [...replaceRGB, a];
            }
            return colorArray;
        }

        function traverse(currentObj) {
            if (Array.isArray(currentObj)) {
                currentObj.forEach((item, index) => {
                    if (Array.isArray(item) && item.length >= 3 && item.length <= 4 && item.every(n => typeof n === 'number')) {
                        currentObj[index] = processColorArray(item);
                    } else if (typeof item === 'object') {
                        traverse(item);
                    }
                });
            } else if (currentObj && typeof currentObj === 'object') {
                for (const key in currentObj) {
                    if (!currentObj.hasOwnProperty(key)) continue;
                    const value = currentObj[key];
                    if (key === 'c' && value?.k && Array.isArray(value.k)) {
                        currentObj[key].k = processColorArray(value.k);
                    } else if (key === 'g' && value?.k?.k && Array.isArray(value.k.k) && value.p) {
                        const raw = value.k.k;
                        const stops = value.p;
                        for (let i = 0; i < stops; i++) {
                            const base = i * 4;
                            const r_idx = base + 1;
                            const g_idx = base + 2;
                            const b_idx = base + 3;
                            if (shouldReplace(raw[r_idx], raw[g_idx], raw[b_idx])) {
                                raw[r_idx] = replaceRGB[0];
                                raw[g_idx] = replaceRGB[1];
                                raw[b_idx] = replaceRGB[2];
                            }
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        traverse(value);
                    }
                }
            }
        }
        traverse(obj);
    }


    /**
     * Handles the GIF download button click. Generates the GIF using gif.js.
     */
     function generateGif() {
         if (!lottieData || !window.GIF) {
             alert("GIF generation requires the Lottie data and gif.js library.");
             return;
         }

         // --- UI Feedback: Start Loading ---
         downloadGifBtn.classList.add('btn--loading');
         downloadGifBtn.disabled = true;

         // Optional: Load a Lottie animation as a loading indicator
         // let loadingAnim;
         // try {
         //     loadingAnim = lottie.loadAnimation({ /* options for loader.json */ });
         // } catch(e) { console.warn("Could not load loading animation", e); }


         // --- Prepare Data and Settings ---

         // 1. Deep-clone the master data and replace key colors if needed
         const gifData = JSON.parse(JSON.stringify(lottieData));
         replacePureBlack(gifData); // Replace black/keyColor if necessary

         // 2. Set up a temporary, hidden Lottie instance for rendering frames
         gifContainer.innerHTML = ''; // Clear previous temporary instance
         const tmpAnim = lottie.loadAnimation({
             container: gifContainer,
             renderer: 'svg',
             loop: false, // Don't loop the temporary instance
             autoplay: false, // Don't autoplay
             animationData: gifData
         });

         tmpAnim.addEventListener('DOMLoaded', () => { // Wait for SVG to be ready
             // 3. Calculate GIF dimensions and frame settings
             const scaleValue = parseFloat(gifScaleSelect.value) || 1;
             const aspectRatio = animWidth / animHeight;
             // Calculate dimensions, ensuring they are integers
             const gifW = Math.max(1, Math.round(animWidth * scaleValue));
             const gifH = Math.max(1, Math.round(gifW / aspectRatio));

             const GIF_FPS = 30; // Target FPS for GIF (lower than source is often fine)
             // Calculate delay: 1000ms / FPS. gif.js uses centiseconds (1/100th s), so multiply by 10

             const FRAME_DELAY_CS = Math.round((100 / GIF_FPS) * (1 / 0.127));

             // Calculate total frames based on duration and target FPS
             // Duration = (Out Point - In Point) / Original Frame Rate
             const animDurationSec = (lottieData.op - lottieData.ip) / originalFrameRate;
             // Total frames = Duration * Target FPS (respecting current speed)
             // Limit max frames to prevent excessive generation time/size
             const totalFrames = Math.min(Math.floor((animDurationSec / currentSpeed) * GIF_FPS), 300); // Max 300 frames

             if (totalFrames <= 0) {
                  alert("Calculated duration or frame count is zero. Cannot generate GIF.");
                  cleanupGifGen(tmpAnim);
                  return;
             }


             // 4. Get background settings from UI
             const useTransparentBg = transparentBgCheckbox.checked;
             const customBgColor = bgHexInput.value; // e.g., "#ffffff"

             // 5. Configure gif.js options
             const gifOptions = {
                 workers: Math.max(1, navigator.hardwareConcurrency ? Math.floor(navigator.hardwareConcurrency / 2) : 2), // Use half available cores, min 1, default 2
                 quality: 10, // Lower quality means smaller file, 1-30 range, 10 is default
                 width: gifW,
                 height: gifH,
                 // IMPORTANT: Path to worker script relative to the HTML file or absolute URL
                 workerScript: './gif.worker.js' // Adjust if your worker is elsewhere
             };

             // Set background or transparency based on checkbox
             if (useTransparentBg) {
        // Solid background mode
                  gifOptions.background = customBgColor;
              } else {
                  // Transparent background mode
                  gifOptions.transparent = parseInt(keyColor.replace('#', '0x'), 16);
              }

             // --- Initialize GIF Encoder ---
             let gif;
             try {
                 gif = new GIF(gifOptions);
             } catch (e) {
                 console.error("Failed to initialize GIF encoder:", e);
                 alert("Failed to initialize GIF encoder. Check console and ensure gif.js/worker are loaded correctly.");
                 cleanupGifGen(tmpAnim);
                 return;
             }


             // --- Frame Capturing Loop ---
             const svgEl = gifContainer.querySelector('svg');
             if (!svgEl) {
                 alert("Could not find SVG element for GIF generation.");
                 cleanupGifGen(tmpAnim);
                 return;
             }

             let frameIndex = 0;

             function captureFrame() {
                 if (frameIndex >= totalFrames) {
                     // --- Finalize GIF Rendering ---
                     gif.render();
                     return; // Stop capturing
                 }

                 // Calculate the time and corresponding frame number in the original Lottie timeline
                 const timeSec = (frameIndex / GIF_FPS) * currentSpeed; // Time adjusted for speed
                 const lottieFrame = lottieData.ip + timeSec * originalFrameRate;

                 // Go to the calculated frame on the *temporary* animation instance
                 tmpAnim.goToAndStop(lottieFrame, true); // true = isFrame

                 // Use requestAnimationFrame to ensure the SVG has updated visually
                 requestAnimationFrame(() => {
                     // Create a new canvas for this frame
                     const canvas = document.createElement('canvas');
                     canvas.width = gifW;
                     canvas.height = gifH;
                     const ctx = canvas.getContext('2d');

                     // Draw background color OR the transparency key color onto the canvas
                     ctx.fillStyle = useTransparentBg ? customBgColor : keyColor;
                     ctx.fillRect(0, 0, gifW, gifH);

                     // Serialize the current state of the SVG element
                     // Clone the SVG to avoid potential issues with direct manipulation
                     const svgClone = svgEl.cloneNode(true);
                     // Ensure viewBox, width, and height are set correctly for rendering
                     svgClone.setAttribute('viewBox', `0 0 ${animWidth} ${animHeight}`);
                     svgClone.setAttribute('width', gifW);
                     svgClone.setAttribute('height', gifH);
                     const svgString = new XMLSerializer().serializeToString(svgClone);

                     // Create an Image object to draw the SVG onto the canvas
                     const img = new Image();
                     const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                     const url = URL.createObjectURL(svgBlob);

                     img.onload = () => {
                         // Draw the SVG image onto the canvas (over the background/key color)
                         ctx.drawImage(img, 0, 0, gifW, gifH);
                         URL.revokeObjectURL(url); // Clean up blob URL

                         // Add the canvas frame to the GIF encoder
                         try {
                             gif.addFrame(canvas, { delay: FRAME_DELAY_CS, copy: true });
                         } catch(e) {
                             console.error(`Error adding frame ${frameIndex}:`, e);
                             // Decide whether to stop or continue on error
                         }


                         // Capture the next frame
                         frameIndex++;
                         // Use setTimeout for less aggressive looping than rAF for long tasks
                         setTimeout(captureFrame, 0);
                     };
                     img.onerror = () => {
                         console.error(`Failed to load SVG frame ${frameIndex} into image.`);
                         URL.revokeObjectURL(url);
                         // Decide how to handle frame errors (skip, stop, etc.)
                         // For now, let's try skipping to the next frame
                         frameIndex++;
                          setTimeout(captureFrame, 0);
                     };
                     img.src = url; // Load the SVG blob into the image
                 });
             } // End of captureFrame function

             // --- GIF Rendering Finished Callback ---
             gif.on('finished', (blob) => {
                 // --- UI Feedback: Stop Loading ---
                 cleanupGifGen(tmpAnim); // Includes resetting button state

                 // --- Trigger Download ---
                 const downloadUrl = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = downloadUrl;
                 const originalFilename = windowTitle.textContent || 'animation';
                 const baseFilename = originalFilename.replace(/\.json$/i, '');
                 a.download = `${baseFilename}.gif`;
                 a.style.display = 'none';
                 document.body.appendChild(a);
                 a.click();

                 // Clean up
                 setTimeout(() => {
                     document.body.removeChild(a);
                     URL.revokeObjectURL(downloadUrl);
                 }, 100);
             });

              // --- GIF Rendering Progress Callback (Optional) ---
             gif.on('progress', (p) => {
                 // Update UI with progress if desired (e.g., update a progress bar)
                  console.log(`GIF rendering progress: ${Math.round(p * 100)}%`);
                  // Example: downloadGifBtn.textContent = `Generating... ${Math.round(p * 100)}%`;
             });


             // --- Start Capturing Frames ---
             captureFrame();

         }); // End of tmpAnim DOMLoaded listener

          // Error handling for temporary animation loading
         tmpAnim.addEventListener('data_failed', () => {
             console.error("Temporary Lottie data failed to load for GIF generation.");
             alert("Failed to load animation data for GIF generation.");
             cleanupGifGen(tmpAnim);
         });
         tmpAnim.addEventListener('error', (error) => {
             console.error("Temporary Lottie animation error:", error);
              alert("An error occurred with the animation instance for GIF generation.");
             cleanupGifGen(tmpAnim);
         });


     } // End of generateGif function

     /**
      * Cleans up resources used during GIF generation and resets button state.
      * @param {object} tmpAnim The temporary Lottie animation instance.
      * @param {object} [loadingAnim] Optional loading indicator animation instance.
      */
     function cleanupGifGen(tmpAnim, loadingAnim) {
          // Destroy temporary Lottie instance
         if (tmpAnim) {
             tmpAnim.destroy();
         }
         // Clear the hidden container
         gifContainer.innerHTML = '';

         // Destroy optional loading animation
         if (loadingAnim) {
             loadingAnim.destroy();
         }

         // Reset GIF button state
         downloadGifBtn.classList.remove('btn--loading');
         downloadGifBtn.disabled = false;
         // Restore icon if it was removed
         // downloadGifBtn.style.backgroundImage = "url(...)"; // Or manage via CSS
     }




    /**
     * Opens the advanced GIF render settings overlay.
     */
    function openSettings() {
        document.getElementById('keyColor').value = keyColor;
        document.getElementById('keyHex').value = keyColor;
        document.getElementById('replaceColor').value = replaceColor;
        document.getElementById('replaceHex').value = replaceColor;
        renderSettingsOverlay.classList.add('active');
    }

    /**
     * Saves settings from the overlay and closes it.
     */
    function closeSettings() {
        keyColor = document.getElementById('keyColor').value;
        replaceColor = document.getElementById('replaceColor').value;
        renderSettingsOverlay.classList.remove('active');
    }

    /**
     * Initializes the sync between color pickers and hex inputs in the settings overlay.
     */
    function initSettingsSync() {
        function setupSync(colorId, hexId) {
            const colorInput = document.getElementById(colorId);
            const hexInput = document.getElementById(hexId);
            if (!colorInput || !hexInput) return;

            colorInput.addEventListener('input', () => {
                hexInput.value = colorInput.value;
            });

            hexInput.addEventListener('change', () => {
                let newHex = hexInput.value.trim();
                 if (!newHex.startsWith("#")) newHex = "#" + newHex;
                 if (/^#[0-9A-F]{6}$/i.test(newHex)) {
                    colorInput.value = newHex;
                 } else {
                     hexInput.value = colorInput.value;
                 }
            });
        }
        setupSync('keyColor', 'keyHex');
        setupSync('replaceColor', 'replaceHex');
    }


    // --- Event Listeners ---






    activateColorPickerBtn.addEventListener('click', async () => {
        if (!animationInstance) {
            alert("Please load a Lottie animation first.");
            return;
        }

        if (isColorPickerActive) { // If trying to cancel picker
            console.log("Color picking cancelled by button re-click.");
            isColorPickerActive = false;
            activateColorPickerBtn.style.opacity = '1'; // Or revert to original icon
            if (previewBgToggleContainer) previewBgToggleContainer.style.display = 'flex'; // Show GIF BG toggle
            // Optionally resume animation if it was paused by picker activation
            // if (!isPlaying && previouslyPlayingBeforePicker) animationInstance.play();
            return;
        }

        isColorPickerActive = true;
        activateColorPickerBtn.style.opacity = '0.5'; // Indicate active state or change icon

        if (isPlaying) {
            playPauseBtn.click();
            // Note: We are not changing the global 'isPlaying' state here,
            // just temporarily pausing for picking.
            // Or, if you want it to reflect as a full pause:
            // playPauseBtn.click(); // Simulate a click if it correctly handles state and UI
        }

        if (previewBgToggleContainer) previewBgToggleContainer.style.display = 'none'; // Hide GIF BG toggle
        if (durationpill) durationpill.style.display = 'none';

        if (window.EyeDropper) {
              const eyeDropper = new EyeDropper();
              try {
                  const result = await eyeDropper.open();
                  isColorPickerActive = false; // Reset flag
                  activateColorPickerBtn.style.display = 'none'; // Hide picker button
                  // GIF toggle remains hidden until pill is dismissed

                  isUserInitiatedFilter = true; // <<< SET THIS FLAG
                  handleColorPickedForFiltering(result.sRGBHex.toLowerCase());

              } catch (e) {
                  console.log("EyeDropper cancelled or failed:", e);
                  isColorPickerActive = false;
                  isUserInitiatedFilter = false; // <<< RESET FLAG ON FAILURE/CANCEL
                  activateColorPickerBtn.style.opacity = '1';
                  if (previewBgToggleContainer) previewBgToggleContainer.style.display = 'flex';
                  // If animation was paused by this action, consider resuming it or leaving as is.
              }
          } else {
              alert("Your browser does not support the EyeDropper API. This color picking feature is unavailable.");
              isColorPickerActive = false;
              isUserInitiatedFilter = false; // <<< RESET FLAG
              activateColorPickerBtn.style.opacity = '1';
              if (previewBgToggleContainer) previewBgToggleContainer.style.display = 'flex';
          }
    });

    playPauseBtn.addEventListener('click', () => {
             if (!animationInstance) return; // animationInstance is the Lottie animation object
             if (isPlaying) {
                 // If currently playing, the intention is to pause
                 animationInstance.pause();
                 playPauseBtn.innerHTML = PLAY_ICON_SVG;
                 playPauseBtn.setAttribute('aria-label', 'Play');
             } else {
                 // If currently paused, the intention is to play
                 animationInstance.play();
                 playPauseBtn.innerHTML = PAUSE_ICON_SVG;
                 playPauseBtn.setAttribute('aria-label', 'Pause');
             }
             isPlaying = !isPlaying; // Toggle the state
         });

         lottieSeekbar.addEventListener('input', () => {
       if (!animationInstance) return;
       const frame = parseInt(lottieSeekbar.value, 10);
       animationInstance.goToAndStop(frame, true); // This stops the animation at the selected frame

       // If the animation was playing before seekbar interaction
       if (isPlaying) {
           isPlaying = false; // Update the state to paused
           playPauseBtn.innerHTML = PLAY_ICON_SVG; // Change button to show "Play" icon
           playPauseBtn.setAttribute('aria-label', 'Play');
           // animationInstance.pause(); // goToAndStop already pauses it, but explicit pause can be added if needed for clarity or specific Lottie behaviors.
       }
   });

        speedControlPillBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent click from bubbling to document
            speedSliderPopup.classList.toggle('active');
            speedControlPillBtn.setAttribute('aria-expanded', speedSliderPopup.classList.contains('active'));
            if (speedSliderPopup.classList.contains('active')) {
                resetSpeedPopupTimer();
            } else {
                clearTimeout(speedPopupTimer);
            }
        });

        dismissSpeedPopupBtn.addEventListener('click', () => {
            speedSliderPopup.classList.remove('active');
            speedControlPillBtn.setAttribute('aria-expanded', 'false');
            clearTimeout(speedPopupTimer);
        });

        speedSliderMain.addEventListener('input', (e) => {
          currentSpeed = parseFloat(e.target.value);
          speedValuePill.textContent = currentSpeed.toFixed(1) + "x";
          if (animationInstance) {
            animationInstance.setSpeed(currentSpeed);
          }
           updateDurationPillDisplay();
          resetSpeedPopupTimer(); // Reset timer on interaction
        });
        speedSliderMain.addEventListener('mousedown', () => clearTimeout(speedPopupTimer)); // Clear timer when user starts dragging
        speedSliderMain.addEventListener('touchstart', () => clearTimeout(speedPopupTimer));


        // Auto-dismiss speed popup
        function resetSpeedPopupTimer() {
            clearTimeout(speedPopupTimer);
            speedPopupTimer = setTimeout(() => {
                speedSliderPopup.classList.remove('active');
                speedControlPillBtn.setAttribute('aria-expanded', 'false');
            }, 5000); // 5 seconds
        }

        // Close speed popup if clicked outside
        document.addEventListener('click', (event) => {
            if (speedSliderPopup.classList.contains('active') &&
                !speedSliderPopup.contains(event.target) &&
                !speedControlPillBtn.contains(event.target)) {
                speedSliderPopup.classList.remove('active');
                speedControlPillBtn.setAttribute('aria-expanded', 'false');
                clearTimeout(speedPopupTimer);
            }
        });






    // File Input
    fileInput.addEventListener('change', handleFileLoad);

    // Window Close Button (Reset UI)
    windowCloseBtn.addEventListener('click', resetUI);



    // Download Buttons
    downloadJsonBtn.addEventListener('click', handleJsonDownload);
    downloadGifBtn.addEventListener('click', generateGif);

    // GIF Background Toggle and Color Picker Sync
    transparentBgCheckbox.addEventListener('change', () => {
        bgColorGroup.classList.toggle('hidden', !transparentBgCheckbox.checked);
    });
    bgColorPicker.addEventListener('input', () => {
      bgHexInput.value = bgColorPicker.value;
    });
    bgHexInput.addEventListener('change', () => {
      let newHex = bgHexInput.value.trim();
      if (!newHex.startsWith("#")) newHex = "#" + newHex;
      if (/^#[0-9A-F]{6}$/i.test(newHex)) {
        bgColorPicker.value = newHex;
      } else {
        alert('Invalid hex code. Use format #RRGGBB.');
        bgHexInput.value = bgColorPicker.value;
      }
    });

    // Open Settings Overlay (Ctrl+Click on label)
    gifExportLabel.addEventListener('click', (e) => {
      if (e.ctrlKey || e.metaKey) {
        openSettings();
      }
    });

    // Open Trim Editor Overlay Button
    openOverlayBtn.addEventListener('click', () => {
        if (!lottieData) return;

        if (overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
        }

        customOverlay.classList.add('active');
        customOverlayIframe.src = 'overlay.html'; // Load Trim editor
        console.log(windowTitle.textContent);
        customOverlayIframe.onload = () => {
            try {

                const overlayData = JSON.parse(JSON.stringify(lottieData));
                if (originalFrameRate && overlayData.fr) {
                    overlayData.fr = originalFrameRate * currentSpeed;
                }
                customOverlayIframe.contentWindow.postMessage({
                    type: 'lottieData',
                    data: overlayData,
                    filename: windowTitle.textContent,
                }, '*'); // Use specific origin in production
            } catch (error) {
                console.error("Error preparing or sending data to trim overlay:", error);
                alert("Could not load data into the trim editor overlay.");
                customOverlay.classList.remove('active');
            }
        };
         customOverlayIframe.onerror = () => {
             console.error("Failed to load trim overlay iframe:", customOverlayIframe.src);
             alert("Failed to load the trim editor overlay (overlay.html).");
             customOverlay.classList.remove('active');
         };
    });




// --- Add to Event Listeners ---
openAssetReplacerBtn.addEventListener('click', () => {
    if (!lottieData) return;

    // Optional: Destroy any existing overlay instance if you have one
    // if (overlayAnimationInstance) {
    //     overlayAnimationInstance.destroy();
    //     overlayAnimationInstance = null;
    // }

    customOverlay.classList.add('active');
    customOverlayIframe.src = 'asset_replacer.html'; // Path to your asset replacer tool

    customOverlayIframe.onload = () => {
        try {
            const overlayData = JSON.parse(JSON.stringify(lottieData));
            // Adjust frame rate for overlay if needed, similar to other overlays
            if (originalFrameRate && overlayData.fr) {
                overlayData.fr = originalFrameRate * currentSpeed; // Or just originalFrameRate
            }
            customOverlayIframe.contentWindow.postMessage({
                type: 'lottieDataAssetTool', // Ensure this matches the type in asset_replacer.html
                lottieData: overlayData,
                filename: windowTitle.textContent
            }, '*'); // In production, specify the iframe's origin
        } catch (error) {
            console.error("Error preparing or sending data to asset replacer overlay:", error);
            alert("Could not load data into the asset replacer overlay.");
            customOverlay.classList.remove('active');
        }
    };
    customOverlayIframe.onerror = () => {
         console.error("Failed to load asset replacer overlay iframe:", customOverlayIframe.src);
         alert("Failed to load the asset replacer overlay (asset_replacer.html).");
         customOverlay.classList.remove('active');
     };
});



    // *** NEW: Open Crop Editor Overlay Button ***
    openCropBtn.addEventListener('click', () => {
        if (!lottieData) return;

        if (overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
        }

        customOverlay.classList.add('active');
        customOverlayIframe.src = 'crop.html'; // Load Crop editor

        customOverlayIframe.onload = () => {
            try {
                const overlayData = JSON.parse(JSON.stringify(lottieData));
                if (originalFrameRate && overlayData.fr) {
                    overlayData.fr = originalFrameRate * currentSpeed;
                }
                customOverlayIframe.contentWindow.postMessage({
                    type: 'lottieData',
                    data: overlayData,
                    filename: windowTitle.textContent
                }, '*'); // Use specific origin in production
            } catch (error) {
                console.error("Error preparing or sending data to crop overlay:", error);
                alert("Could not load data into the crop editor overlay.");
                customOverlay.classList.remove('active');
            }
        };
         customOverlayIframe.onerror = () => {
             console.error("Failed to load crop overlay iframe:", customOverlayIframe.src);
             alert("Failed to load the crop editor overlay (crop.html).");
             customOverlay.classList.remove('active');
         };
    });
    // *** END NEW LISTENER ***

    // Close Overlay Buttons (Generic Handler)
    overlayCloseButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const overlay = e.target.closest('.overlay');
        if (overlay) {
          overlay.classList.remove('active');
          // If closing the custom editor overlay, destroy its Lottie instance
          if (overlay.id === 'customOverlay' && overlayAnimationInstance) {
            overlayAnimationInstance.destroy();
            overlayAnimationInstance = null;
          }
          // Clear iframe src when closing to stop potential background processes
          if (overlay.id === 'customOverlay') {
              customOverlayIframe.src = 'about:blank';
          }
        }
      });
    });








// Debounce function to prevent rapid updates
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
}







resetFilterBtn.addEventListener('click', () => {
    filterInfoPill.style.display = 'none';
    const previouslyActiveColor = activePickedColor;
    activePickedColor = null;
    initialFilteredAccordionIds.clear(); // <<< CLEAR THE SET
    isUserInitiatedFilter = false;      // <<< RESET FLAG

    activateColorPickerBtn.style.display = 'inline-block';
    activateColorPickerBtn.style.opacity = 1;
    if (previewBgToggleContainer) previewBgToggleContainer.style.display = 'flex';

    if (!previouslyActiveColor) {
        console.log("No active filter to reset.");
        return;
    }

    console.log("Filter reset. Restoring default UI structure.");

    // Remove filter-specific classes from all accordions and show their content rows
    document.querySelectorAll('#editorArea .accordion, #editorArea .gradient-accordion').forEach(accordion => {
        accordion.classList.remove('hidden-by-filter', 'accordion-filtered-nomatch');
        const body = accordion.querySelector('.accordion-body, .gradient-content');
        if (body) {
            // Iterate over direct children that are rows
            for (const row of body.children) {
                 if (row.classList.contains('color-row') || row.classList.contains('stop-row') || row.classList.contains('text-instance-row')) {
                    row.style.display = ''; // Revert to default display (flex or block based on CSS)
                    row.classList.remove('row-filtered-nomatch'); // If you used this class
                }
            }
        }
    });

    const emptyStateDiv = document.getElementById('emptyStateDiv');
    if (emptyStateDiv) {
        // Hide empty state as we are restoring all items
        emptyStateDiv.style.display = 'none';

    }

    // Call refreshUIStateAndRender to fully rebuild UI in its unfiltered state.
    // It will handle empty states and label visibility correctly.
    // Since activePickedColor is null, no filter will be applied.
    refreshUIStateAndRender();
});




//all functions begin
// Replace the ENTIRE existing handleColorPickedForFiltering function with this:
// Replace the ENTIRE existing handleColorPickedForFiltering function with this:
function handleColorPickedForFiltering(pickedHexByEyeDropper) {
    const pickedHexClean = pickedHexByEyeDropper.toLowerCase();
    if (isUserInitiatedFilter) {
        activePickedColor = pickedHexClean;
    }
    const currentFilterColor = activePickedColor;
    const pickedRgb = hexToRgbComponents(currentFilterColor);

    console.log(`Filtering for: ${currentFilterColor}. User initiated: ${isUserInitiatedFilter}`);

    const filterPillSwatch = document.getElementById('filterPillColorSwatch');
    const filterPillHexDisplay = document.getElementById('filterPillHexDisplay');
    if (filterInfoPill && filterPillSwatch && filterPillHexDisplay) {
        filterInfoPill.style.display = 'flex';
        filterPillSwatch.style.backgroundColor = currentFilterColor;
        filterPillHexDisplay.textContent = currentFilterColor.toUpperCase();
    }

    if (isUserInitiatedFilter) {
        initialFilteredAccordionIds.clear();
    }
    let totalVisibleAccordionsAcrossAllSections = 0; // Keep track of visible items


    function processSection(containerElement, accordionSelector, getColorFromAccordionFn, isMultiStopType = false) {
        if (!containerElement) return 0;

        const allAccordionsInDOM = Array.from(containerElement.querySelectorAll(accordionSelector));
        let visibleAccordionCountInSection = 0;
        const accordionsToSort = [];

        allAccordionsInDOM.forEach(accordion => {
            const accordionId = accordion.dataset.id;
            if (!accordionId) {
                console.warn("Accordion missing dataset.id in container:", containerElement.id, accordion);
                return;
            }

            let currentDistance = Infinity;
            let matchesNow = false;
            const body = accordion.querySelector('.accordion-body, .gradient-content');
            let hasMatchingStopInternally = false; // Specifically for multi-stop types

            if (isMultiStopType) {
                let minStopDistance = Infinity;
                if (body) {
                    const rows = body.querySelectorAll('.stop-row, .text-instance-row');
                    rows.forEach(row => {
                        const colorInput = row.querySelector('input[type="color"]');
                        if (colorInput) {
                            const stopHex = colorInput.value.toLowerCase();
                            const stopRgb = hexToRgbComponents(stopHex);
                            const dist = colorDistance(pickedRgb, stopRgb);
                            if (dist <= COLOR_DISTANCE_TOLERANCE) {
                                hasMatchingStopInternally = true;
                                minStopDistance = Math.min(minStopDistance, dist);
                            }
                        }
                    });
                }
                if (hasMatchingStopInternally) {
                    matchesNow = true;
                    currentDistance = minStopDistance;
                }
            } else { // Solid Colors, Animated Solid Colors
                const accordionColorHex = getColorFromAccordionFn(accordion);
                if (accordionColorHex) {
                    const accordionRgb = hexToRgbComponents(accordionColorHex);
                    currentDistance = colorDistance(pickedRgb, accordionRgb);
                    if (currentDistance <= COLOR_DISTANCE_TOLERANCE) {
                        matchesNow = true;
                    }
                }
            }

            if (isUserInitiatedFilter && matchesNow) {
                initialFilteredAccordionIds.add(accordionId);
            }

            let sortKey;
            if (matchesNow) { // sortKey = 0
                sortKey = 0;
                accordion.classList.remove('hidden-by-filter', 'accordion-filtered-nomatch');
                if (body) {
                    const rows = body.querySelectorAll('.color-row, .stop-row, .text-instance-row');
                    rows.forEach(row => {
                        row.style.display = ''; // Show all rows within a matching accordion
                        // Optionally, still style individual rows if they don't match the filter color
                        let rowIndividuallyMatches = false;
                        const colorInput = row.querySelector('input[type="color"]');
                        if (colorInput) {
                            const rowHex = colorInput.value.toLowerCase();
                            if (colorDistance(pickedRgb, hexToRgbComponents(rowHex)) <= COLOR_DISTANCE_TOLERANCE) {
                                rowIndividuallyMatches = true;
                            }
                        }
                        row.classList.toggle('row-filtered-nomatch', !rowIndividuallyMatches);
                    });
                }
                visibleAccordionCountInSection++;
            } else if (initialFilteredAccordionIds.has(accordionId)) { // sortKey = 1
                sortKey = 1;
                currentDistance = Infinity;
                accordion.classList.remove('hidden-by-filter');
                accordion.classList.add('accordion-filtered-nomatch');
                if (body) { // Show ALL rows as per main requirement for this state
                    const rows = body.querySelectorAll('.color-row, .stop-row, .text-instance-row');
                    rows.forEach(row => {
                        row.style.display = '';
                        let rowIndividuallyMatches = false; // Check even for these rows
                        const colorInput = row.querySelector('input[type="color"]');
                        if (colorInput) {
                            const rowHex = colorInput.value.toLowerCase();
                            if (colorDistance(pickedRgb, hexToRgbComponents(rowHex)) <= COLOR_DISTANCE_TOLERANCE) {
                                rowIndividuallyMatches = true;
                            }
                        }
                        row.classList.toggle('row-filtered-nomatch', !rowIndividuallyMatches);
                    });
                }
                visibleAccordionCountInSection++;
            } else { // sortKey = 2
                sortKey = 2;
                currentDistance = Infinity;
                accordion.classList.add('hidden-by-filter');
                accordion.classList.remove('accordion-filtered-nomatch');
            }
            accordionsToSort.push({ element: accordion, sortKey, distance: currentDistance });
        });

        accordionsToSort.sort((a, b) => {
            if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey;
            return a.distance - b.distance;
        });

        const fragment = document.createDocumentFragment();
        accordionsToSort.forEach(item => fragment.appendChild(item.element));
        containerElement.innerHTML = '';
        containerElement.appendChild(fragment);

        return visibleAccordionCountInSection;
    }

    // --- Process Sections ---
    const solidColorsVisibleCount = processSection(
        document.getElementById('colorEditor'),
        '.accordion',
        (acc) => acc.querySelector('.accordion-header-controls input[type="text"]')?.value.toLowerCase()
    );
     totalVisibleAccordionsAcrossAllSections += solidColorsVisibleCount;
    document.getElementById('colorInstancesLabel').style.display = solidColorsVisibleCount > 0 ? 'block' : 'none';

    const animatedSolidColorsVisibleCount = processSection(
        document.getElementById('animatedColorEditor'),
        '.gradient-accordion',
        (acc) => acc.querySelector('.accordion-header-controls input[type="text"]')?.value.toLowerCase()
    );
     totalVisibleAccordionsAcrossAllSections += animatedSolidColorsVisibleCount;
    document.getElementById('animatedColorLabel').style.display = animatedSolidColorsVisibleCount > 0 ? 'block' : 'none';

    const gradientsVisibleCount = processSection(
        document.getElementById('stopEditor'),
        '.gradient-accordion',
        null,
        true
    );
     totalVisibleAccordionsAcrossAllSections += gradientsVisibleCount;
    document.getElementById('gradientInstancesLabel').style.display = gradientsVisibleCount > 0 ? 'block' : 'none';

    const animatedGradientsVisibleCount = processSection(
        document.getElementById('animatedGradientEditor'),
        '.gradient-accordion',
        null,
        true
    );
     totalVisibleAccordionsAcrossAllSections += animatedGradientsVisibleCount;
    document.getElementById('animatedGradientLabel').style.display = animatedGradientsVisibleCount > 0 ? 'block' : 'none';

    const textMainAccordion = document.getElementById('detected-text-main-accordion');
    let textSectionOverallVisible = false;
    if (textMainAccordion) {
        const dummyTextContainer = document.createElement('div');
        const clonedTextAccordion = textMainAccordion.cloneNode(true);
        dummyTextContainer.appendChild(clonedTextAccordion);

        processSection( // This will apply the new row visibility logic to the clone
            dummyTextContainer,
            '.gradient-accordion',
            null,
            true
        );

        // Reflect changes from the processed clone back to the original textMainAccordion in the DOM
        textMainAccordion.className = clonedTextAccordion.className; // Sync classes like hidden-by-filter, accordion-filtered-nomatch

        const originalRows = textMainAccordion.querySelectorAll('.text-instance-row');
        const clonedRows = clonedTextAccordion.querySelectorAll('.text-instance-row');
        originalRows.forEach((origRow, index) => {
            if (clonedRows[index]) {
                origRow.style.display = clonedRows[index].style.display; // Sync display style (most important)
                origRow.className = clonedRows[index].className; // Sync classes like 'row-filtered-nomatch'
            }
        });
        textSectionOverallVisible = !textMainAccordion.classList.contains('hidden-by-filter');
        if (textSectionOverallVisible) {
             totalVisibleAccordionsAcrossAllSections++; // Count the main text accordion if it's visible
        }

    }
    document.getElementById('textEditorLabel').style.display = textSectionOverallVisible ? 'block' : 'none';

    // --- Handle Empty State for No Filter Results ---
const emptyStateDiv = document.getElementById('emptyStateDiv');


if (totalVisibleAccordionsAcrossAllSections === 0) {
    // If no accordions are visible in any section after filtering
    if (emptyStateDiv) {
        emptyStateDiv.style.display = 'flex'; // Show empty state
        // Optionally change the image/text for "no results"

    }

}
// --- End Empty State Handling ---

   durationpill.style.display = 'flex';
    previewBgToggleContainer.style.display = 'flex';
    if (isUserInitiatedFilter) {
        isUserInitiatedFilter = false;
    }
}

    function updatePreviewBackground() {
      const previewBgToggle = document.getElementById('previewBgToggle'); // Ref for the new toggle
const windowBody = document.getElementById('lottiePreview');         // Ref for the preview area body

  if (!previewBgToggle || !windowBody || !bgColorPicker) return;

  if (previewBgToggle.checked) {
    // Solid Background Mode
    // Explicitly remove just in case
    windowBody.style.background = bgColorPicker.value;
  } else {
    // Checkerboard Mode


    windowBody.style.background = 'none'; // Remove inline style to let CSS handle it
  }
}


    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {

      //START COFFEE

      const lottieTriggerElement = document.getElementById('headerLottie');
  const coffeeRoastOverlayElement = document.getElementById('coffeeRoastOverlay');
  const freshBrewFrameElement = document.getElementById('freshBrewFrame');
  const closeEspressoShotBtnElement = document.getElementById('closeEspressoShotBtn');

  const coffeeOrderPageUrl = 'buycoffee.html'; // Your HTML file

  if (lottieTriggerElement) {
    lottieTriggerElement.addEventListener('click', function() {
      freshBrewFrameElement.src = coffeeOrderPageUrl;
      coffeeRoastOverlayElement.classList.remove('coffeeRoast-hidden');
      coffeeRoastOverlayElement.classList.add('coffeeRoast-visible');
      document.body.style.overflow = 'hidden'; // Optional: Disable body scroll
    });
  } else {
    console.error("Lottie trigger element (e.g., #headerLottie) not found.");
  }

  if (closeEspressoShotBtnElement) {
    closeEspressoShotBtnElement.addEventListener('click', function() {
      closeTheCafe();
    });
  }

  if (coffeeRoastOverlayElement) {
    coffeeRoastOverlayElement.addEventListener('click', function(event) {
      if (event.target === coffeeRoastOverlayElement) {
        closeTheCafe();
      }
    });
  }

  function closeTheCafe() {
    coffeeRoastOverlayElement.classList.remove('coffeeRoast-visible');
    coffeeRoastOverlayElement.classList.add('coffeeRoast-hidden');
    freshBrewFrameElement.src = ''; // Clear iframe to stop content
    document.body.style.overflow = 'auto'; // Optional: Re-enable body scroll
  }






// END COFFEE


        updateDownloadButtonsState(); // Set initial button states (disabled)
        initSettingsSync(); // Setup sync for overlay color/hex inputs
        bgColorGroup.classList.toggle('hidden', !transparentBgCheckbox.checked);


        // Ensure empty state is hidden on initial load
 const emptyStateDiv = document.getElementById('emptyStateDiv');
 if (emptyStateDiv) {
     emptyStateDiv.style.display = 'none';
 }



        const previewBgToggle = document.getElementById('previewBgToggle'); // Ref for the new toggle
 const windowBody = document.getElementById('lottiePreview');         // Ref for the preview area body


 if (previewBgToggle && windowBody && bgColorPicker) {
     previewBgToggle.addEventListener('change', () => {
       updatePreviewBackground();
     });
   } else {
     console.warn("Could not find elements needed for preview background toggle.");
   }

   // Also update preview background if the GIF color picker changes AND solid mode is active
   if (bgColorPicker && windowBody && previewBgToggle) {
     bgColorPicker.addEventListener('input', () => {
       if (previewBgToggle.checked) { // Only update if toggle is ON
         windowBody.style.backgroundColor = bgColorPicker.value;
       }
     });
     // Sync from hex input too
      bgHexInput.addEventListener('change', () => {
       if (previewBgToggle.checked) { // Only update if toggle is ON
         windowBody.style.backgroundColor = bgColorPicker.value; // bgColorPicker is already synced
       }
     });
   }




        // >>> START: Add this block <<<
const initialPositionRef = document.querySelector('.drag-drop-overlay');
const containerToPosition = document.querySelector('.window-container');

if (initialPositionRef && containerToPosition) {
    const refRect = initialPositionRef.getBoundingClientRect();
    // Set initial position based on the drag-drop overlay's viewport position
    // Add scroll offsets in case the page is already scrolled on load

    containerToPosition.style.top = `${refRect.top + window.scrollY}px`;
    containerToPosition.style.left = `${refRect.left + window.scrollX}px`;
    containerToPosition.style.visibility = 'visible'; // Make it visible now that it's positioned
    console.log('Initial window-container position set to:', containerToPosition.style.top, containerToPosition.style.left);
} else {
    console.warn('Could not find .drag-drop-overlay or .window-container for initial positioning.');
    if (containerToPosition) containerToPosition.style.visibility = 'visible'; // Make visible anyway if found
}
// >>> END: Add this block <<<


        if (windowTitle && windowTitle.contentEditable === 'true') {

    // On FOCUS (clicking into the title)
    windowTitle.addEventListener('focus', () => {
        const currentText = windowTitle.textContent.trim();
        // If it ends with .json, remove it for editing
        if (/\.json$/i.test(currentText)) {
            windowTitle.textContent = currentText.replace(/\.json$/i, '');
        }
    });

    // On BLUR (clicking out of the title)
    windowTitle.addEventListener('blur', () => {
        let currentText = windowTitle.textContent.trim();

        // Handle if the user deleted all text
        if (!currentText) {
            currentText = 'animation'; // Default base name
            console.warn("Filename was empty on blur, resetting to 'animation.json'");
        }

        // Append .json if it's missing (case-insensitive)
        if (!/\.json$/i.test(currentText)) {
            windowTitle.textContent = currentText + '.json';
        } else {
            // If it already ends with .json, just make sure the trimmed value is set back
            windowTitle.textContent = currentText;
        }
    });

    // Optional: Prevent line breaks if user presses Enter
    windowTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault(); // Prevent new line
            windowTitle.blur();   // Trigger blur to apply formatting and save
        }
    });




}
let resizeTimer;
window.addEventListener('resize', () => {
clearTimeout(resizeTimer);
resizeTimer = setTimeout(() => {
repositionWindowContainerX();
}, 150); // adjust debounce delay if you like
});


document.addEventListener('keydown', (event) => {
const isCtrlOrCmd = event.ctrlKey || event.metaKey;

if (isCtrlOrCmd && (event.key === 'z' || event.key === 'Z')) {
  event.preventDefault(); // Prevent browser's default undo (e.g., in text fields)
  performUndo();
} else if (isCtrlOrCmd && (event.key === 'y' || event.key === 'Y')) {
  event.preventDefault(); // Prevent browser's default redo
  performRedo();
}
});



});

function repositionWindowContainerX() {



  const container = document.querySelector('.window-container');
    const previewArea = document.getElementById('previewArea');
  const card      = document.getElementById('jsonEditorCard');

  if (!container || !card) return;

  // 1. Get the bounding boxes
  const cardRect = card.getBoundingClientRect();
  const winRect  = container.getBoundingClientRect();
  const previewRect = previewArea.getBoundingClientRect();

  // 2. Compute the X coordinate so that container’s center
  //    aligns with card’s center


  let targetLeft;
  const deviceWidth = window.innerWidth;
  if (deviceWidth>763.63){
       let multiplier;
    if(deviceWidth>1199){ multiplier = 1200/2; }
    else{ multiplier=deviceWidth/2;}

    targetLeft = previewRect.left + multiplier*(0.52) - 200;


  }
  else {targetLeft = previewRect.left;}


   console.log("windowRectAfter:"+winRect.left);

   const translateX = targetLeft - winRect.left+translationtoX;
  // 3. Apply it directly (absolute positioning assumed in your CSS)
  /*container.style.left = `${targetLeft}px`;*/
  container.style.transform = `translate(${translateX}px, ${translationtoY}px)`;

  translationtoX = translateX;





}


window.addEventListener('load', () => {
const overlay   = document.querySelector('.drag-drop-overlay');
const container = document.querySelector('.window-container');
if (!overlay || !container) return;

const { top, left } = overlay.getBoundingClientRect();
container.style.top        = `${top  + window.scrollY}px`;
container.style.left       = `${left + window.scrollX}px`;
container.style.visibility = 'visible';
});

function recordChange(changeDetails) {
  if (!lottieData) return; // Don't record if no data loaded

  undoStack.push(changeDetails);

  // If undo stack exceeds max steps, remove the oldest one
  if (undoStack.length > MAX_UNDO_STEPS) {
    undoStack.shift(); // Removes the first (oldest) element
  }

  // A new change clears the redo stack (handles branching)
  redoStack = [];

  // Optional: Update UI to enable/disable undo/redo buttons if you add them
  // updateUndoRedoButtonStates();
  console.log('Change recorded. Undo stack size:', undoStack.length);
}




/*function getValueByPathTxt(obj, path) {
      if (!obj || !Array.isArray(path) || path.length === 0) {
          console.warn("getValueByPath: Invalid obj or path.", { obj, path });
          return undefined;
      }
      let current = obj;
      // If path[0] is 'lottieData' (a convention for paths from root),
      // start traversing from path[1]. Otherwise, use the whole path.
      const pathSegments = (path[0] === 'lottieData' && path.length > 1) ? path.slice(1) : path;

      for (let i = 0; i < pathSegments.length; i++) {
          const key = pathSegments[i];
          if (current && typeof current === 'object' && Object.prototype.hasOwnProperty.call(current, key)) {
              current = current[key];
          } else if (Array.isArray(current) && typeof key === 'number' && key >= 0 && key < current.length) {
              current = current[key];
          }
          else {
              console.warn(`getValueByPath: Invalid segment in path. Original: [${path.join(', ')}], Segment Key: '${key}' at index ${i} of effective path [${pathSegments.join(', ')}]. Current object before failing:`, current);
              return undefined;
          }
      }
      return current;
  }*/

  /**
   * Sets a value in an object using a path array.
   * Handles paths that might start with 'lottieData' if obj is the root.
   */
  function setValueByPathTxt(obj, path, newValue) {
      if (!obj || !Array.isArray(path) || path.length === 0) {
          console.warn("setValueByPath: Invalid obj or path.", { obj, path });
          return;
      }

      const pathSegments = (path[0] === 'lottieData' && path.length > 1) ? path.slice(1) : path;

      if (pathSegments.length === 0) {
           console.warn("setValueByPath: effective pathSegments is empty, cannot set value.", { originalPath: path });
           return;
      }

      let current = obj;
      for (let i = 0; i < pathSegments.length - 1; i++) {
          const key = pathSegments[i];
          // Check if current is an object or array and if the key/index is valid
          if (current && typeof current === 'object' && Object.prototype.hasOwnProperty.call(current, key)) {
              current = current[key];
          } else if (Array.isArray(current) && typeof key === 'number' && key >= 0 && key < current.length) {
               current = current[key];
          }
          else {
              console.warn(`setValueByPath: Cannot find valid object at segment. Original: [${path.join(', ')}], Segment Key: '${key}' at index ${i} of effective path [${pathSegments.join(', ')}]. Current object before failing:`, current);
              return;
          }
      }

      const lastKey = pathSegments[pathSegments.length - 1];
      if (current && typeof current === 'object') {
          if (Array.isArray(current) && typeof lastKey !== 'number') {
              console.warn(`setValueByPath: Trying to use non-numeric key '${lastKey}' on an array.`, { originalPath: path, parentObject: current });
              return;
          }
          current[lastKey] = newValue;
      } else {
          console.warn(`setValueByPath: Final target object (parent) is not valid or not an object. Original: [${path.join(', ')}], Last Key: '${lastKey}'. Parent object:`, current);
      }
  }







function performUndo() {
  if (undoStack.length === 0) {
    if (originalLottieDataForReset) {
      console.log("Undo stack empty, attempting to revert to original file state.");
      // To allow "redoing" the reset, we need to capture the current state vs original
      // This is complex for delta, so for now, reset won't be "redoable" in the same way.
      // A simpler "reset" would just load originalLottieDataForReset.
      // If you want reset to be part of the undo/redo chain, it needs its own delta type.

      // For now, a simple reset:
      lottieData = JSON.parse(JSON.stringify(originalLottieDataForReset));
      undoStack = []; // Clear undo stack after a full reset


      console.log("Reverted to original file state.");
    } else {
      console.log("Undo stack empty and no original data for reset.");
      return;
    }
  } else {
    const changeDetails = undoStack.pop();
    redoStack.push(changeDetails); // Push the change itself to redo

    console.log('Performing undo for:', changeDetails.type);

    if (changeDetails.type === 'SOLID_COLOR') {
      setValueByPath(lottieData, changeDetails.path, [...changeDetails.oldValue]); // Use a copy
    } else if (changeDetails.type === 'GRADIENT_STOP') {
      const gradStops = allGradients[changeDetails.gradientIndex];
      if (gradStops && gradStops[changeDetails.stopIndex]) {
        const stopToUpdate = gradStops[changeDetails.stopIndex];
        stopToUpdate.r = changeDetails.oldStopData.r;
        stopToUpdate.g = changeDetails.oldStopData.g;
        stopToUpdate.b = changeDetails.oldStopData.b;
        stopToUpdate.a = changeDetails.oldStopData.a;
        // Offset is not changed by user, so no need to revert it unless recorded.
        updateLottieGradient(); // This will update lottieData from allGradients
      }
    }else if (changeDetails.type === 'SOLID_COLOR_ACCORDION') { // New Handler
      changeDetails.items.forEach(item => {
        setValueByPath(lottieData, item.path, [...item.oldValue]); // Revert each item to its specific old RGBA
      });
    } else if (changeDetails.type === 'ANIMATED_SOLID_COLOR_KEYFRAME') { // <<< NEW HANDLER
      setValueByPath(lottieData, changeDetails.path, [...changeDetails.oldValue]);
    } else if (changeDetails.type === 'ANIMATED_GRADIENT_KEYFRAME') { // <<< NEW HANDLER
      setValueByPath(lottieData, changeDetails.path, [...changeDetails.oldValue]);
    }else if (changeDetails.type === 'ANIMATED_SOLID_COLOR_GROUP_KEYFRAME') { // <<< HANDLER
      changeDetails.items.forEach(item => {
        setValueByPath(lottieData, item.path, [...item.oldValue]);
      });
    }
    else if (changeDetails.type === 'TEXT_PROPERTY') {
    const textElement = detectedTextElements[changeDetails.textElementIndex];
    if (textElement) {
        // The path in changeDetails directly points to either '.t' or '.fc'
        // For text content: changeDetails.path would be like [...layerPath, 't', 'd', 'k', keyframeIndex, 's', 't']
        // For color: changeDetails.path would be like [...layerPath, 't', 'd', 'k', keyframeIndex, 's', 'fc']
        setValueByPathTxt(lottieData, changeDetails.path, Array.isArray(changeDetails.oldValue) ? [...changeDetails.oldValue] : changeDetails.oldValue);

        // Additionally, update the direct reference in detectedTextElements if you rely on it for UI rendering
        // This depends on how `textNodeRef` is used. If `setValueByPath` updates the original lottieData,
        // and `textNodeRef` points into `lottieData`, it should be automatically updated.
        // However, explicitly:
        if (changeDetails.path.slice(-1)[0] === 't') { // If it was a text change
             textElement.textNodeRef.t = changeDetails.oldValue;
        } else if (changeDetails.path.slice(-1)[0] === 'fc') { // If it was a color change
             textElement.textNodeRef.fc = [...changeDetails.oldValue];
        }
    }
  }

  }

  // Refresh UI (common logic after state change)
  refreshUIStateAndRender();
  // ---- ADD THIS BLOCK ----

  // ---- END ADD THIS BLOCK ----
}



function performRedo() {
  if (redoStack.length === 0) {
    console.log("Redo stack empty, nothing to redo.");
    return;
  }

  const changeDetails = redoStack.pop();
  undoStack.push(changeDetails); // Push the change itself to undo

  console.log('Performing redo for:', changeDetails.type);

  if (changeDetails.type === 'SOLID_COLOR') {
    setValueByPath(lottieData, changeDetails.path, [...changeDetails.newValue]); // Use a copy
  } else if (changeDetails.type === 'GRADIENT_STOP') {
    const gradStops = allGradients[changeDetails.gradientIndex];
    if (gradStops && gradStops[changeDetails.stopIndex]) {
      const stopToUpdate = gradStops[changeDetails.stopIndex];
      stopToUpdate.r = changeDetails.newStopData.r;
      stopToUpdate.g = changeDetails.newStopData.g;
      stopToUpdate.b = changeDetails.newStopData.b;
      stopToUpdate.a = changeDetails.newStopData.a;
      updateLottieGradient(); // This will update lottieData from allGradients
    }
  } else if (changeDetails.type === 'SOLID_COLOR_ACCORDION') { // New Handler
    const { newBaseRgbApplied, items } = changeDetails;
    items.forEach(item => {
      // For redo, apply the newBaseRgbApplied with the original alpha of the item (stored in item.oldValue[3])
      const originalAlpha = item.oldValue.length === 4 ? item.oldValue[3] : 1;
      const newColorWithOriginalAlpha = [...newBaseRgbApplied, originalAlpha];
      setValueByPath(lottieData, item.path, newColorWithOriginalAlpha);
    });
  }else if (changeDetails.type === 'ANIMATED_SOLID_COLOR_KEYFRAME') { // <<< NEW HANDLER
    setValueByPath(lottieData, changeDetails.path, [...changeDetails.newValue]);
  } else if (changeDetails.type === 'ANIMATED_GRADIENT_KEYFRAME') { // <<< NEW HANDLER
    setValueByPath(lottieData, changeDetails.path, [...changeDetails.newValue]);
  } else if (changeDetails.type === 'ANIMATED_SOLID_COLOR_GROUP_KEYFRAME') { // <<< HANDLER
    changeDetails.items.forEach(item => {
      setValueByPath(lottieData, item.path, [...item.newValue]);
    });
  }
else if (changeDetails.type === 'TEXT_PROPERTY') {
    const textElement = detectedTextElements[changeDetails.textElementIndex];
    if (textElement) {
        setValueByPath(lottieData, changeDetails.path, Array.isArray(changeDetails.newValue) ? [...changeDetails.newValue] : changeDetails.newValue);
        // Explicitly update textNodeRef for consistency:
        if (changeDetails.path.slice(-1)[0] === 't') {
             textElement.textNodeRef.t = changeDetails.newValue;
        } else if (changeDetails.path.slice(-1)[0] === 'fc') {
             textElement.textNodeRef.fc = [...changeDetails.newValue];
        }
    }
}

  // Refresh UI (common logic after state change)
  refreshUIStateAndRender();
  // ---- ADD THIS BLOCK ----

 // ---- END ADD THIS BLOCK ----
}



function refreshUIStateAndRender() {


   recordAccordionStates();

  // Re-evaluate colorRefs and allGradients from the current lottieData
  // This is important because lottieData (or allGradients that affects lottieData) has changed.
  colorRefs = [];
  findColors(lottieData); // findColors populates colorRefs

  // For gradients, if updateLottieGradient() was called, lottieData is updated.
  // We need to re-extract 'allGradients' to ensure the UI renders based on the true current state
  // of the gradient structures within lottieData, which might have been reverted.
  allGradients = extractGradientStops(lottieData);

  animatedColorRefs = [];
  findAnimatedColors(lottieData);
  // Apply empty state logic
  const emptyStateDiv = document.getElementById('emptyStateDiv');
  const colorInstancesLabel = document.getElementById('colorInstancesLabel');
  const editorAreaDiv = document.getElementById('editorArea'); // Get the parent

  if (!anyContent) {

    colorEditor.style.display = 'none';
    stopEditor.style.display = 'none';
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'none'; // Hide heading
    if(animatedGradientLabel) animatedGradientLabel.style.display = 'none';
    if (emptyStateDiv) emptyStateDiv.style.display = 'flex'; // Show empty state (use flex for centering)
    if (editorAreaDiv) editorAreaDiv.classList.add('is-empty'); // Add class to parent
    console.log("No colors or gradients detected. Displaying empty state.");
  } else {
    document.getElementById('colorEditor').style.display = 'block';
    document.getElementById('stopEditor').style.display = 'block';
    if (colorInstancesLabel) colorInstancesLabel.style.display = 'block';
    if (emptyStateDiv) emptyStateDiv.style.display = 'none';
    if (editorAreaDiv) editorAreaDiv.classList.remove('is-empty');
  }
  const animatedGradientLabel = document.getElementById('animatedGradientLabel');
  const container = document.getElementById('animatedGradientEditor');
  const editableItemsRendered = container.querySelectorAll('.stop-row');
  if (animatedGradientLabel) {
    console.log('this has happened');
    animatedGradientLabel.style.display = editableItemsRendered.length > 0 ? 'block' : 'none';
  }




  detectedTextElements = []; // <<<< ADD THIS: Clear and re-find text elements
    findTextLayersRecursive(lottieData.layers, '', ['lottieData']);
    if (lottieData.assets) {
        lottieData.assets.forEach((asset, assetIndex) => {
            if (asset.layers) {
                findTextLayersRecursive(asset.layers, asset.id || `asset${assetIndex}_`, ['lottieData', 'assets', assetIndex]);
            }
        });
    }




  renderColorPickers();   // Renders based on current colorRefs
  renderGradientEditor();
  renderAnimatedColorEditor(); // Renders based on current allGradients
  renderAnimatedGradientEditor();
  reloadLottiePreview();  // Reloads Lottie player with current lottieData
  renderTextEditorUI();
  initializeElementsToManageVisibility();
   // --- Handle Empty State and Labels AFTER rendering the base UI ---




       if (emptyStateDiv) emptyStateDiv.style.display = anyContent ? 'none' : 'flex';
       if (editorAreaDiv) editorAreaDiv.classList.toggle('is-empty', !anyContent);

       //document.getElementById('animatedGradientLabel').style.display = hasAnimatedGradients ? 'block' : 'none';
       // textEditorLabel's visibility is typically handled within renderTextEditorUI

       // --- Re-apply filter if active ---
       if (activePickedColor) {
           console.log("Re-applying filter (during undo/redo or refresh) for color:", activePickedColor);
           isUserInitiatedFilter = false; // Ensure this is false when re-applying post-undo/redo
           handleColorPickedForFiltering(activePickedColor);
       }


}

function recordAccordionStates() {
  preservedColorAccordionStates = {};
  const colorAccordions = document.querySelectorAll('#colorEditor .accordion');
  colorAccordions.forEach(accordion => {
      const id = accordion.dataset.id; // We'll add this dataset.id in renderColorPickers
      if (id) {
          const header = accordion.querySelector('.accordion-header');
          // An accordion is open if its header has the 'active' class
          preservedColorAccordionStates[id] = header ? header.classList.contains('active') : false;
      }
  });

  preservedGradientAccordionStates = {};
  const gradientAccordions = document.querySelectorAll('#stopEditor .gradient-accordion');
  gradientAccordions.forEach(accordion => {
      const id = accordion.dataset.id; // We'll add this dataset.id in renderGradientEditor
      if (id) {
          const header = accordion.querySelector('.gradient-header');
          preservedGradientAccordionStates[id] = header ? header.classList.contains('active') : false;
      }
  });

 // --- Animated Color Accordions (Updated for new ID structure) ---
  preservedAnimatedColorAccordionStates = {};
  // The new renderAnimatedColorEditor uses 'gradient-accordion' class and a new dataset.id format.
  const animatedColorAccordions = document.querySelectorAll('#animatedColorEditor .gradient-accordion');
  animatedColorAccordions.forEach(accordion => {
    // The id will be like: `anim-color-group-${hexColor.replace('#', '')}-${groupIdx}`
    const id = accordion.dataset.id;
    if (id) {
      const header = accordion.querySelector('.gradient-header'); // Still uses .gradient-header
      preservedAnimatedColorAccordionStates[id] = header ? header.classList.contains('active') : false;
    }
  });
  // --- End Animated Color Accordions ---

  // --- Animated Gradient Accordions (NEW) ---
  preservedAnimatedGradientAccordionStates = {};
  const animatedGradientAccordions = document.querySelectorAll('#animatedGradientEditor .gradient-accordion');
  animatedGradientAccordions.forEach(accordion => {
      const id = accordion.dataset.id; // We'll add this dataset.id in renderAnimatedGradientEditor
      if (id) {
          const header = accordion.querySelector('.gradient-header');
          preservedAnimatedGradientAccordionStates[id] = header ? header.classList.contains('active') : false;
      }
  });

  // --- MODIFICATION FOR TEXT ACCORDION STATE ---
    // DO NOT CLEAR preservedTextAccordionStates here:
    // preservedTextAccordionStates = {}; // <--- REMOVE THIS LINE

    const mainTextAccordion = document.getElementById('detected-text-main-accordion');
    if (mainTextAccordion) {
        // If the accordion exists in the DOM, record its current state
        const header = mainTextAccordion.querySelector('.gradient-header');
        // Use the accordion's dataset.id as the key, which is 'detected-text-main-accordion'
        if (mainTextAccordion.dataset.id) { // Ensure dataset.id exists
          preservedTextAccordionStates[mainTextAccordion.dataset.id] = header ? header.classList.contains('active') : false;
        }
    }
    // If mainTextAccordion is not found, its state in preservedTextAccordionStates remains untouched,
    // preserving the last known state (e.g., if it was open before text elements disappeared).
    // --- END MODIFICATION ---


}

function commitAfterIdle(inputEl, onCommit, delay = 150) {
  let timer = null;
  inputEl.addEventListener('input', e => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      onCommit(e.target.value);
      timer = null;
    }, delay);
  });
}


/**
 * Recursively finds animated color properties (solid or gradient)
 * i.e. where obj.c.k is an array of keyframe objects ({ t, s: [r,g,b,a], … })
 */
 function findAnimatedColors(obj, path = []) {
   if (Array.isArray(obj)) {
     obj.forEach((item, i) => findAnimatedColors(item, [...path, i]));
   } else if (obj && typeof obj === 'object') {
     // ——— SOLID COLOR ANIMATION ONLY ———
     if (
       obj.c &&                              // has a “color” property
       Array.isArray(obj.c.k) &&            // that .k is an array of keyframes
       obj.c.k.length > 0 &&                // there is at least one keyframe
       Array.isArray(obj.c.k[0].s) &&       // each keyframe has an .s stops array
       obj.c.k[0].s.length >= 3             // and that .s is at least [r,g,b]
     ) {
       const kfPaths = obj.c.k.map((_, i) => [...path, 'c', 'k', i, 's']);
       animatedColorRefs.push({
         path: [...path, 'c', 'k'],
         keyframePaths: kfPaths
       });
     }

     // ——— NO gradient logic here ———

     // recurse into every other property
     for (let key in obj) {
       findAnimatedColors(obj[key], [...path, key]);
     }
   }

   // (optional) at the very top‐level you can still print your summary:
   if (path.length === 0) {
     const solids = animatedColorRefs;
     const solidStops = solids.reduce((sum, g) => sum + g.keyframePaths.length, 0);
     console.log(
       `${solids.length} animated solid color${solids.length!==1?'s':''} found, ` +
       `${solidStops} editable stop${solidStops!==1?'s':''}`
     );
   }
 }

 function renderAnimatedColorEditor() {
  const container = document.getElementById('animatedColorEditor');
  container.innerHTML = ''; // Clear previous UI



  const animatedColorLabel = document.getElementById('animatedColorLabel');
if (!initialAnimatedColorGroupsByHex || Object.keys(initialAnimatedColorGroupsByHex).length === 0) {
    if (animatedColorLabel) animatedColorLabel.style.display = 'none';
 console.log ('whats going on');
    return;
  } else {
    if (animatedColorLabel) animatedColorLabel.style.display = 'block';
  }

 // --- 3. CHANGE: Iterate over sorted keys of initialAnimatedColorGroupsByHex for stable order ---
  const sortedInitialHexKeys = Object.keys(initialAnimatedColorGroupsByHex).sort();

  sortedInitialHexKeys.forEach((initialHexKey, groupIdx) => { // Was: Object.entries(animatedColorsByHex).forEach(([hexColor, instancesArray], groupIdx) => {
    const instancesArray = initialAnimatedColorGroupsByHex[initialHexKey]; // Get instances for this initial hex key

    // --- 4. CHANGE: Accordion ID based on initialHexKey and stable groupIdx ---
    const accordionId = `anim-color-group-${initialHexKey.replace('#', '')}-${groupIdx}`;


    const accordion = document.createElement('div');
    accordion.className = 'gradient-accordion'; // Reuse styling
    accordion.dataset.id = accordionId;

    const header = document.createElement('div');
    header.className = 'gradient-header';

    const headerContent = document.createElement('div');
    headerContent.className = 'accordion-header-content';

    const title = document.createElement('span');
    title.textContent = `${instancesArray.length} Instance${instancesArray.length > 1 ? 's' : ''}`;

    // Master color picker for the group
    const groupControls = document.createElement("div");
    groupControls.className = "accordion-header-controls color-input-group"; // Reuse styles

    const groupHexInput = document.createElement("input");
    groupHexInput.type = "text";
     groupHexInput.value = initialHexKey;
    groupHexInput.setAttribute("aria-label", `Hex code for original color group ${initialHexKey}`);


    const groupColorInput = document.createElement("input");
    groupColorInput.type = "color";
     groupColorInput.value = initialHexKey;
    groupColorInput.setAttribute("aria-label", `Picker for original color group ${initialHexKey}`);

    groupControls.appendChild(groupHexInput); // Or picker first
    groupControls.appendChild(groupColorInput);

    headerContent.appendChild(title);
    headerContent.appendChild(groupControls);
    header.appendChild(headerContent);

    const body = document.createElement('div');
    body.className = 'gradient-content';
    body.id = `anim-color-group-body-${initialHexKey.replace('#', '')}-${groupIdx}`;

    // Apply preserved accordion state
    if (preservedAnimatedColorAccordionStates && preservedAnimatedColorAccordionStates[accordionId] === true) {
      header.classList.add('active');
      body.classList.add('active');
      body.style.display = "flex";
      header.setAttribute('aria-expanded', 'true');
    } else {
      body.style.display = "none";
      header.setAttribute('aria-expanded', 'false');
    }

    // Event listener for the group color picker
   const handleGroupColorChange = (newHex) => {
        if (!/^#[0-9A-F]{6}$/i.test(newHex)) return;
        const [newR_norm, newG_norm, newB_norm] = hexToRgb(newHex);
        const changesToRecord = [];

        // This affects all instances that *initially* belonged to this initialHexKey group
        instancesArray.forEach(instanceData => { // instanceData is from initialAnimatedColorGroupsByHex
            const oldValue = [...getValueByPath(lottieData, instanceData.kfPath)];
            // Apply new RGB, but preserve the alpha this keyframe had at load time (instanceData.initialAlpha)
            const newColorArrayWithInitialAlpha = [newR_norm, newG_norm, newB_norm, instanceData.initialAlpha];
            setValueByPath(lottieData, instanceData.kfPath, newColorArrayWithInitialAlpha);
            changesToRecord.push({
                path: [...instanceData.kfPath],
                oldValue: oldValue,
                newValue: [...newColorArrayWithInitialAlpha]
            });
        });

        if (changesToRecord.length > 0) {
            recordChange({
                type: 'ANIMATED_SOLID_COLOR_GROUP_KEYFRAME',
                items: changesToRecord,
                newBaseHex: newHex
            });
        }

        body.querySelectorAll('.color-row').forEach((rowNode, rowIndex) => {
            const instance = instancesArray[rowIndex];
            if (instance) {
                const rowColorInput = rowNode.querySelector('input[type="color"]');
                const rowHexInput = rowNode.querySelector('input[type="text"]');
                if (rowColorInput) rowColorInput.value = newHex;
                if (rowHexInput) rowHexInput.value = newHex;
            }
        });
        reloadLottiePreview();
    };


    commitAfterIdle(groupColorInput, (newHexValue) => {
        groupHexInput.value = newHexValue; // Sync hex input
        handleGroupColorChange(newHexValue);
    }, 150);

    groupHexInput.addEventListener('change', (e) => {
        let newHexVal = e.target.value.trim();
        if (!newHexVal.startsWith("#")) newHexVal = "#" + newHexVal;
        if (/^#[0-9A-F]{6}$/i.test(newHexVal)) {
            groupColorInput.value = newHexVal; // Sync color picker
            handleGroupColorChange(newHexVal);
        } else {
            alert("Invalid hex code. Please use #RRGGBB format.");
            e.target.value = groupColorInput.value; // Revert
        }
    });


    // Populate accordion body with instances
    instancesArray.forEach((instanceData, instanceIdx) => { // instanceData is from initialAnimatedColorGroupsByHex
      // --- 8. CHANGE: Get CURRENT color from lottieData for instance's picker ---
      const currentActualKfColorArray = getValueByPath(lottieData, instanceData.kfPath);
      const [r_curr, g_curr, b_curr, a_curr = 1] = currentActualKfColorArray; // Use current alpha from lottieData
      const currentInstanceHexDisplay = rgbToHex(r_curr, g_curr, b_curr);

      const row = document.createElement('div');
      row.className = 'color-row stop-row';

      const labelWrapper = document.createElement('div');
      labelWrapper.className = 'title-wrapper';
      labelWrapper.style.display = 'flex';
      labelWrapper.style.alignItems = 'center';
      labelWrapper.style.gap = 'var(--spacing-sm)';

      const instanceLabel = document.createElement('span');
      instanceLabel.className = 'label';
      instanceLabel.textContent = `Instance ${instanceIdx + 1}`;
      instanceLabel.title = `Layer: ${instanceData.layerName}, Original Group: ${instanceData.originalHexGroup}, KF Index: ${instanceData.keyframeIndex}`;
      labelWrapper.appendChild(instanceLabel);

          // 1. Turn the stored kfPath into the parent “shape” object
    const fullPath = instanceData.kfPath;                  // e.g. [..., 'c','k']
    const shapePath = fullPath.slice(0, -4);               // drop the ['c','k']
    const shapeItem = getValueByPath(lottieData, shapePath);

	const propertyGroupIdentifier = pathToGroupId(instanceData.originalPropertyPath);
if (shapeItem) { // Ensure shapeItem is valid
    pillPropertyGroupMap.set(shapeItem, propertyGroupIdentifier); // <<< SET IN WEAKMAP
}

    // 2. Create a pill that toggles only this fill/stroke
    const layerPill = createLayerNamePill(instanceData.layerName, shapeItem);
    if (layerPill) {
      // 3. Prevent the accordion header from toggling when you click the pill
      layerPill.addEventListener('click', e => e.stopPropagation());
      labelWrapper.appendChild(layerPill);
    }

      const inputGroup = document.createElement('div');
      inputGroup.className = 'color-input-group';

      const hexInput = document.createElement('input');
      hexInput.type = 'text';
      hexInput.value = currentInstanceHexDisplay; // Display current actual color
      hexInput.setAttribute('aria-label', `Hex for Instance ${instanceIdx + 1}`);

      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = currentInstanceHexDisplay; // Display current actual color
      colorInput.setAttribute('aria-label', `Picker for Instance ${instanceIdx + 1}`);

      // --- 9. MODIFY: Individual instance color change to use its initialAlpha ---
      commitAfterIdle(colorInput, (newHexValue) => {
        const oldValue = [...getValueByPath(lottieData, instanceData.kfPath)];
        const [nr, ng, nb] = hexToRgb(newHexValue);
        // Apply new RGB, but preserve the alpha this keyframe had at load time (instanceData.initialAlpha)
        const updatedColorArray = [nr, ng, nb, instanceData.initialAlpha];
        setValueByPath(lottieData, instanceData.kfPath, updatedColorArray);

        hexInput.value = newHexValue;
        reloadLottiePreview();

        recordChange({
          type: 'ANIMATED_SOLID_COLOR_KEYFRAME',
          path: [...instanceData.kfPath],
          oldValue: oldValue,
          newValue: [...updatedColorArray]
        });
      }, 150);

      hexInput.addEventListener('change', (e) => {
        let newHexFromText = e.target.value.trim();
        if (!newHexFromText.startsWith("#")) newHexFromText = "#" + newHexFromText;
        if (/^#[0-9A-F]{6}$/i.test(newHexFromText)) {
          const oldValue = [...getValueByPath(lottieData, instanceData.kfPath)];
          const [nr, ng, nb] = hexToRgb(newHexFromText);
          // Apply new RGB, but preserve the alpha this keyframe had at load time (instanceData.initialAlpha)
          const updatedColorArray = [nr, ng, nb, instanceData.initialAlpha];
          setValueByPath(lottieData, instanceData.kfPath, updatedColorArray);
          colorInput.value = newHexFromText;
          reloadLottiePreview();
          recordChange({
            type: 'ANIMATED_SOLID_COLOR_KEYFRAME',
            path: [...instanceData.kfPath],
            oldValue: oldValue,
            newValue: [...updatedColorArray]
          });
        } else {
          alert('Invalid hex code. Please use #RRGGBB format.');
          e.target.value = colorInput.value;
        }
      });

      inputGroup.append(colorInput, hexInput);
      row.append(labelWrapper, inputGroup);
      body.appendChild(row);
    });


    header.addEventListener('click', (e) => {
      // Prevent toggle if click is on input elements within the header
      if (e.target.closest('input[type="color"], input[type="text"]')) {
          return;
      }
      const open = body.classList.toggle('active');
      header.classList.toggle('active', open);
      body.style.display = open ? 'flex' : 'none';
      header.setAttribute('aria-expanded', open);
    });
    header.setAttribute('role', 'button');
    header.setAttribute('aria-controls', body.id);

    accordion.append(header, body);
    container.appendChild(accordion);
  });
}






  </script>
</body>
</html>
