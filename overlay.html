<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link
  href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
  rel="stylesheet"
/>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lottie Segment Marker Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; max-width: 1024px; margin: 0 auto; padding: 20px;   background: #f5f5f5; }
    h1 { margin-bottom: 16px; }
    .container { display: flex; flex-direction: column; gap: 20px; }

    /* Animation preview + main play */
    #preview-wrapper { position: relative; background: #f5f5f5; border-radius: 32px;   background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
                        linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
                        linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;}
    #animation-container { width: 100%; height: 400px;  border-radius: 8px; overflow: hidden; margin-bottom: 3rem;}
    .main-play-btn {
      position: absolute; bottom: 8px; left: 8px; z-index: 5;
      padding: 6px 12px; background: #007bff; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;
    }

    #globalBar { position: relative; height: 8px; background: #ddd; border-radius: 4px; margin-top: 8px; width: 100%; flex: 1;}

    .controls { display: flex; flex-direction: column; gap: 16px; }
    .button-group { display: flex; gap: 10px; }
    button { padding: 8px 16px; background: #4CAF50; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
    button:disabled { background: #ccc; cursor: not-allowed; }

    #segmentsContainer { display: flex; flex-direction: column; gap: 12px; }
    .segment-control { padding: 12px; background: #fafafa; border-radius: 4px; display: flex;  gap: 8px; }
    .segment-header { position: relative; display: flex; align-items: center; gap: 24px; width: 100%; }    .frame-input{background-color: #f5f5f5 !important;}
    .segment-name { padding: 4px 8px; font-size: 14px; width: 80px; }
    .frame-input { width: 70px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; }
    .play-btn, .download-btn { height: 2rem; width: 2rem; border: none; border-radius: 999px; cursor: pointer; }
    .download-btn { background: #007bff; color: #fff; }

    .range-container { position: relative; height: 24px; box-sizing: border-box; padding: 0 7px; }
    .range-highlight { position: absolute; top: 10px; height: 4px; border-radius: 2px; border-left: 2px solid; border-right: 2px solid; z-index: 1; }
    .range-input {
      -webkit-appearance: none; width: 100%; height: 16px; background: transparent; margin: 0; padding: 0;
      position: absolute; top: 0; pointer-events: none; z-index: 2;
    }
    .range-input::-webkit-slider-runnable-track { background: transparent; }
    .range-input::-webkit-slider-thumb {
      -webkit-appearance: none; pointer-events: all; width: 16px; height: 16px;
      border-radius: 50%; background: #007bff; border: none; cursor: pointer; margin-top: -6px; z-index: 3;
    }
    .range-input::-moz-range-track { background: transparent; }
    .range-input::-moz-range-thumb {
      pointer-events: all; width: 16px; height: 16px; border-radius: 50%;
      background: #007bff; border: none; cursor: pointer; margin-top: 0; z-index: 3;
    }
    .close-btn {
       position: absolute;
       top: -24px; /* Adjust as needed */
       right:-24px; /* Adjust as needed */
       width: 24px;
       height: 24px;
       padding: 0;
       border: none;
       border-radius: 50%;
       background: #eee; /* Light gray background */
       color: #555;     /* Darker gray text/icon */
       font-size: 16px; /* Adjust size of the '×' */
       line-height: 24px; /* Center the '×' vertically */
       text-align: center;
       cursor: pointer;
       transition: background-color 0.2s ease, color 0.2s ease;
       z-index: 5; /* Ensure it's above other elements if needed */

       /* --- SVG Background Styles --- */
        background-image: url('deleteblack.svg'); /* Path to your SVG */
        background-repeat: no-repeat;
        background-position: center center; /* Center the icon */
        background-size: 18px 18px; /* Adjust size of icon inside button */

        /* --------------------------- */
   }

   .close-btn:hover {
       background-color: #e0588c; /* Darken background on hover */
       color: #222;         /* Darken text/icon on hover */
   }

    #status { font-style: italic; color: #666; }
    #error { color: #f44336; }

/* some ui improvements */


/* make each segment row a flex container */
.segment-control {
  display: flex;
  align-items: center;
  gap: 16px;
  border-radius: 24px;
  padding: 20px;
  background: #fff;
}

/* left “info” column: name above the two frame numbers */

/* stack start/end inputs vertically */
.segment-info {
  display: flex;
  flex-direction: column;
  gap: 8px;

}
.frame-inputs {
 display: flex;

 gap: 2px;

}


/* the slider handles take up the remaining horizontal space */
.segment-handles {
  flex: 1;
}

/* right-side actions (Play / Download) stacked vertically */
.segment-actions {
  display: flex;

  gap: 10px;
  margin-left: 16px;
}

/* segment input stylings*/

.segment-name,
.frame-input {
  height: 20px;
  background: none;
  border: none;              /* light gray border */
  border-radius: 999px;                  /* pill-shaped corners */
  padding: 4px 14px;                    /* a bit of breathing room */
  transition: border-color 0.2s ease,  /* smooth color change */
              box-shadow 0.2s ease;    /* smooth shadow on focus */
}


.frame-input::-webkit-outer-spin-button,
.frame-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.frame-input {
  -moz-appearance: textfield;
}

/* hover state */
.segment-name:hover,
.frame-input:hover {
    background: #fff;
  border-color: #888;                  /* darken border on hover */
}

/* focus state */
.segment-name:focus,
.frame-input:focus {
  outline: none;                       /* remove default outline */
  border-color: #007bff;               /* blue border on focus */
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

.frame-input{
  width: 30px;
  background: #fff;
  margin-right: 8px;
}

.segment-frames {
  font-size: 0.9rem;
  color: #555;
}

.segment-info{
  width: 140px;
}



/*Segment handles*/
/* 1) full‐length dull track behind everything */
.range-container::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 6px;                  /* track thickness */
  background: #ddd;             /* dull color */
  border-radius: 3px;
  transform: translateY(-50%);
  z-index: 0;
}

/* 2) highlight bar perfectly centered */
.range-highlight {
  position: absolute;
  top: 50%;
  height: 6px;                  /* match track thickness */
  transform: translateY(-50%);
  z-index: 1;
  border: none;                 /* remove side borders if you like */
  border-radius: 3px;
}

/* 3) make the two thumbs into vertical pills */
.range-input {
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  z-index: 2;
}

/* WebKit pill‐style thumb */
.range-input::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px; /* Slightly wider */
  height: 24px;
  margin-top: 0px; /* Adjust as needed based on track height */
  border-radius: 7px; /* More rounded pill */
  background: #007bff;
  border: 2px solid #ffffff; /* Slightly darker border */
  cursor: pointer;
  z-index: 3;
  transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Add transitions */

}

.range-input:hover::-webkit-slider-thumb {
  background-color: #0056b3; /* Darken on hover */

}

.range-input:active::-webkit-slider-thumb {
  transform: scale(1.1); /* Slightly enlarge */
  background-color: #004085; /* Even darker */
}

/* Firefox pill‐style thumb */
.range-input::-moz-range-thumb {
  width: 14px; /* Slightly wider */
  height: 24px;
  border-radius: 7px; /* More rounded pill */
  background: #007bff;
  border: 2px solid #ffffff; /* Slightly darker border */
  cursor: pointer;
  transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Add transitions */

}

.range-input:hover::-moz-range-thumb {
  background-color: #0056b3; /* Darken on hover */

}
.range-input:active::-moz-range-thumb {
  transform: scale(1.1); /* Slightly enlarge */
  background-color: #004085; /* Even darker */
}

/* hide the default track */
.range-input::-webkit-slider-runnable-track,
.range-input::-moz-range-track {
  background: transparent;
}


body .container #fullControl{
  flex-direction: row;
  padding-top: 24px;
  padding-bottom: 24px;
 box-shadow: 0 -2px 16px rgba(0, 0, 0, 0.03);
  border-radius: 0 0 32px 32px;

  background: #
}

/* seek control*/
.segment-handles {
  flex: 1;                /* fill the gap */
  position: relative;     /* positioning context */
  margin: 0;         /* optional side‐padding */
}

/* position the bar dead‐center inside .segment-handles */
.segment-handles #globalBar {
  position: absolute;
  top: 50%;
  left:   0;
  width: 100%;
  height: 6px;            /* your track thickness */
  margin: 0;
  transform: translateY(-50%);
}

/* layer the scrubber on top, same footprint */
#fullSeek {
  position: absolute;
  top: 50%;
  left:   0;
  width: 100%;
  height: 8px;            /* at least thumb‐height */
  transform: translateY(-50%);
  background: transparent;
  pointer-events: all;
  z-index: 2;             /* above the bar */
}

/* hide the native track and style the thumb */
#fullSeek::-webkit-slider-runnable-track,
#fullSeek::-moz-range-track {
  background: transparent;
}
#fullSeek::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px; height: 14px;
  margin-top: -3px;       /* center on 6px bar */
  border-radius: 50%;
  background: #007bff;
  border: 2px solid #fff;
  cursor: pointer;
  z-index: 3;
}
#fullSeek::-moz-range-thumb {
  width: 14px; height: 14px;
  border-radius: 50%;
  background: #007bff;
  border: 2px solid #fff;
  cursor: pointer;
  transform: translateY(-3px);
  z-index: 3;
}

/* 1) Remove any default track styling */
#fullSeek {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: transparent;
}

/* 2) Hide the track */
#fullSeek::-webkit-slider-runnable-track,
#fullSeek::-moz-range-track {
  height: 0;
  background: transparent;
}

/* 3) Style only the thumb as a circle */
#fullSeek::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #007bff;
  border: 2px solid #fff;
  margin-top: -4px;   /* vertically center over 6px bar */
  cursor: pointer;
}
#fullSeek::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #007bff;
  border: 2px solid #fff;
  transform: translateY(-4px);
  cursor: pointer;
}
.segment-handles #globalBar {


box-sizing: border-box;
}

/* 2) tooltip styling */
.seek-tooltip {
  position: absolute;
  top: -2.3rem;               /* float above the bar */
  transform: translateX(-73%);
  padding: 4px 6px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  font-size: 0.75rem;
  border-radius: 4px;
  pointer-events: none;
  white-space: nowrap;
  display: none;
  z-index: 4;
}

.seek-tooltip {
  /* start invisible & smoothly transition opacity */
  opacity: 0;
  transition: opacity 300ms ease-out;
}

/* aligning seek thumb perfectly */

/* 1) Make sure the input still spans the full width and is centered over the bar */
.segment-handles #fullSeek {
  left: -10px;                         /* negative half-thumb width */
  width: calc(100% + 20px);            /* full + thumb width */
}


/* 2) vertically center a 20px thumb over an 8px bar */
#fullSeek::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px; /* Slightly larger */
  height: 20px;
  margin-top: -5px; /* Re-center based on new size and 6px bar */
  border-radius: 50%; /* Keep circular */
  background: #007bff;
  border: 2px solid #ffffff; /* White border for contrast */
  cursor: pointer;
  z-index: 3;
  transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Add transitions */

}
#fullSeek::-moz-range-thumb {
  width: 20px; /* Slightly larger */
  height: 20px;
  border-radius: 50%; /* Keep circular */
  background: #007bff;
  border: 2px solid #ffffff; /* White border for contrast */
  cursor: pointer;
  transform: translateY(-5px); /* Re-center based on new size and 6px bar */
  z-index: 3;
  transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Add transitions */

}

/* Hover effect for main seekbar thumb */
#fullSeek:hover::-webkit-slider-thumb {
background-color: #0056b3; /* Darken */

}
#fullSeek:hover::-moz-range-thumb {
background-color: #0056b3; /* Darken */

}

/* Active/Dragging effect for main seekbar thumb */
#fullSeek:active::-webkit-slider-thumb {
transform: scale(1.15); /* Enlarge more */
background-color: #004085; /* Even darker */
}
#fullSeek:active::-moz-range-thumb {
/* Need to combine transforms */
transform: translateY(-6px) scale(1.15); /* Enlarge more */
background-color: #004085; /* Even darker */
}



  /* play pause dynamic */

.play-btn, #mainPlay {
  /* size to your SVG, hide any text */
  width: 24px;
  height: 24px;
  padding: 0;
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  border: none;
  color: transparent;
  cursor: pointer;
}

/* default = play icon */
.play-btn, #mainPlay {
  background-image: url('play.svg');
  width: 32px;
  height: 32px;
 background-size: 24px 24px;
}

/* when paused (i.e. playing state), show pause icon */
.play-btn.paused, #mainPlay.paused {
  background-image: url('pause.svg');
}



.download-btn {
  width: 32px;
  height: 32px;
  padding: 0;
  border: none;
  background-image: url('download.svg');
  background-size: 26px 26px;
  color: transparent;  /* hide any inner text */
  background-repeat: no-repeat;
  background-position: center;

}

#addSegment {
  font-family: Inter;
  font-weight: bold;
  background-color: transparent; /* No background fill */
  color: #888888; /* Greyish text color */
  border: 2px dashed #cccccc; /* Greyish dotted border */
  padding: 10px 16px; /* Adjust padding for comfortable clicking */
  border-radius: 10px; /* Slightly rounded corners */
  cursor: pointer;
  font-weight: 500; /* Slightly bolder text */
  text-align: center; /* Center the text */
  width: 60%; /* Make the button take full available width */
  margin: auto;
   /* Add some space above the button */
  box-sizing: border-box; /* Include padding and border in the element's total width and height */
  /* Smooth transitions for hover effects */
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}

/* Hover effect (only when the button is NOT disabled) */
#addSegment:hover:not(:disabled) {
  background-color: rgba(0, 123, 255, 0.05); /* Very light blueish background tint */
  color: #007bff; /* Blueish text color */
  border-color: #007bff; /* Blueish border color */
}

/* Style for when the button is disabled */
#addSegment:disabled {
  background-color: transparent; /* Keep background transparent */
  color: #bbbbbb; /* Lighter grey text when disabled */
  border-color: #dddddd; /* Lighter grey border when disabled */
  cursor: not-allowed; /* Indicate it's not clickable */
}

  </style>
</head>
<body>
  <div class="container">



    <!-- Preview + main play -->
    <div id="preview-wrapper">
      <div id="animation-container"></div>
      <div id="fullControl" class="segment-control" style="border-color:#888;">
      <div class="segment-header">
    <div class="segment-info">
  <div style=" font-size: 14px;">Full Animation</div>
      <div class="segment-frames" id="fullFramesCount">0 frames</div>
    </div>
      <div class="segment-handles">
      <div id="globalBar"></div>
      <input id="fullSeek" type="range" min="0" max="0" value="0" />
      <div id="seekTooltip" class="seek-tooltip"></div>
    </div>
    <div class="segment-actions">
      <div class="button-group">
        <button id="mainPlay" class="play-btn" disabled>Play All</button>
          <button id="downloadAll" class="download-btn" disabled></button>
        </div>
    </div>
  </div>
  </div>

    </div>




    <div class="controls">
        <button id="addSegment" disabled> Add a Segment</button>
      <div id="segmentsContainer"></div>
      <div class="button-group">

      </div>

    </div>

  </div>

  <script>
    // --- Global/Accessible Scope Variables ---
    let originalData = null;
     let originalFilename = 'animation';
    const maxSegments = 10;
    const segmentColors = [
      '#87d8c0', // Mint Green
      '#c5e0a5', // Pastel Olive
      '#ffb79a', // Soft Peach
      '#ff938a', // Muted Salmon
      '#ff707e', // Dusty Rose
      '#b890d9', // Medium Lavender
      '#9cdcdc', // Aqua Blue
      '#e9d8a6', // Sandy Beige
      '#e8a7b1', // Deeper Rose
      '#95c5c5'  // Teal Blue
    ];
    let animation, totalFrames;
    const segments = [];
    let selectedSegmentId = null; // Keep track of the playing segment's ID
    let mainPlaying = false;

    // Get references to elements once
    const mainBtn = document.getElementById('mainPlay');
    const fullSeek = document.getElementById('fullSeek');
    const tooltip = document.getElementById('seekTooltip');
    const segmentsContainer = document.getElementById('segmentsContainer');
    const animationContainer = document.getElementById('animation-container');

    // --- Define Listener Functions ---

    // Listener for manual seeking on the main slider
    const handleSeekInput = (e) => {
      if (!animation) return;
      const f = +e.target.value;
      animation.resetSegments(true);
      animation.goToAndStop(f, true);
      // Optionally update tooltip during manual drag
       updateTooltip(f);
       tooltip.style.opacity = '1'; // Keep tooltip visible while dragging
       tooltip.style.display = 'block';
    };

     // Listener to hide tooltip after manual seek finishes
     const handleSeekChange = () => {
        // Wait a bit, then fade out, then hide
        setTimeout(() => {
            tooltip.style.opacity = '0';
            setTimeout(() => {
            tooltip.style.display = 'none';
            }, 300);
        }, 1500); // Shorter delay after manual change
     };

    // Listener for updating seekbar during FULL animation playback
    const updateSeekOnEnterFrame_Full = () => {
      if (!animation || mainPlaying === false) return; // Only update if main animation is playing
       const currentFrame = Math.floor(animation.currentFrame);
       // Only update if the value actually changes, prevents potential jitter
       if (parseInt(fullSeek.value) !== currentFrame) {
           fullSeek.value = currentFrame;
           // Update tooltip only if it's currently hidden (avoids flicker with manual seek)
           if (tooltip.style.display === 'none') {
               updateTooltip(currentFrame);
           }
       }
    };

    // Listener for updating seekbar during SEGMENT animation playback
    const updateSeekOnEnterFrame_Segment = () => {
      if (!animation || selectedSegmentId === null) return; // Ensure a segment is selected
      const currentSegment = segments.find(s => s.id === selectedSegmentId);
      if (!currentSegment) return;

      // Calculate the global frame based on segment progress
      // Assuming animation.currentFrame is 0-based relative to segment start during playSegments
      const frameWithinSegment = Math.floor(animation.currentFrame);
      const calculatedGlobalFrame = currentSegment.start + frameWithinSegment;

      // Clamp the value to be within the total animation range
      const finalGlobalFrame = Math.min(Math.max(0, calculatedGlobalFrame), totalFrames);

       // Only update if the value actually changes
       if (parseInt(fullSeek.value) !== finalGlobalFrame) {
            fullSeek.value = finalGlobalFrame;
            // Update tooltip only if it's currently hidden
            if (tooltip.style.display === 'none') {
                updateTooltip(finalGlobalFrame);
            }
       }
    };

    // Helper to update tooltip position and text
    function updateTooltip(frame) {
        tooltip.textContent = frame;
        const pct = frame / totalFrames;
        const trackWidth = fullSeek.clientWidth;
        // Adjust position calculation based on thumb width (20px in CSS) and track padding
        const thumbWidth = 20;
        const effectiveTrackWidth = trackWidth - thumbWidth; // Usable track width
        const x = (thumbWidth / 2) + (pct * effectiveTrackWidth); // Center tooltip over thumb center
        tooltip.style.left = `${x}px`;
        // console.log(`Frame: ${frame}, Pct: ${pct}, TrackWidth: ${trackWidth}, X: ${x}`);
    }


    // --- Initialization and Main Logic ---

    window.addEventListener('message', (e) => {
      if (e.data.type === 'lottieData') {
        originalData = e.data.data;
        originalFilename = e.data.filename || 'animation';
        console.log('loaded');
        try {
          if (!originalData || !originalData.v || !originalData.op || !originalData.fr) throw 'Invalid Lottie JSON';
          initAnim(originalData);
          console.log('initiated');
        } catch (err) {
          console.error("Error initializing animation:", err);
          // Handle error display if needed
        }
      }
    });

    function sanitizeName(name) {
        if (!name) return 'segment'; // Handle empty names
        // Replace spaces and common problematic characters with underscores
        // Allow letters, numbers, underscore, hyphen
        return name.trim().replace(/\s+/g, '_').replace(/[^a-z0-9_-]/gi, '');
    }

    mainBtn.onclick = () => {
    if (!animation) return;

    // 1. If a segment was playing/selected, stop and deselect it
    if (selectedSegmentId !== null) {
        const previousButton = document.querySelector(`.play-btn.paused[data-id='${selectedSegmentId}']`);
        if (previousButton) {
            previousButton.classList.remove('paused'); // Deactivate segment button
        }
        animation.pause(); // Pause whatever was playing
        animation.resetSegments(true); // IMPORTANT: Reset segment state
        selectedSegmentId = null; // Deselect the segment
    }

    // 2. Toggle main playback state
    if (mainPlaying) { // If currently playing full animation -> pause it
        animation.pause();
        mainPlaying = false;
    } else { // If currently paused/stopped -> play full animation
        // 3. Ensure correct listeners are active for main playback
        animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment);
        animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full); // Remove first to prevent duplicates
        animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Full);

        fullSeek.removeEventListener('input', handleSeekInput); // Remove first to prevent duplicates
        fullSeek.addEventListener('input', handleSeekInput); // Re-enable manual seek
        fullSeek.removeEventListener('change', handleSeekChange); // Ensure tooltip hiding is active
        fullSeek.addEventListener('change', handleSeekChange);

        // 4. Play the full animation
        animation.loop = true; // Ensure looping for full playback
        animation.resetSegments(true); // Reset again just before playing full
        mainPlaying = true; // Set flag BEFORE playing
        animation.goToAndPlay(0, true); // Play from start
    }

    // 5. Update main button UI
    mainBtn.classList.toggle('paused', mainPlaying);
};


    function initAnim(data) {
      segments.length = 0;
      selectedSegmentId = null;
      mainPlaying = false;
      mainBtn.disabled = false;
      mainBtn.classList.remove('paused'); // Reset button state
      segmentsContainer.innerHTML = '';

      if (animation) {
         // Crucially remove old listeners before destroying
         animation.removeEventListener('DOMLoaded', onDOMLoaded); // Assuming we name the callback
         animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full);
         animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment);
         animation.destroy();
      }

      const playbackData = JSON.parse(JSON.stringify(data));

      animation = lottie.loadAnimation({
        container : animationContainer,
        animationData : playbackData,
        renderer  : 'svg',
        loop      : false,
        autoplay  : false
      });

      // Name the DOMLoaded callback to remove it later if needed
      const onDOMLoaded = () => {
        totalFrames = Math.floor(animation.totalFrames);
        document.getElementById('fullFramesCount').textContent = `${totalFrames} frames`;
        fullSeek.max = totalFrames;
        fullSeek.value = 0;

        // --- Attach Initial Listeners ---
        fullSeek.removeEventListener('input', handleSeekInput); // Clean up just in case
        fullSeek.addEventListener('input', handleSeekInput);
        fullSeek.removeEventListener('change', handleSeekChange); // Clean up tooltip hide listener
        fullSeek.addEventListener('change', handleSeekChange);   // Add tooltip hide listener

        animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full); // Clean up
        animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment); // Clean up
        animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Full); // Default to full update


        // Tooltip visibility on hover/focus for the seek bar
        fullSeek.addEventListener('mouseenter', () => { if (!mainPlaying && selectedSegmentId === null) updateTooltip(fullSeek.value); tooltip.style.display = 'block'; tooltip.style.opacity = '1'; });
        fullSeek.addEventListener('mouseleave', () => { if (tooltip.style.display === 'block') handleSeekChange();}); // Hide after mouse leaves if it was shown
         fullSeek.addEventListener('focus', () => { updateTooltip(fullSeek.value); tooltip.style.display = 'block'; tooltip.style.opacity = '1'; });
         fullSeek.addEventListener('blur', () => { if (tooltip.style.display === 'block') handleSeekChange();}); // Hide after focus leaves if it was shown





        document.getElementById('addSegment').disabled = false;
        document.getElementById('downloadAll').disabled = false;
        if (Array.isArray(data.markers) && data.markers.length > 0) {
            loadMarkers(data.markers);
         } else if (originalData && Array.isArray(originalData.markers) && originalData.markers.length > 0) {
            // Fallback if playbackData somehow lost markers
            loadMarkers(originalData.markers);
         }
         renderSegments(); // Render even if no markers initially
         drawGlobalBar();
      };

      animation.addEventListener('DOMLoaded', onDOMLoaded);
    }


    function loadMarkers(markers) {
      segments.length = 0; // Clear existing before loading
      markers.slice(0, maxSegments).forEach((m, i) => {
        // Adjust for comp inPoint if it exists (often 0, but good practice)
        const compIp = originalData && typeof originalData.ip === 'number' ? originalData.ip : 0;
        const start = Math.max(0, Math.floor(m.tm - compIp));
        const duration = Math.max(1, Math.floor(m.dr));
        // Ensure end doesn't exceed totalFrames (if already known)
        const end = totalFrames ? Math.min(totalFrames, start + duration) : (start + duration);

        // Basic validation
        if (start < end && (!totalFrames || start < totalFrames)) {
             segments.push({ id: Date.now() + i, start, end, name: m.cm || `Marker ${i+1}`, color: segmentColors[segments.length % segmentColors.length] });
        } else {
             console.warn(`Skipping invalid marker: ${m.cm || `Marker ${i+1}`} (tm: ${m.tm}, dr: ${m.dr}) -> start: ${start}, end: ${end}, totalFrames: ${totalFrames}`);
        }

      });
      // Don't render/draw here, wait for DOMLoaded where totalFrames is certain
    }

    document.getElementById('addSegment').onclick = () => {
      if (segments.length >= maxSegments || !totalFrames) return; // Need totalFrames
      const id = Date.now();
      // Default new segment to first 1/4 of animation or minimum duration
      const defaultEnd = Math.max(1, Math.min(totalFrames, Math.floor(totalFrames * 0.25)));
      const seg = { id, start: 0, end: defaultEnd, name: `Segment ${segments.length+1}`, color: segmentColors[segments.length % segmentColors.length] };
      segments.push(seg);

      renderSegments();
      drawGlobalBar();
    };

    function renderSegments() {
        segmentsContainer.innerHTML = ''; // Clear existing
        segments.forEach(seg => {
            // Create segment control element (ensure totalFrames is available)
            if (typeof totalFrames !== 'number') {
                 console.error("Cannot render segments, totalFrames not set.");
                 return;
            }
            const el = document.createElement('div');
            el.className = 'segment-control';
            el.style.borderColor = seg.color; // Use border color for themeing if needed

             // Clamp segment start/end to valid frame range on render
            seg.start = Math.max(0, Math.min(seg.start, totalFrames -1));
            seg.end = Math.max(seg.start + 1, Math.min(seg.end, totalFrames));


            el.innerHTML = `
                <div class="segment-header">
                <div class="segment-info">
                    <input type="text" class="segment-name" data-id="${seg.id}" value="${seg.name}" />
                    <div class="frame-inputs">
                    <input type="number" class="frame-input" data-id="${seg.id}" data-type="start" value="${seg.start}" min="0" max="${totalFrames - 1}" />
                    <input type="number" class="frame-input" data-id="${seg.id}" data-type="end"   value="${seg.end}"   min="1" max="${totalFrames}" />
                    </div>
                </div>
                <div class="segment-handles">
                    <div class="range-container">
                    <div class="range-highlight" id="highlight-${seg.id}" style="background:${seg.color}; border-color:${seg.color};"></div>
                    <input type="range" class="range-input" data-id="${seg.id}" data-type="start" min="0" max="${totalFrames}" value="${seg.start}" />
                    <input type="range" class="range-input" data-id="${seg.id}" data-type="end"   min="0" max="${totalFrames}" value="${seg.end}" />
                    </div>
                </div>
                <div class="segment-actions">
                    <button class="play-btn"     data-id="${seg.id}"></button> <button class="download-btn" data-id="${seg.id}"></button> </div>
                     <button class="close-btn" data-id="${seg.id}" aria-label="Remove segment"></button>
                </div>
            `;
            //segmentsContainer.appendChild(el);
             segmentsContainer.prepend(el);
            updateHighlight(seg); // Update highlight after adding
        });

        // Add event handlers after elements are in the DOM
        attachSegmentHandlers();
    }

     function attachSegmentHandlers() {
         segmentsContainer.querySelectorAll('.segment-name').forEach(input => {
            input.oninput = handleSegmentNameInput; // Use named function
         });
         segmentsContainer.querySelectorAll('.frame-input').forEach(input => {
            input.onchange = handleSegmentFrameInput; // Use named function
         });
         segmentsContainer.querySelectorAll('.range-input').forEach(input => {
            input.oninput = handleSegmentRangeInput; // Use named function
            // Add 'change' listener maybe? To sync number input after drag?
            input.onchange = handleSegmentRangeChange;
         });
         segmentsContainer.querySelectorAll('.play-btn').forEach(btn => {
            btn.onclick = handlePlay; // Use the main handlePlay function
         });
         segmentsContainer.querySelectorAll('.download-btn').forEach(btn => {
            btn.onclick = handleDownload; // Use named function
         });

         /* --- ADD THIS --- */
   segmentsContainer.querySelectorAll('.close-btn').forEach(btn => {
       btn.onclick = handleRemoveSegment; // Attach the new handler
   });
   /* --------------- */

     }

    // --- Event Handlers for Segment Controls ---
     function handleSegmentNameInput(e) {
         const seg = segments.find(s => s.id == e.target.dataset.id);
         if (seg) seg.name = e.target.value;
     }

     function handleSegmentFrameInput(e) {
         const seg = segments.find(s => s.id == e.target.dataset.id);
         if (!seg || !totalFrames) return;
         const type = e.target.dataset.type;
         let val = Math.floor(+e.target.value);

         if (type === 'start') {
             val = Math.max(0, Math.min(val, totalFrames - 1)); // Clamp start frame
             seg.start = Math.min(val, seg.end - 1); // Ensure start < end
         } else { // type === 'end'
             val = Math.max(1, Math.min(val, totalFrames)); // Clamp end frame
             seg.end = Math.max(val, seg.start + 1); // Ensure end > start
         }
         // Ensure values don't cross after clamping
         seg.start = Math.min(seg.start, seg.end - 1);
         seg.end = Math.max(seg.end, seg.start + 1);

         syncSegmentUI(seg); // Update sliders and highlights
         drawGlobalBar(); // Update main bar visualization
     }

     function handleSegmentRangeInput(e) {
       animation.resetSegments(true);
         const seg = segments.find(s => s.id == e.target.dataset.id);
          if (!seg || !totalFrames) return;
         const type = e.target.dataset.type;
         const val = Math.floor(+e.target.value);

         if (type === 'start') {
             seg.start = Math.min(val, seg.end - 1); // Allow temporary overlap during drag
         } else { // type === 'end'
             seg.end = Math.max(val, seg.start + 1);
         }

         // --- ADD THESE LINES ---
         if (animation && val >= 0 && val <= totalFrames) {
             // 1. Update the main seek bar's value
             fullSeek.value = val;

             // 2. Go to the corresponding frame in the animation preview
             animation.goToAndStop(val, true);
             console.log('here');
             // 3. Update and show the tooltip for the main seek bar
             updateTooltip(val);
             tooltip.style.display = 'block'; // Make tooltip visible
             tooltip.style.opacity = '1';    // Ensure it's fully opaque
         }
         // ---------------------



         syncSegmentUI(seg); // Update number inputs and highlights during drag
         // Don't update global bar on every input event, maybe only on 'change'
     }

    function handleSegmentRangeChange(e) {
        // This fires after the user releases the slider thumb
        const seg = segments.find(s => s.id == e.target.dataset.id);
        if (!seg || !totalFrames) return;

        // Final validation and clamping after drag ends
        seg.start = Math.max(0, Math.min(seg.start, totalFrames - 1));
        seg.end = Math.max(seg.start + 1, Math.min(seg.end, totalFrames));
        seg.start = Math.min(seg.start, seg.end - 1); // Final cross-check

        syncSegmentUI(seg); // Ensure final state is synced
        drawGlobalBar(); // Update global bar now

        // If this segment was playing, restart it with new values? Or just stop?
        // For simplicity, let's not automatically restart/stop here.
        // if (selectedSegmentId === seg.id) {
        //    playSeg(seg); // Option: restart playback
        // }
    }


    function syncSegmentUI(seg) {
        // Update range sliders
        document.querySelector(`.range-input[data-id='${seg.id}'][data-type='start']`).value = seg.start;
        document.querySelector(`.range-input[data-id='${seg.id}'][data-type='end']`).value = seg.end;
        // Update number inputs
        document.querySelector(`.frame-input[data-id='${seg.id}'][data-type='start']`).value = seg.start;
        document.querySelector(`.frame-input[data-id='${seg.id}'][data-type='end']`).value = seg.end;
        // Update highlight bar
        updateHighlight(seg);
    }


    // --- Playback Handling ---

    function handlePlay(e) {
        const id = +e.target.dataset.id;
        const segmentButton = e.target;
        const segmentToPlay = segments.find(s => s.id === id);


        if (!segmentToPlay || !animation) return; // Exit if segment or animation not found

        // If main animation is playing, stop it FIRST
        if (mainPlaying) {
            mainBtn.click(); // This handles state update, listener swap, and pausing
        }

        // --- Logic when clicking the button of the ALREADY selected/playing segment ---
        if (selectedSegmentId === id) {
            animation.pause(); // Pause playback

            // Restore default listeners
            animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment);
            animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full); // Clean first
            animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Full);
            fullSeek.removeEventListener('input', handleSeekInput); // Clean first
            fullSeek.addEventListener('input', handleSeekInput);    // Re-enable manual seek
            fullSeek.removeEventListener('change', handleSeekChange); // Re-enable tooltip hide
            fullSeek.addEventListener('change', handleSeekChange);

            selectedSegmentId = null; // Deselect
            segmentButton.classList.remove('paused'); // Update button UI
             // animation.resetSegments(true); // Maybe reset state on pause? Optional.

        // --- Logic when clicking a NEW segment's button (or the first time) ---
        } else {
            // If another segment was active, clean it up first
            if (selectedSegmentId !== null) {
                 animation.pause(); // Pause previous segment
                 animation.resetSegments(true); // Reset lottie state
                 // Deactivate previous button visually
                 const previousButton = document.querySelector(`.play-btn.paused[data-id='${selectedSegmentId}']`);
                 if (previousButton) {
                    previousButton.classList.remove('paused');
                 }
                 // Ensure default listeners are active before switching
                 animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment);
                 animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full);
                 animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Full);
                 fullSeek.removeEventListener('input', handleSeekInput);
                 fullSeek.addEventListener('input', handleSeekInput);
                 fullSeek.removeEventListener('change', handleSeekChange);
                 fullSeek.addEventListener('change', handleSeekChange);
            }

            // Now set up for the new segment
            selectedSegmentId = id;

            // Deactivate all other play buttons visually
            document.querySelectorAll('.segment-actions .play-btn').forEach(btn => {
                if (btn !== segmentButton) {
                    btn.classList.remove('paused');
                }
            });
            segmentButton.classList.add('paused'); // Activate current button

            // Swap to segment-specific listeners
            fullSeek.removeEventListener('input', handleSeekInput); // Disable manual seek
            fullSeek.removeEventListener('change', handleSeekChange); // Disable tooltip hide on change
            animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full);
            animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Segment); // Enable segment update logic

            animation.loop = true; // Segments loop by default in this logic

            playSeg(segmentToPlay); // Play the selected segment
        }
    }

    // Play segment function (remains simple)
    function playSeg(seg) {
      if (!animation) return;
      animation.resetSegments(true);
      console.log(`Playing frames ${seg.start} to ${seg.end}`);
        const addNumber = originalData.ip;

      // Ensure segment bounds are valid before playing
      const safeStart = seg.start + addNumber;
      const safeEnd = seg.end+ addNumber;
        console.log(`Playing frames add number ${safeStart} to ${safeEnd}`);
   // Go to the validated start frame
      animation.playSegments([safeStart, safeEnd], true); // Play the validated segment
    }


    // --- UI Update Functions ---

    function updateHighlight(seg) {
      const hl = document.getElementById(`highlight-${seg.id}`);
      if (hl && typeof totalFrames === 'number' && totalFrames > 0) {
        const startPercent = (seg.start / totalFrames) * 100;
        const widthPercent = ((seg.end - seg.start) / totalFrames) * 100;
        hl.style.left = `${startPercent}%`;
        hl.style.width = `${widthPercent}%`;
      } else if (!hl) {
         console.warn(`Highlight element not found for segment ID: highlight-${seg.id}`);
      }
    }

    function drawGlobalBar() {
      const bar = document.getElementById('globalBar');
      if (!bar || typeof totalFrames !== 'number' || totalFrames <= 0) return;
      bar.innerHTML = ''; // Clear previous divs
      segments.forEach(seg => {
        const d = document.createElement('div');
        d.style.position = 'absolute';
        const startPercent = (seg.start / totalFrames) * 100;
        const widthPercent = ((seg.end - seg.start) / totalFrames) * 100;
        d.style.left = `${startPercent}%`;
        d.style.width = `${widthPercent}%`;
        d.style.height = '100%';
        d.style.background = seg.color;
        d.style.borderRadius = '4px'; // Match track radius
        d.style.pointerEvents = 'none'; // Prevent interaction
        bar.appendChild(d);
      });
    }

    // --- Download Functions ---

    document.getElementById('downloadAll').onclick = () => {
        if (!originalData) return;
        const mod = stripRuntimeFlags(JSON.parse(JSON.stringify(originalData)));
         // Ensure ip exists, default to 0 if not
         const compIp = typeof mod.ip === 'number' ? mod.ip : 0;
        mod.markers = segments.map(s => ({
            cm: s.name,
            tm: s.start + compIp, // Add composition inPoint back for standard marker time
            dr: s.end - s.start
        }));
        let baseFilename = originalFilename.replace(/\.json$/i, '');

          // 2. Get sanitized marker names
          const markerNames = segments.map(s => sanitizeName(s.name)).join('_');

          // 3. Combine parts
          let finalFilename = `${baseFilename}`;
          if (markerNames) { // Only add marker names if there are segments
              finalFilename += `_${markerNames}`;
          }
          finalFilename += '.json'; // Add extension back
          // --- END: Generate New Filename ---


          // --- Use the new filename in the download function ---
          // downloadJSON(mod, 'animation_with_markers.json'); // Old way
          downloadJSON(mod, finalFilename); // New way
    };

    function handleDownload(e) {
        if (!originalData) return;
        const seg = segments.find(s => s.id == e.target.dataset.id);
        if (!seg) return;

        const mod = stripRuntimeFlags(JSON.parse(JSON.stringify(originalData)));

        // Set new inPoint and outPoint for the trimmed animation
        mod.ip = 0; // New animation starts at frame 0 of the segment
        mod.op = seg.end - seg.start; // New animation ends at the duration of the segment

        // Adjust all keyframe times ('t' property) within the layers
        if (Array.isArray(mod.layers)) {
            mod.layers.forEach(layer => {
                adjustKeyframeTimes(layer, seg.start);
            });
        }

        // Optional: Add a single marker relative to the new timeline
        mod.markers = [{ cm: seg.name, tm: 0, dr: seg.end - seg.start }];


        let baseFilename = originalFilename.replace(/\.json$/i, '');

       // 2. Construct the filename using the new format


        // Generate filename, sanitize segment name
        const safeName = seg.name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();

        downloadJSON(mod, `${baseFilename}_${safeName}_${seg.start}_${seg.end}.json`);
    }

     // Recursive function to adjust keyframe times
     function adjustKeyframeTimes(obj, offset) {
         if (!obj || typeof obj !== 'object') {
             return;
         }

         // Adjust 't' property if it exists and is a number (start time for keyframe)
         if (typeof obj.t === 'number') {
             obj.t -= offset;
             // Optional: Clamp to 0 if negative, though should usually align if data is consistent
             // obj.t = Math.max(0, obj.t);
         }

         // Recursively process nested properties/arrays
         for (const key in obj) {
             if (obj.hasOwnProperty(key)) {
                 if (Array.isArray(obj[key])) {
                     obj[key].forEach(item => adjustKeyframeTimes(item, offset));
                 } else if (typeof obj[key] === 'object') {
                     adjustKeyframeTimes(obj[key], offset);
                 }
             }
         }

         // Adjust layer inPoint and outPoint
         if (typeof obj.ip === 'number') {
             obj.ip -= offset;
         }
          if (typeof obj.op === 'number') {
             obj.op -= offset;
         }
          // Optional: Clamp layer ip/op based on new animation duration? More complex.
     }


    function stripRuntimeFlags(obj) {
      if (Array.isArray(obj)) {
        return obj.map(stripRuntimeFlags);
      }
      if (obj && typeof obj === 'object') {
        const out = {};
        for (const [k, v] of Object.entries(obj)) {
          // Keep common properties, remove Lottie-web internal state flags
          if (!k.startsWith('__') && k !== 'live' && k !== 'isFrozen') {
             out[k] = stripRuntimeFlags(v);
          }
        }
        return out;
      }
      return obj; // Primitives
    }

    function downloadJSON(data, filename) {
      try {
          const jsonString = JSON.stringify(data); // Pretty print JSON
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);
      } catch (error) {
          console.error("Failed to stringify or download JSON:", error);
          // Provide user feedback?
      }
    }

    // --- Initial Load ---
    setTimeout(() => {
      if (!originalData) {
        fetch('default.json') // Make sure default.json exists in the same directory
          .then(res => {
             if (!res.ok) {
                 throw new Error(`HTTP error! status: ${res.status}`);
             }
             return res.json();
          })
          .then(data => {
            originalData = data;
            initAnim(data); // Initialize with default data
          })
          .catch(err => console.error('Failed to load default.json:', err));
      }
    }, 300); // Delay slightly to allow potential message listener to receive data first

    function handleRemoveSegment(e) {
    const idToRemove = +e.target.dataset.id;
    const segmentIndex = segments.findIndex(s => s.id === idToRemove);

    if (segmentIndex > -1) {
        // Remove from the JavaScript array
        segments.splice(segmentIndex, 1);

        // Remove the element from the DOM
        const segmentElement = e.target.closest('.segment-control');
        if (segmentElement) {
            segmentElement.remove();
        }

        // If the removed segment was the currently playing one, stop playback
        if (selectedSegmentId === idToRemove) {
            animation.pause();
            animation.resetSegments(true);
            selectedSegmentId = null;
            // Reset main play button if it was paused due to segment play
             mainBtn.classList.remove('paused'); // Assuming mainBtn is accessible
            // Restore default listeners if needed (similar to handlePlay logic)
            animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Segment);
            animation.removeEventListener('enterFrame', updateSeekOnEnterFrame_Full);
            animation.addEventListener('enterFrame', updateSeekOnEnterFrame_Full);
            fullSeek.removeEventListener('input', handleSeekInput);
             fullSeek.addEventListener('input', handleSeekInput);
             fullSeek.removeEventListener('change', handleSeekChange);
             fullSeek.addEventListener('change', handleSeekChange);


        }

        // Redraw the global bar visualization
        drawGlobalBar();

         // Optional: Re-assign colors if you want them to redistribute
         // segments.forEach((seg, i) => seg.color = segmentColors[i % segmentColors.length]);
         // renderSegments(); // Re-render all segments if colors changed (might be overkill)

         // Re-enable add segment button if max was reached
         document.getElementById('addSegment').disabled = segments.length >= maxSegments;


    } else {
        console.warn("Segment to remove not found in data:", idToRemove);
    }
}


  </script>
</body>
</html>
