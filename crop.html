<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lottie Cropper & Expander</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.26/interact.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
  <style>
    /* Basic Reset & Body Setup */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden; /* Prevent body scrollbars */
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: #f0f2f5; /* Slightly different background */
        color: #333;
    }
    body {
      display: flex;
      flex-direction: column; /* Stack controls on top of workspace */
    }

    /* Top Controls Area */
    #top-controls {
        background-color: #ffffff;
        padding: 10px 20px;
        border-bottom: 1px solid #d9d9d9;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center; /* Center controls horizontally */
        align-items: center;
        width: 100%;
        box-sizing: border-box;
        z-index: 100; /* Keep controls on top */
    }

    /* Workspace Area (takes remaining space) */
    #workspace {
        flex-grow: 1; /* Allow workspace to fill available vertical space */
        width: 100%;
        position: relative; /* Needed for absolute positioning of pan-zoom-container */
        overflow: hidden; /* Crucial: hides parts of the panned container */
        cursor: grab; /* Indicate pannable area */
        background-color: #e9ecef; /* Background for the pannable area */
    }
    #workspace:active {
        cursor: grabbing;
    }

    /* Container moved by panning/zooming */
    #pan-zoom-container {
        position: absolute;
        top: 0; /* Initial position */
        left: 0;
        width: auto; /* Size determined by content */
        height: auto;
        /* transition: transform 0.1s linear; */ /* Optional smooth pan */
    }


    /* Wrapper containing the Lottie and crop box (inside pan-zoom) */
    #previewWrapper {
        position: relative; /* Position children relative to this */
        display: none; /* Hidden initially */
        border: 1px dashed #adb5bd;
        box-sizing: border-box;
        background-color: #f8f9fa; /* Slightly different background */
        /* width, height, padding dynamically set by JS */
        /* Scaling applied here */
        transform-origin: top left; /* Scale from top-left (Coordinates are relative to this)*/
        transition: transform 0.3s ease; /* Smooth scale transition */
    }
    /* Container for the actual Lottie animation */
    #lottieContainer {
        position: absolute;
        background: #f8f9fa;
        /* width, height, top, left dynamically set by JS relative to previewWrapper */
    }
    /* The draggable and resizable crop/expand box */
    #cropBox {
      position: absolute;
      border: 2px dashed #007bff;
      background: rgba(0, 123, 255, 0.1);
      touch-action: none; /* Prevent browser default touch actions */
      box-sizing: border-box;
      cursor: move; /* Use 'move' cursor for the crop box */
      /* width, height, top, left dynamically set by JS */
    }

    /* --- Buttons and Controls Styling --- */
    button, input[type="file"]::file-selector-button {
        padding: 8px 15px;
        border: none;
        border-radius: 5px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-size: 0.9rem; /* Slightly smaller font */
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    button:hover, input[type="file"]::file-selector-button:hover {
        background-color: #0056b3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        box-shadow: none;
    }
    input[type="file"] {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 5px;
        font-size: 0.9rem;
    }
    a#downloadLink {
        display: inline-block; /* Correct display type */
        padding: 8px 15px;
        background-color: #28a745;
        color: white;
        text-decoration: none;
        border-radius: 5px;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        font-size: 0.9rem;
    }
     a#downloadLink:hover {
        background-color: #218838;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
     }

    /* Buttons inside preview */
    .preview-buttons {
        position: absolute;
        top: 5px;
        left: 5px;
        z-index: 20; /* Above crop box */
        display: flex;
        gap: 5px;
    }
    .preview-buttons button {
        width: 30px; /* Slightly smaller */
        height: 30px;
        padding: 0;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .preview-buttons button:hover { background: white; }
    .preview-buttons img { width: 18px; height: 18px; opacity: 0.8; }

    /* Resizing handles on the cropBox */
    #cropBox .handle {
      position: absolute;
      width: 10px; /* Smaller handles */
      height: 10px;
      background: #0056b3;
      border: 1px solid white;
      border-radius: 50%;
      box-shadow: 0 0 2px rgba(0,0,0,0.3);
      z-index: 15; /* Above crop box, below preview buttons */
    }
    #cropBox .top-left     { top: -5px; left: -5px; cursor: nwse-resize; }
    #cropBox .top-right    { top: -5px; right: -5px; cursor: nesw-resize; }
    #cropBox .bottom-left  { bottom: -5px; left: -5px; cursor: nesw-resize; }
    #cropBox .bottom-right { bottom: -5px; right: -5px; cursor: nwse-resize; }

    /* Aspect Ratio Overlay */
    #ratioOverlay { /* Styles remain largely the same */
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.6); justify-content: center; align-items: center; z-index: 1000;
    }
    .ratio-form { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: center; }
    .ratio-form h3 { margin-top: 0; margin-bottom: 20px; color: #333; }
    .ratio-input-group { display: flex; gap: 10px; margin: 15px 0 20px 0; align-items: center; justify-content: center; }
    .ratio-input { width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-size: 1rem; }
    .ratio-input-group span { font-size: 1.2rem; font-weight: bold; color: #555; }
    .ratio-buttons { display: flex; gap: 10px; justify-content: center; }
    .ratio-submit, .ratio-cancel { background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s ease; }
    .ratio-cancel { background: #6c757d; }
    .ratio-submit:hover { background: #0056b3; }
    .ratio-cancel:hover { background: #5a6268; }

     /* Responsive adjustments */
     @media (max-width: 768px) {
        #top-controls {
            justify-content: space-around; /* Better spacing on smaller screens */
        }
        button, input[type="file"]::file-selector-button, input[type="file"], a#downloadLink {
            font-size: 0.85rem; /* Smaller font on mobile */
            padding: 6px 10px;
        }
     }
     @media (max-width: 480px) {
        #top-controls {
             flex-direction: column;
             align-items: stretch; /* Make controls full width */
        }
        button, input[type="file"]::file-selector-button, input[type="file"], a#downloadLink {
            width: 100%;
            box-sizing: border-box;
        }
     }

  </style>
</head>
<body>
   <div id="top-controls">


        <button id="increasePaddingBtn" style="display:none;" title="Increase surrounding space by 20%">Increase Padding</button>
        <button id="autoCenterBtn" style="display:none;" title="Center view on content">Auto Center</button>
        <button id="applyBtn" style="display:none;" disabled title="Apply changes and prepare download">Apply Changes & Download</button>
        <a id="downloadLink" style="display:none;" title="Download the modified Lottie JSON">Download Modified JSON</a>
   </div>

   <div id="workspace">
       <div id="pan-zoom-container">
           <div id="previewWrapper">
               <div class="preview-buttons">
                   <button id="centerBtn" title="Center Crop Box on Lottie"><img src="https://img.icons8.com/material-outlined/24/000000/center-of-gravity.png" alt="Center" /></button>
                   <button id="ratioBtn" title="Set Aspect Ratio"><img src="https://img.icons8.com/material-outlined/24/000000/aspect-ratio.png" alt="Aspect Ratio" /></button>
               </div>
               <div id="lottieContainer"></div>
               <div id="cropBox">
                   <div class="handle top-left"></div>
                   <div class="handle top-right"></div>
                   <div class="handle bottom-left"></div>
                   <div class="handle bottom-right"></div>
               </div>
           </div>
       </div>
   </div>


    <div id="ratioOverlay">
      <div class="ratio-form">
        <h3>Set Aspect Ratio</h3>
        <div class="ratio-input-group">
          <input type="number" step="any" min="0.01" class="ratio-input" id="ratioW" placeholder="W">
          <span>:</span>
          <input type="number" step="any" min="0.01" class="ratio-input" id="ratioH" placeholder="H">
        </div>
        <div class="ratio-buttons">
            <button class="ratio-submit" id="applyRatio">Apply Ratio</button>
            <button class="ratio-cancel" id="closeRatio">Cancel</button>
        </div>
      </div>
    </div>


  <script>
    // --- Global Variables ---
    let originalFilename = null;
    let originalJson = null;
    let lottieAnim = null;
    let currentPadding = 50;
    let currentScaleFactor = 1;
    let panX = 0; // Current horizontal pan offset
    let panY = 0; // Current vertical pan offset
    const PADDING_INCREASE_FACTOR = 1.20;
    const SCREEN_MARGIN = 40; // Margin (px) to keep around the preview wrapper when scaling

    // --- DOM Element References ---
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const increasePaddingBtn = document.getElementById('increasePaddingBtn');
    const autoCenterBtn = document.getElementById('autoCenterBtn'); // New button
    const applyBtn = document.getElementById('applyBtn');
    const downloadLink = document.getElementById('downloadLink');
    const topControls = document.getElementById('top-controls'); // Reference to top controls bar
    const workspace = document.getElementById('workspace'); // Pannable area
    const panZoomContainer = document.getElementById('pan-zoom-container'); // Container that moves
    const previewWrapper = document.getElementById('previewWrapper'); // Scaled container
    const lottieContainer = document.getElementById('lottieContainer');
    const cropBox = document.getElementById('cropBox');
    const centerBtn = document.getElementById('centerBtn'); // Centers cropBox on Lottie
    const ratioBtn = document.getElementById('ratioBtn');
    const ratioOverlay = document.getElementById('ratioOverlay');
    const applyRatioBtn = document.getElementById('applyRatio');
    const closeRatioBtn = document.getElementById('closeRatio');
    const ratioWInput = document.getElementById('ratioW');
    const ratioHInput = document.getElementById('ratioH');

    // --- Event Listeners Setup ---

    increasePaddingBtn.addEventListener('click', increasePadding);
    autoCenterBtn.addEventListener('click', autoCenterView); // Listener for new button
    applyBtn.addEventListener('click', handleApplyChanges);
    centerBtn.addEventListener('click', centerCropBox);
    ratioBtn.addEventListener('click', () => ratioOverlay.style.display = 'flex');
    applyRatioBtn.addEventListener('click', applyAspectRatio);
    closeRatioBtn.addEventListener('click', closeRatioOverlay);
    ratioOverlay.addEventListener('click', (e) => {
      if (e.target === ratioOverlay) closeRatioOverlay();
    });
    window.addEventListener('resize', () => {
        if (originalJson) {
            updateWrapperAndContainerSize(originalJson.w, originalJson.h);
            autoCenterView(); // Re-center view on window resize
        }
    });

    // --- Panning Setup ---
    setupPanning(); // Initialize panning listener

    // --- Core Functions ---

    function handleLoadLottie() {
      const file = fileInput.files[0];
      if (!file) { alert('Please select a Lottie JSON file.'); return; }
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const fileContent = e.target.result;
          if (typeof fileContent !== 'string' || fileContent.trim() === '') {
              alert('Error: File is empty or could not be read as text.'); originalJson = null; resetUI(); return;
          }
          const jsonData = JSON.parse(fileContent);
          if (!jsonData || typeof jsonData.w !== 'number' || typeof jsonData.h !== 'number' || !Array.isArray(jsonData.layers)) {
              alert('Invalid Lottie JSON: Missing essential properties.'); originalJson = null; resetUI(); return;
          }
          originalJson = jsonData;
          currentPadding = 50;
          currentScaleFactor = 1;
          panX = 0; // Reset pan on load
          panY = 0;
          initPreview(originalJson);
          autoCenterView(); // Center initially
        } catch (err) {
          console.error("JSON Parsing Error Details:", err);
          let alertMessage = `Error parsing JSON file. ${err.message ? `(${err.message})` : ''}`;
          if (err instanceof SyntaxError) alertMessage += ' Check syntax.';
          alert(alertMessage); originalJson = null; resetUI();
        }
      };
      reader.onerror = () => { alert('Error reading file.'); originalJson = null; resetUI(); };
      reader.readAsText(file);
    }

    function initPreview(data) {
        if (!data) return;
        if (lottieAnim) { lottieAnim.destroy(); lottieAnim = null; }
        lottieContainer.innerHTML = '';

        previewWrapper.style.display = 'block';
        autoCenterBtn.style.display = 'inline-block'; // Show auto-center button
        increasePaddingBtn.style.display = 'inline-block';
        applyBtn.style.display = 'inline-block';
        applyBtn.disabled = false;
        downloadLink.style.display = 'none';
        downloadLink.href = '#';

        updateWrapperAndContainerSize(data.w, data.h);
        const animData = JSON.parse(JSON.stringify(data));
        try {
            lottieAnim = lottie.loadAnimation({ container: lottieContainer, renderer: 'svg', loop: true, autoplay: true, animationData: animData });
        } catch (error) {
            console.error("Lottie Loading Error:", error); alert("Failed to load Lottie animation."); resetUI(); return;
        }
        cropBox.style.width = data.w + 'px';
        cropBox.style.height = data.h + 'px';
        cropBox.style.left = currentPadding + 'px';
        cropBox.style.top = currentPadding + 'px';
        cropBox.dataset.x = currentPadding;
        cropBox.dataset.y = currentPadding;

        // Update pan container position based on current panX/panY
        updatePanContainerPosition();

        setupInteract(); // Setup interact for cropbox
    }

    /**
     * Updates wrapper size, calculates scale, and applies transform.
     * Does NOT change pan position.
     */
    function updateWrapperAndContainerSize(lottieW, lottieH) {
        const targetWrapperWidth = lottieW + currentPadding * 2;
        const targetWrapperHeight = lottieH + currentPadding * 2;
        const availableWidth = window.innerWidth - SCREEN_MARGIN;
        const controlsHeight = topControls ? topControls.offsetHeight : 50; // Default height if not found
        const availableHeight = window.innerHeight - controlsHeight - SCREEN_MARGIN;

        let scaleW = 1;
        let scaleH = 1;
        if (targetWrapperWidth > availableWidth && availableWidth > 0) {
            scaleW = availableWidth / targetWrapperWidth;
        }
         if (targetWrapperHeight > availableHeight && availableHeight > 0) {
             scaleH = availableHeight / targetWrapperHeight;
         }
        const oldScaleFactor = currentScaleFactor; // Store old scale before updating
        currentScaleFactor = Math.min(scaleW, scaleH, 1); // Use the smaller scale factor, max 1

        // Set unscaled dimensions
        previewWrapper.style.width = targetWrapperWidth + 'px';
        previewWrapper.style.height = targetWrapperHeight + 'px';
        previewWrapper.style.padding = currentPadding + 'px';

        // Apply scaling transform
        previewWrapper.style.transformOrigin = 'top left'; // Keep origin top-left for coordinate consistency
        previewWrapper.style.transform = `scale(${currentScaleFactor})`;

        // Lottie container uses unscaled dimensions relative to wrapper
        lottieContainer.style.width = lottieW + 'px';
        lottieContainer.style.height = lottieH + 'px';
        lottieContainer.style.left = currentPadding + 'px';
        lottieContainer.style.top = currentPadding + 'px';

        // Return the change in scale factor if needed for pan adjustment
        return currentScaleFactor / oldScaleFactor;
    }

    /**
     * Applies the current panX and panY to the pan-zoom container.
     */
    function updatePanContainerPosition() {
        panZoomContainer.style.left = `${panX}px`;
        panZoomContainer.style.top = `${panY}px`;
    }

    /**
     * Increases padding and updates layout, keeping visual center.
     */
    function increasePadding() {
        if (!originalJson) return;

        // --- Store old state ---
        const oldPadding = currentPadding;
        const oldScaleFactor = currentScaleFactor;
        // Get dimensions BEFORE padding/scale change
        const oldUnscaledWidth = previewWrapper.offsetWidth;
        const oldUnscaledHeight = previewWrapper.offsetHeight;
        const oldScaledWidth = oldUnscaledWidth * oldScaleFactor;
        const oldScaledHeight = oldUnscaledHeight * oldScaleFactor;
        const oldPanX = panX;
        const oldPanY = panY;

        // --- Apply padding increase ---
        currentPadding = Math.round(currentPadding * PADDING_INCREASE_FACTOR);
        const deltaPadding = currentPadding - oldPadding;

        // --- Update wrapper size and get NEW scale factor ---
        updateWrapperAndContainerSize(originalJson.w, originalJson.h); // This updates currentScaleFactor

        // --- Adjust cropBox position relative to unscaled wrapper ---
        const currentCropX = parseFloat(cropBox.dataset.x || 0);
        const currentCropY = parseFloat(cropBox.dataset.y || 0);
        const newCropX = currentCropX + deltaPadding;
        const newCropY = currentCropY + deltaPadding;
        cropBox.style.left = newCropX + 'px';
        cropBox.style.top = newCropY + 'px';
        cropBox.dataset.x = newCropX;
        cropBox.dataset.y = newCropY;

        // --- Recalculate pan to keep visual center stationary ---
        // Get the NEW scaled dimensions
        const newScaledWidth = previewWrapper.offsetWidth * currentScaleFactor;
        const newScaledHeight = previewWrapper.offsetHeight * currentScaleFactor;

        // Calculate the required pan shift to compensate for size/scale change
        // This keeps the center point in the same visual position relative to the workspace
        const panShiftX = (oldScaledWidth - newScaledWidth) / 2;
        const panShiftY = (oldScaledHeight - newScaledHeight) / 2;

        // Apply the shift to the old pan position
        panX = oldPanX + panShiftX;
        panY = oldPanY + panShiftY;


        // --- Clamp and apply pan ---
        clampPanPosition();
        updatePanContainerPosition(); // Apply the corrected pan
    }


    /**
     * Centers the cropBox over the Lottie container (within previewWrapper).
     */
    function centerCropBox() {
        if (!originalJson) return;
        const boxW = cropBox.offsetWidth;
        const boxH = cropBox.offsetHeight;
        const containerOffsetX = currentPadding;
        const containerOffsetY = currentPadding;
        const centerX = containerOffsetX + (originalJson.w - boxW) / 2;
        const centerY = containerOffsetY + (originalJson.h - boxH) / 2;
        cropBox.style.left = centerX + 'px';
        cropBox.style.top = centerY + 'px';
        cropBox.dataset.x = centerX;
        cropBox.dataset.y = centerY;
    }

    /**
     * Centers the previewWrapper within the workspace view.
     */
    function autoCenterView() {
        if (!previewWrapper.style.display || previewWrapper.style.display === 'none') return;

        const workspaceWidth = workspace.clientWidth;
        const workspaceHeight = workspace.clientHeight;

        // Get the scaled dimensions of the preview wrapper
        const scaledWrapperWidth = previewWrapper.offsetWidth * currentScaleFactor;
        const scaledWrapperHeight = previewWrapper.offsetHeight * currentScaleFactor;

        // Calculate desired top-left corner for centering
        panX = (workspaceWidth - scaledWrapperWidth) / 2;
        panY = (workspaceHeight - scaledWrapperHeight) / 2;

        // Apply the new pan position
        updatePanContainerPosition();
    }

    /**
     * Prevents panning too far away from the content.
     * Corrected logic for clamping.
     */
    function clampPanPosition() {
         const workspaceWidth = workspace.clientWidth;
         const workspaceHeight = workspace.clientHeight;
         const scaledWrapperWidth = previewWrapper.offsetWidth * currentScaleFactor;
         const scaledWrapperHeight = previewWrapper.offsetHeight * currentScaleFactor;

         let minX, maxX, minY, maxY;

         if (scaledWrapperWidth <= workspaceWidth) {
             // Content is narrower than workspace: Clamp between 0 and the right edge space
             minX = 0;
             maxX = workspaceWidth - scaledWrapperWidth;
         } else {
             // Content is wider than workspace: Clamp between the left edge space and 0
             minX = workspaceWidth - scaledWrapperWidth;
             maxX = 0;
         }

         if (scaledWrapperHeight <= workspaceHeight) {
             // Content is shorter than workspace: Clamp between 0 and the bottom edge space
             minY = 0;
             maxY = workspaceHeight - scaledWrapperHeight;
         } else {
             // Content is taller than workspace: Clamp between the top edge space and 0
             minY = workspaceHeight - scaledWrapperHeight;
             maxY = 0;
         }

         // Apply clamps
         panX = Math.max(minX, Math.min(panX, maxX));
         panY = Math.max(minY, Math.min(panY, maxY));
    }


     function applyAspectRatio() {
         const w = parseFloat(ratioWInput.value);
         const h = parseFloat(ratioHInput.value);
         if (!w || !h || w <= 0 || h <= 0) { alert('Invalid ratio.'); return; }
         const targetRatio = w / h;
         const currentWidth = cropBox.offsetWidth;
         const currentHeight = cropBox.offsetHeight;
         const currentX = parseFloat(cropBox.dataset.x || 0);
         const currentY = parseFloat(cropBox.dataset.y || 0);
         let newWidth, newHeight;
         if (currentWidth / currentHeight > targetRatio) {
             newWidth = currentHeight * targetRatio; newHeight = currentHeight;
         } else {
             newHeight = currentWidth / targetRatio; newWidth = currentWidth;
         }
         const wrapperWidth = parseFloat(previewWrapper.style.width) || previewWrapper.offsetWidth;
         const wrapperHeight = parseFloat(previewWrapper.style.height) || previewWrapper.offsetHeight;
         if (newWidth > wrapperWidth) { newWidth = wrapperWidth; newHeight = newWidth / targetRatio; }
         if (newHeight > wrapperHeight) { newHeight = wrapperHeight; newWidth = newHeight * targetRatio; }
         const deltaW = currentWidth - newWidth;
         const deltaH = currentHeight - newHeight;
         let newX = currentX + deltaW / 2;
         let newY = currentY + deltaH / 2;
         newX = Math.max(0, Math.min(newX, wrapperWidth - newWidth));
         newY = Math.max(0, Math.min(newY, wrapperHeight - newHeight));
         cropBox.style.width = Math.round(newWidth) + 'px';
         cropBox.style.height = Math.round(newHeight) + 'px';
         cropBox.style.left = Math.round(newX) + 'px';
         cropBox.style.top = Math.round(newY) + 'px';
         cropBox.dataset.x = newX;
         cropBox.dataset.y = newY;
         closeRatioOverlay();
     }

     function closeRatioOverlay() {
        ratioOverlay.style.display = 'none';
        ratioWInput.value = ''; ratioHInput.value = '';
     }

     function resetUI() {
        previewWrapper.style.display = 'none';
        previewWrapper.style.transform = 'none';
        autoCenterBtn.style.display = 'none';
        increasePaddingBtn.style.display = 'none';
        applyBtn.style.display = 'none';
        applyBtn.disabled = true;
        downloadLink.style.display = 'none';
        downloadLink.href = '#';
        if (lottieAnim) { lottieAnim.destroy(); lottieAnim = null; }
        lottieContainer.innerHTML = '';
        originalJson = null;
        currentPadding = 50;
        currentScaleFactor = 1;
        panX = 0;
        panY = 0;
        updatePanContainerPosition(); // Reset pan visually
     }

     /**
      * Sets up Interact.js listener for panning the workspace.
      */
     function setupPanning() {
         interact(workspace).draggable({
             listeners: {
                 start(event) {
                     // Only start panning if the drag didn't start on the cropBox or its handles
                     if (event.target === workspace || event.target === panZoomContainer || event.target === previewWrapper || event.target === lottieContainer) {
                         workspace.style.cursor = 'grabbing';
                     } else {
                         return false; // Prevents this draggable from taking over
                     }
                 },
                 move(event) {
                    // Check again if panning should proceed
                     if (event.target !== workspace && event.target !== panZoomContainer && event.target !== previewWrapper && event.target !== lottieContainer) {
                         return;
                     }
                     panX += event.dx;
                     panY += event.dy;
                     updatePanContainerPosition();
                 },
                 end(event) {
                     workspace.style.cursor = 'grab';
                     clampPanPosition(); // Clamp after panning stops
                     updatePanContainerPosition();
                 }
             },
             allowFrom: ':not(#cropBox, #cropBox *)' // Prevent starting pan on cropBox/handles
         });
     }


    /**
     * Sets up Interact.js for cropBox dragging/resizing.
     */
    function setupInteract() {
        let startX, startY, startWidth, startHeight, startRatio;
        let wasSymmetricalCornerResize = false;

        interact(cropBox)
          .draggable({
            listeners: {
              move(event) {
                const target = event.target;
                const dx = event.dx / currentScaleFactor;
                const dy = event.dy / currentScaleFactor;
                const x = (parseFloat(target.dataset.x) || 0) + dx;
                const y = (parseFloat(target.dataset.y) || 0) + dy;
                target.style.left = x + 'px';
                target.style.top  = y + 'px';
                target.dataset.x = x;
                target.dataset.y = y;
              }
            },
            modifiers: [
              interact.modifiers.restrictRect({ restriction: 'parent', endOnly: false })
            ]
          })
          .resizable({
            edges: { left: true, right: true, top: true, bottom: true },
            listeners: {
              start(event) {
                  const target = event.target;
                  startX = parseFloat(target.dataset.x) || 0;
                  startY = parseFloat(target.dataset.y) || 0;
                  startWidth = target.offsetWidth;
                  startHeight = target.offsetHeight;
                  startRatio = startHeight !== 0 ? startWidth / startHeight : 1;
                  wasSymmetricalCornerResize = false;
              },
              move(event) {
                const target = event.target;
                let x = startX;
                let y = startY;
                let width = event.rect.width / currentScaleFactor;
                let height = event.rect.height / currentScaleFactor;
                const dw = width - startWidth;
                const dh = height - startHeight;
                const isCorner = event.edges.left && event.edges.top || event.edges.right && event.edges.top || event.edges.left && event.edges.bottom || event.edges.right && event.edges.bottom;

                if (event.ctrlKey) {
                    wasSymmetricalCornerResize = false;
                    if (event.edges.left) { x = startX - dw; }
                    if (event.edges.top) { y = startY - dh; }
                } else {
                    if (isCorner) {
                        wasSymmetricalCornerResize = true;
                        if (Math.abs(dw) > Math.abs(dh * startRatio)) { height = width / startRatio; } else { width = height * startRatio; }
                    } else { wasSymmetricalCornerResize = false; }
                    const finalDw = width - startWidth; const finalDh = height - startHeight;
                    x = startX - finalDw / 2; y = startY - finalDh / 2;
                }
                target.style.width = width + 'px'; target.style.height = height + 'px';
                target.style.left = x + 'px'; target.style.top = y + 'px';
                target.dataset.x = x; target.dataset.y = y;
              },
              end(event) {
                const target = event.target;
                let finalX = parseFloat(target.dataset.x); let finalY = parseFloat(target.dataset.y);
                let finalWidth = target.offsetWidth; let finalHeight = target.offsetHeight;
                const wrapperWidth = parseFloat(previewWrapper.style.width) || previewWrapper.offsetWidth;
                const wrapperHeight = parseFloat(previewWrapper.style.height) || previewWrapper.offsetHeight;
                let needsCorrection = false; const minSize = 20;

                if (finalX < 0) { finalX = 0; needsCorrection = true; }
                if (finalY < 0) { finalY = 0; needsCorrection = true; }
                if (finalWidth < minSize) { finalWidth = minSize; needsCorrection = true; }
                if (finalHeight < minSize) { finalHeight = minSize; needsCorrection = true; }
                if (finalX + finalWidth > wrapperWidth) { finalWidth = wrapperWidth - finalX; if (finalWidth < minSize) { finalWidth = minSize; finalX = wrapperWidth - minSize; } needsCorrection = true; }
                if (finalY + finalHeight > wrapperHeight) { finalHeight = wrapperHeight - finalY; if (finalHeight < minSize) { finalHeight = minSize; finalY = wrapperHeight - minSize; } needsCorrection = true; }
                if (finalX < 0) { finalX = 0; needsCorrection = true; }
                if (finalY < 0) { finalY = 0; needsCorrection = true; }

                if (needsCorrection && wasSymmetricalCornerResize && startRatio > 0 && finalHeight > 0) { // Added finalHeight > 0 check
                    const currentRatio = finalWidth / finalHeight; const tolerance = 0.01;
                    if (Math.abs(currentRatio - startRatio) > tolerance) {
                        let potentialWidth = finalHeight * startRatio; let potentialHeight = finalWidth / startRatio;
                        if (potentialHeight >= minSize && potentialHeight <= wrapperHeight - finalY) { finalHeight = potentialHeight; }
                        else if (potentialWidth >= minSize && potentialWidth <= wrapperWidth - finalX) { finalWidth = potentialWidth; }
                    }
                }

                if (needsCorrection) {
                    finalWidth = Math.max(minSize, finalWidth); finalHeight = Math.max(minSize, finalHeight);
                    finalX = Math.max(0, Math.min(finalX, wrapperWidth - finalWidth));
                    finalY = Math.max(0, Math.min(finalY, wrapperHeight - finalHeight));
                    target.style.width = finalWidth + 'px'; target.style.height = finalHeight + 'px';
                    target.style.left = finalX + 'px'; target.style.top = finalY + 'px';
                    target.dataset.x = finalX; target.dataset.y = finalY;
                }
                wasSymmetricalCornerResize = false;
              }
            },
          });
    }

    /**
     * Applies changes and prepares download.
     */
    function handleApplyChanges() {
      if (!originalJson) { alert('No Lottie loaded.'); return; }
      const data = JSON.parse(JSON.stringify(originalJson));
      const containerWidth = parseFloat(lottieContainer.style.width) || lottieContainer.offsetWidth;
      const containerHeight = parseFloat(lottieContainer.style.height) || lottieContainer.offsetHeight;
      if (containerWidth <= 0 || containerHeight <= 0) { console.error("Lottie container zero dimensions."); alert("Error applying changes."); return; }
      const cropBoxX = parseFloat(cropBox.dataset.x || 0);
      const cropBoxY = parseFloat(cropBox.dataset.y || 0);
      const cropBoxWidth = cropBox.offsetWidth;
      const cropBoxHeight = cropBox.offsetHeight;
      const scaleX = originalJson.w / containerWidth;
      const scaleY = originalJson.h / containerHeight;
      const offsetX = (cropBoxX - currentPadding) * scaleX;
      const offsetY = (cropBoxY - currentPadding) * scaleY;
      const newWidth = cropBoxWidth * scaleX;
      const newHeight = cropBoxHeight * scaleY;
      addNullParent(data);
      if (data.layers[0]?.ks?.p) { data.layers[0].ks.p.k = [-offsetX, -offsetY, 0]; }
      else { console.error("Null parent missing."); alert("Error applying changes."); return; }
      data.w = Math.round(newWidth); data.h = Math.round(newHeight);
      const modifiedJsonString = JSON.stringify(data);
      const blob = new Blob([modifiedJsonString], { type: 'application/json' });
      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { URL.revokeObjectURL(downloadLink.href); }
      downloadLink.href = URL.createObjectURL(blob);
      /*const originalFileName = fileInput.files[0]?.name.replace(/\.json$/i, '') || 'lottie';*/
      downloadLink.download = originalFileName;
      downloadLink.style.display = 'inline-block';
      downloadLink.textContent = `Download ${downloadLink.download}`;
    }

    /**
     * Adds or verifies the null parent layer.
     */
    function addNullParent(data) {
      if (!data || !Array.isArray(data.layers)) { console.error("Invalid data."); return; }
      if (data.layers.length === 0) return;
      const nullName = 'CROPPER_ROOT_NULL';
      if (data.layers[0].ty === 3 && data.layers[0].nm === nullName) {
         const parentIndex = data.layers[0].ind;
         for (let i = 1; i < data.layers.length; i++) { if (typeof data.layers[i].parent === 'undefined') { data.layers[i].parent = parentIndex; } }
         return;
      }
      let maxIndex = 0;
      data.layers.forEach(l => { if (typeof l.ind === 'number' && l.ind > maxIndex) maxIndex = l.ind; });
      const nullIndex = maxIndex + 1;
      const nullLayer = {
        ddd: 0, ind: nullIndex, ty: 3, nm: nullName, sr: 1,
        ks: { a: { a: 0, k: [0, 0, 0] }, p: { a: 0, k: [0, 0, 0] }, s: { a: 0, k: [100, 100, 100] }, r: { a: 0, k: 0 }, o: { a: 0, k: 100 } },
        ao: 0, ip: data.ip ?? 0, op: data.op ?? 9999, st: data.st ?? 0, bm: 0
      };
      data.layers.unshift(nullLayer);
      for (let i = 1; i < data.layers.length; i++) { if (typeof data.layers[i].parent === 'undefined') { data.layers[i].parent = nullIndex; } }
    }


function loadReceivedLottie(jsonData, filename) {

    try {

      // --- Keep the rest of the logic from here ---
      if (!jsonData || typeof jsonData.w !== 'number' || typeof jsonData.h !== 'number' || !Array.isArray(jsonData.layers)) {
          alert('Invalid Lottie JSON received: Missing essential properties.'); originalJson = null; resetUI(); return;
      }
      console.log('recieved' + filename);
      originalFileName = filename;
      originalJson = jsonData;
      currentPadding = 50;
      currentScaleFactor = 1;
      panX = 0; // Reset pan on load
      panY = 0;
      initPreview(originalJson);
      autoCenterView(); // Center initially
      // --- End of kept logic ---

    } catch (err) {
      console.error("JSON Processing Error Details:", err);
      let alertMessage = `Error processing received Lottie data. ${err.message ? `(${err.message})` : ''}`;
      alert(alertMessage); originalJson = null; resetUI();
    }

}




    window.addEventListener('message', (event) => {
    // Optional: Add origin check for security in production
    // if (event.origin !== 'expected_origin_of_index.html') {
    //     console.warn('Message received from unexpected origin:', event.origin);
    //     return;
    // }

    if (event.data && event.data.type === 'lottieData') {
        console.log('Lottie data received from parent:', event.data.data);
        console.log(event.data.filename);
        // Call the modified function to load the received data
        loadReceivedLottie(event.data.data, event.data.filename);
    } else {
        console.log('Received non-Lottie message or invalid data:', event.data);
    }
});


  </script>
</body>
</html>
