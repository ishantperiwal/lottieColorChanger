<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottie Asset Replacer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
    body {
       font-family: 'Inter', sans-serif;
    }
    #assetListContainer::-webkit-scrollbar {
       display: none;
    }
    #assetListContainer {
       -ms-overflow-style: none;
       scrollbar-width: none;
    }
    .asset-item {
       min-height: 110px;
       transition: background-color 0.2s ease, border-color 0.2s ease;
    }

    .asset-item-selected {
        background-color: #bfdbfe; /* Tailwind blue-200 */
        border-color: #60a5fa !important; /* Tailwind blue-400 */
    }

    .sequence-checkbox-container {
        align-items: center;
        padding-right: 0.75rem; /* pr-3 */
        flex-shrink: 0;
    }

    /* Custom circular checkbox styling */
    .asset-sequence-checkbox {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        width: 1.25rem; /* 20px */
        height: 1.25rem; /* 20px */
        border-radius: 9999px; /* rounded-full */
        border: 2px solid #9ca3af; /* gray-400 */
        background-color: white;
        cursor: pointer;
        position: relative;
        outline: none;
        transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .asset-sequence-checkbox:checked {
        background-color: #3b82f6; /* blue-500 */
        border-color: #3b82f6; /* blue-500 */
    }
    .asset-sequence-checkbox:checked::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0.375rem; /* 6px */
        height: 0.625rem; /* 10px */
        border: solid white;
        border-width: 0 2px 2px 0;
        transform: translate(-50%, -60%) rotate(45deg); /* Adjust for checkmark centering */
    }


    .preview-image-container {
       cursor: pointer;
       border: 2px dotted #cbd5e1;
       transition: border-color 0.2s ease, background-color 0.2s ease, border-style 0.2s ease;
       border-radius: 0.375rem;
       position: relative;
       width: 100px;
       height: 100px;
       display: flex;
       align-items: center;
       justify-content: center;
       background-color: #f8fafc;
       overflow: hidden;
       flex-shrink: 0;
    }
    .preview-image-container:hover {
       border-color: #94a3b8;
       background-color: #f1f5f9;
    }
    .preview-image-container.drag-over {
       border-color: #2563eb;
       border-style: solid;
       background-color: rgba(59, 130, 246, 0.15);
    }
    .preview-image-max-height {
       max-width: 100%;
       max-height: 100%;
       object-fit: contain;
       display: block;
    }

    .asset-info-text {
       white-space: normal; overflow: visible; text-overflow: clip;
       line-height: 1.4; font-size: 0.875rem;
    }
    .asset-info-text .asset-name {
       font-weight: 600; font-size: 1rem; display: block;
       margin-bottom: 0.125rem; word-break: break-all;
    }
    .asset-info-text .asset-details {
       font-size: 0.75rem; color: #4b5563;
    }
    .size-mismatch-warning {
        color: #ef4444; /* Tailwind red-500 */
        font-weight: 500;
        margin-left: 0.25rem; /* ml-1 */
    }
    .hidden-file-input { display: none; }

    .asset-id-pill {
       position: absolute; top: 6px; right: 6px;
       background-color: rgba(0, 0, 0, 0.7); color: white;
       padding: 2px 8px; font-size: 0.6rem; border-radius: 0.75rem;
       z-index: 10; line-height: 1; font-weight: 600; text-transform: uppercase;
    }
    .asset-controls-container {
       display: flex; align-items: center;
       gap: 0.5rem; margin-top: 0.5rem;
    }
    .icon-button {
       background-color: #f3f4f6; border: 1px solid #d1d5db; color: #6b7280;
       width: 2rem; height: 2rem; border-radius: 0.375rem;
       display: flex; align-items: center; justify-content: center;
       cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, opacity 0.2s ease;
    }
    .icon-button:hover:not(:disabled) { background-color: #e5e7eb; border-color: #9ca3af; }
    .icon-button.active { background-color: #bfdbfe; color: #2563eb; border-color: #3b82f6; }
    .icon-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .icon-button svg { width: 1rem; height: 1rem; }

    .lottie-preview-wrapper {
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }
    #lottiePreview {
        border-bottom-left-radius: 0 !important; border-bottom-right-radius: 0 !important;
        border-bottom: none !important;
    }
    .preview-buttons-bar {
        background-color: white; padding: 1rem;
        display: flex; justify-content: space-between; align-items: center;
        border-top: 1px solid #e5e7eb;
    }

    .action-button-group { /* For grouping download buttons */
        display: flex;
        gap: 0.75rem; /* space between download buttons */
    }

    #downloadLottie, #downloadAllAssetsButton { /* Shared styles for download buttons */
        width: 2.5rem; height: 2.5rem;
        color: white;
        border-radius: 50%; padding: 0; display: flex; align-items: center; justify-content: center;
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        transition: background-color 0.2s ease, transform 0.1s ease;
    }
    #downloadLottie { background-color: #10b981; /* emerald-500 */ }
    #downloadLottie:hover:not(:disabled) { background-color: #059669; /* emerald-600 */ transform: scale(1.05); }
    #downloadLottie:active:not(:disabled) { transform: scale(0.98); }

    #downloadAllAssetsButton { background-color: #6366f1; /* indigo-500 */ }
    #downloadAllAssetsButton:hover:not(:disabled) { background-color: #4f46e5; /* indigo-600 */ transform: scale(1.05); }
    #downloadAllAssetsButton:active:not(:disabled) { transform: scale(0.98); }

    #downloadLottie:disabled, #downloadAllAssetsButton:disabled {
        background-color: #9ca3af; /* gray-400 */
        opacity: 0.7; cursor: not-allowed;
    }
    #downloadLottie svg, #downloadAllAssetsButton svg { width: 1.25rem; height: 1.25rem; }


    #replaceSequenceContainer { display: flex; align-items: center; gap: 0.5rem; }
    .sequence-button {
        padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        display: flex; align-items: center; gap: 0.5rem;
        box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        flex-shrink: 0;
    }
    .sequence-button:disabled { opacity: 0.6; cursor: not-allowed; }
    #replaceSequenceButton { background-color: #3b82f6; color: white; border: 1px solid transparent; border-radius: 999px; }
    #replaceSequenceButton:hover:not(:disabled) { background-color: #2563eb; border-radius: 999px;}
    #browseSequenceFilesButton { background-color: #059669; color: white; border: 1px solid transparent; border-radius: 999px;}
    #browseSequenceFilesButton:hover:not(:disabled) { background-color: #047857; }
    #cancelSequenceButton {
        background-color: #ef4444; color: white; border: 1px solid transparent;
        padding: 0.5rem; width: auto; height: auto; justify-content: center;
border-radius: 999px;
    }
    #cancelSequenceButton:hover:not(:disabled) { background-color: #dc2626; }
    #cancelSequenceButton svg { width: 1.25rem; height: 1.25rem; }

    #assetListOuterContainer { position: relative; }
    .scroll-indicator {
        position: absolute; left: 50%; transform: translateX(-50%);
        background-color: rgba(0,0,0,0.6); color: white; padding: 0.25rem 0.75rem;
        border-radius: 9999px; font-size: 0.75rem; cursor: pointer; z-index: 15;
        opacity: 0; transition: opacity 0.3s ease-in-out; pointer-events: none;
    }
    .scroll-indicator.visible { opacity: 1; pointer-events: auto; }
    #scrollUpIndicator { top: 0.5rem; }
    #scrollDownIndicator { bottom: 0.5rem; }

    #assetListContainer { padding: 0 !important; border: none !important; background-color: transparent !important; }
    #lottieFileWrapper.hidden-if-data-received { display: none !important; }

    .tooltip-base {
        position: fixed; bottom: 1.5rem; left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center; gap: 0.75rem;
        color: white; font-size: 0.875rem; /* text-sm */ padding: 0.75rem 1rem; /* py-3 px-4 */
        border-radius: 1.8rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
        z-index: 50;
        opacity: 0; pointer-events: none;
        transition: opacity 0.3s ease-in-out;
	height: 40px;
padding-right: 0.4rem;
padding-left: 0.6rem;
    }
    .tooltip-base.visible { opacity: 1; pointer-events: auto; }

    #sequenceTooltip {
        background-color: #1f2937; /* Tailwind gray-800 */
    }
    #sequenceErrorTooltip {
        background-color: #fef2f2; /* Tailwind red-50 */
        color: #991b1b; /* Tailwind red-800 */
        border: 1px solid #fecaca; /* Tailwind red-300 */
    }
     #sequenceErrorTooltip .replace-anyway-button {
        background-color: #dc2626; /* Tailwind red-600 */
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 1.375rem;
        font-size: 0.75rem;
        font-weight: 500;
    width: 130px;
    height: 30px;
        transition: background-color 0.2s ease;
    }
    #sequenceErrorTooltip .replace-anyway-button:hover {
        background-color: #fef2f2;
    color: #991b1b;
    border: 1px solid #fecaca;
    width: 60%;
    padding: 24px;
    padding-right: 12px;
    }
    .selection-counter-pill {
        background-color: #3b82f6; /* Tailwind blue-500 */
        color: white;
        padding: 0.125rem 0.5rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 500;
    }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="text-gray-800 flex flex-col items-center p-4 selection:bg-sky-500 selection:text-white" style="background:#f5f5f5; height: 100vh; padding-top:0;">

    <div class="rounded-xl p-6 md:p-8 w-full max-w-4xl" style="padding-top: 40px;">
        <div id="lottieFileWrapper" class="mb-6">
            <label for="lottieFile" class="block mb-2 text-sm font-medium text-sky-700">Upload Lottie JSON File</label>
            <input type="file" id="lottieFile" accept=".json" class="block w-full text-sm text-gray-700
                file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold
                file:bg-sky-500 file:text-white hover:file:bg-sky-600
                cursor-pointer focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
        </div>

        <div class="lottie-preview-wrapper mb-6">
            <div id="lottiePreview" class="w-full h-64 md:h-80 lg:h-96 bg-gray-200 rounded-t-xl flex items-center justify-center text-gray-500 text-sm border border-gray-300">
                Upload a Lottie file or wait for data from parent.
            </div>
            <div class="preview-buttons-bar">
                <div id="replaceSequenceContainer">
                    <button id="replaceSequenceButton" class="sequence-button" title="Replace a sequence of assets" disabled>
    <img src="assets/sequence.svg" alt="Replace Sequence" class="w-5 h-5">
    <span style="margin-bottom: 1px;">Select Sequence</span>
</button>
                 <button id="browseSequenceFilesButton" class="sequence-button hidden" title="Choose multiple files">
    <img src="assets/multifiles.svg" alt="Choose multiple files" class="w-5 h-5">
    <span id="browseSequenceFilesButtonText" style="margin-bottom: 1px;">Replace Selected</span>
</button>
                    <button id="cancelSequenceButton" class="sequence-button hidden" title="Cancel sequence replacement">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="action-button-group">
                    <button id="downloadAllAssetsButton" title="Download All Assets as ZIP" disabled>
    <img src="assets/zip.svg" alt="Download ZIP" class="w-5 h-5">
</button>
                    <button id="downloadLottie" title="Download Modified Lottie" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.129V2.75z" />
                            <path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <input type="file" id="multipleFilesInput" multiple class="hidden-file-input" accept="image/png, image/jpeg, image/gif, image/webp, image/svg+xml">

        <div id="assetListOuterContainer">
            <div id="assetListContainer" class="max-h-200 overflow-y-auto">
                <div id="assetList" class="grid grid-cols-1 sm:grid-cols-2 gap-4" ></div>
                <p class="text-gray-500 text-sm hidden text-center py-4" id="noAssetsMessage">No image assets found or Lottie file not loaded.</p>
            </div>
            <div id="scrollUpIndicator" class="scroll-indicator">Scroll Up &uarr;</div>
            <div id="scrollDownIndicator" class="scroll-indicator">Scroll Down &darr;</div>
        </div>
    </div>

     <div id="sequenceTooltip" class="tooltip-base">

        <span id="selectionCounterPill" class="selection-counter-pill">0 Selected</span>
        <span style="margin-bottom: 1px;">Please select the first and the last image of your sequence</span>   <button id="closeSequenceTooltipButton" aria-label="Close sequence selection" title="Cancel sequence selection"
    style="display: flex; align-items: center; justify-content: center; width: 1.5rem; height: 1.5rem;
    border-radius: 9999px; background-color: #ef4444; color: white; cursor: pointer; margin-right: 0.15rem;
    flex-shrink: 0; border: none; padding: 0;">
    <img src="assets/close.svg" alt="Close" style="width: 0.875rem; height: 0.875rem;">
</button>
    </div>

    <div id="sequenceErrorTooltip" class="tooltip-base">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-red-500">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
        </svg>
        <span id="sequenceErrorText">Please ensure the number of selections is equal to the number of assets selected.</span>
        <button id="replaceAnywayButton" class="replace-anyway-button ml-auto">Replace Anyway</button>
    </div>

    <script>
        let animationInstance = null;
        let lottieData = null;
        let lottieFileName = 'animation.json';
        let lastSelectedFiles = []; // For sequence replacement error handling

        // DOM Elements
        const lottieFileWrapper = document.getElementById('lottieFileWrapper');
        const lottieFileInput = document.getElementById('lottieFile');
        const lottiePreview = document.getElementById('lottiePreview');
        const assetListContainer = document.getElementById('assetListContainer');
        const assetList = document.getElementById('assetList');
        const noAssetsMessage = document.getElementById('noAssetsMessage');
        const downloadLottieButton = document.getElementById('downloadLottie');
        const downloadAllAssetsButton = document.getElementById('downloadAllAssetsButton');
        const scrollUpIndicator = document.getElementById('scrollUpIndicator');
        const scrollDownIndicator = document.getElementById('scrollDownIndicator');

        // Sequence Mode Elements
        const sequenceTooltip = document.getElementById('sequenceTooltip');
        const selectionCounterPill = document.getElementById('selectionCounterPill');
        const sequenceErrorTooltip = document.getElementById('sequenceErrorTooltip');
        const sequenceErrorText = document.getElementById('sequenceErrorText');
        const replaceAnywayButton = document.getElementById('replaceAnywayButton');
        const replaceSequenceButton = document.getElementById('replaceSequenceButton');
        const browseSequenceFilesButton = document.getElementById('browseSequenceFilesButton');
        const browseSequenceFilesButtonText = document.getElementById('browseSequenceFilesButtonText'); // Not used currently, but good to have
        const cancelSequenceButton = document.getElementById('cancelSequenceButton');
        const multipleFilesInput = document.getElementById('multipleFilesInput');
	const closeSequenceTooltipButton = document.getElementById('closeSequenceTooltipButton');

        // State Variables
        let isSequenceModeActive = false;
        let selectedAssetIndicesForSequence = []; // Stores original asset indices

        // SVG Icons for buttons
        const aspectRatioIconSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
            </svg>`;
        const downloadAssetIconSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
            </svg>`;

        /**
         * Processes the Lottie JSON data, initializes preview and asset list.
         * Stores original Lottie dimensions for each asset.
         */
        function processLottieData(data, fileNameFromMessage) {
            try {
                lottieData = data;
                if (fileNameFromMessage) lottieFileName = fileNameFromMessage;
                else if (lottieFileInput.files[0]) lottieFileName = lottieFileInput.files[0].name;

                if (!lottieData.assets) lottieData.assets = [];
                // Store original Lottie dimensions for each asset if they exist
                if (lottieData.assets) {
                    lottieData.assets.forEach(asset => {
                        if (asset.w && asset.h) {
                            asset.originalLottieW = asset.w;
                            asset.originalLottieH = asset.h;
                        }
                        // If originalLottieW/H are still undefined, it means the Lottie asset had no w/h.
                        // We can leave them undefined, or set to null/0 to be explicit.
                        // For now, leaving them undefined is fine as checks like `if (originalLottieSlotW && originalLottieSlotH)` handle it.
                    });
                }
                displayLottiePreview();
                listAssets();
                downloadLottieButton.disabled = false;
                const imageAssets = lottieData.assets.filter(asset => asset.p && typeof asset.p === 'string' && asset.p.startsWith('data:image/'));
                replaceSequenceButton.disabled = imageAssets.length === 0;
                downloadAllAssetsButton.disabled = imageAssets.length === 0;

            } catch (error) {
                console.error('Error processing Lottie data:', error);
                lottiePreview.innerHTML = '<p class="text-red-500">Error: Could not process Lottie data.</p>';
                assetList.innerHTML = '';
                noAssetsMessage.classList.remove('hidden');
                noAssetsMessage.textContent = 'Error loading assets.';
                downloadLottieButton.disabled = true;
                replaceSequenceButton.disabled = true;
                downloadAllAssetsButton.disabled = true;
                updateScrollIndicators();
            }
        }

        // Event listener for Lottie file input
        lottieFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        processLottieData(JSON.parse(e.target.result), file.name);
                    } catch (parseError) {
                        console.error('Error parsing Lottie JSON from file:', parseError);
                        lottiePreview.innerHTML = '<p class="text-red-500">Error: Could not parse Lottie file. Make sure it is a valid JSON.</p>';
                        assetList.innerHTML = ''; noAssetsMessage.classList.remove('hidden');
                        noAssetsMessage.textContent = 'Error loading assets from file.';
                        downloadLottieButton.disabled = true; replaceSequenceButton.disabled = true; downloadAllAssetsButton.disabled = true;
                        updateScrollIndicators();
                    }
                };
                reader.readAsText(file);
            } else if (file) {
                // Simple user feedback for wrong file type - replace with a modal if needed
                lottiePreview.innerHTML = `<p class="text-orange-500">Please select a valid JSON file. You selected: ${file.name} (${file.type})</p>`;
            }
        });

        // Listen for Lottie data from parent window (e.g., if embedded in another tool)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'lottieDataAssetTool' && event.data.lottieData) {
                processLottieData(event.data.lottieData, event.data.filename);
                lottieFileWrapper.classList.add('hidden-if-data-received'); // Hide file input if data comes from parent
            }
        });

        /**
         * Displays the Lottie animation preview.
         */
        function displayLottiePreview() {
            const previewElement = document.getElementById('lottiePreview');
            if (animationInstance) {
                animationInstance.destroy();
                animationInstance = null;
            }
            previewElement.innerHTML = ''; // Clear previous preview or message

            if (lottieData && lottieData.assets) {
                // Deep clone lottieData for the animation to prevent modification issues
                const animationDataForLottie = JSON.parse(JSON.stringify(lottieData));
                animationInstance = lottie.loadAnimation({
                    container: previewElement,
                    renderer: 'svg',
                    loop: true,
                    autoplay: true,
                    animationData: animationDataForLottie
                });
            } else {
                previewElement.textContent = 'No Lottie data to display or assets missing.';
            }
        }

        // Helper functions for asset info
        function getImageTypeFromBase64(base64String) {
            const match = base64String.match(/^data:image\/([^;]+);base64,/);
            return match && match[1] ? match[1].toUpperCase() : 'UNKNOWN';
        }

        function getMimeTypeFromBase64(base64String) {
            const match = base64String.match(/^data:([^;]+);base64,/);
            return match && match[1] ? match[1].toLowerCase() : 'application/octet-stream';
        }

        function getApproximateSizeFromBase64(base64String) {
            if (!base64String || !base64String.includes(',')) return "0 KB";
            const base64Data = base64String.substring(base64String.indexOf(',') + 1);
            const padding = (base64Data.endsWith('==')) ? 2 : (base64Data.endsWith('=')) ? 1 : 0;
            const len = base64Data.length;
            if (len === 0) return "0 KB";
            const kBytes = ((len * 3 / 4) - padding) / 1024;
            return kBytes < 1 ? `${kBytes.toFixed(2)} KB` : `${Math.round(kBytes)} KB`;
        }

        /**
         * Updates the display of a single asset card (image, dimensions, type, button states).
         * @param {number} assetIndex - The index of the asset in lottieData.assets.
         * @param {number} currentProcessedW - The current width of the asset as it is in Lottie data.
         * @param {number} currentProcessedH - The current height of the asset as it is in Lottie data.
         * @param {number} [rawUploadedImgW] - Natural width of the user's last uploaded image for this slot.
         * @param {number} [rawUploadedImgH] - Natural height of the user's last uploaded image for this slot.
         */
        function updateAssetCardDisplay(assetIndex, currentProcessedW, currentProcessedH, rawUploadedImgW, rawUploadedImgH) {
            const assetItem = document.querySelector(`.asset-item[data-asset-index='${assetIndex}']`);
            if (!assetItem) return;

            const rawUploadedBase64ForPreview = assetItem.dataset.lastUploadedRawBase64;
            const processedBase64ForLottie = lottieData.assets[assetIndex].p;
            const originalLottieSlotW = lottieData.assets[assetIndex].originalLottieW;
            const originalLottieSlotH = lottieData.assets[assetIndex].originalLottieH;

            const assetImage = assetItem.querySelector('.preview-image-container img');
            const extensionPill = assetItem.querySelector('.asset-id-pill');
            const assetDetailsSpan = assetItem.querySelector('.asset-info-text .asset-details');
            const aspectRatioButton = assetItem.querySelector('.icon-button[title*="Toggle Cover/Stretch"]');

            const existingWarning = assetDetailsSpan.querySelector('.size-mismatch-warning');
            if (existingWarning) existingWarning.remove();

            if (assetImage && rawUploadedBase64ForPreview) {
                assetImage.src = rawUploadedBase64ForPreview;
            }

            const finalMimeType = getMimeTypeFromBase64(processedBase64ForLottie);
            if (extensionPill) {
                extensionPill.textContent = finalMimeType.replace('image/', '').toUpperCase();
            }

            if (aspectRatioButton) {
                const isSVG = (finalMimeType === 'image/svg+xml');
                let disableButtonForRaster = false;
                if (!isSVG) {
                    if (originalLottieSlotW && originalLottieSlotH) { // If Lottie slot dimensions are defined
                        // Disable button if the RAW UPLOADED image's dimensions match the slot.
                        // rawUploadedImgW/H are passed after a new image is processed.
                        // If they are not passed (e.g. initial listAssets), this condition won't make it true unless we load raw image there too.
                        // For now, this relies on rawUploadedImgW/H being available from processAndApplyImage.
                        disableButtonForRaster = rawUploadedImgW && rawUploadedImgH &&
                                                 rawUploadedImgW === originalLottieSlotW &&
                                                 rawUploadedImgH === originalLottieSlotH;
                    } else {
                        // No Lottie slot dimensions defined for this asset. Cover/stretch is not applicable.
                        disableButtonForRaster = true;
                    }
                }

                aspectRatioButton.disabled = isSVG || disableButtonForRaster;
                aspectRatioButton.classList.toggle('opacity-50', aspectRatioButton.disabled);
                aspectRatioButton.classList.toggle('cursor-not-allowed', aspectRatioButton.disabled);

                if (aspectRatioButton.disabled) { // If button ends up disabled for any reason
                    aspectRatioButton.classList.remove('active'); // Reset to stretch (non-active)
                }
            }

            if (assetDetailsSpan && processedBase64ForLottie) {
                const imageSize = getApproximateSizeFromBase64(processedBase64ForLottie);
                let dimensionsText = (currentProcessedW && currentProcessedH) ? `${Math.round(currentProcessedW)}x${Math.round(currentProcessedH)} px` : 'Dimensions N/A';

                if (finalMimeType === 'image/svg+xml' &&
                    originalLottieSlotW && originalLottieSlotH &&
                    (Math.round(currentProcessedW) !== originalLottieSlotW || Math.round(currentProcessedH) !== originalLottieSlotH)) {
                    dimensionsText += ` <span class="size-mismatch-warning">(slot: ${originalLottieSlotW}x${originalLottieSlotH})</span>`;
                }
                assetDetailsSpan.innerHTML = `${imageSize} &bull; ${dimensionsText}`;
            }
        }


        /**
         * Lists all replaceable image assets from the Lottie data.
         */
        function listAssets() {
            assetList.innerHTML = '';
            let imageAssetsFound = false;
            selectedAssetIndicesForSequence = [];
            updateSelectionCounter();

            if (lottieData && lottieData.assets) {
                lottieData.assets.forEach((asset, index) => {
                    if (asset.p && typeof asset.p === 'string' && asset.p.startsWith('data:image/')) {
                        imageAssetsFound = true;
                        const assetItem = document.createElement('div');
                        assetItem.className = 'asset-item bg-white py-3 pl-3 pr-3 rounded-xl border border-gray-200 flex items-start sm:items-center gap-3';
                        assetItem.dataset.assetIndex = index;
                        assetItem.dataset.lastUploadedRawBase64 = asset.p;
                        const initialMimeType = getMimeTypeFromBase64(asset.p);
                        assetItem.dataset.originalFileType = initialMimeType;

                        const sequenceCheckboxContainer = document.createElement('div');
                        sequenceCheckboxContainer.className = 'sequence-checkbox-container hidden';
                        const sequenceCheckbox = document.createElement('input');
                        sequenceCheckbox.type = 'checkbox';
                        sequenceCheckbox.className = 'asset-sequence-checkbox';
                        sequenceCheckbox.dataset.assetIndex = index;
                        sequenceCheckbox.addEventListener('change', handleSequenceCheckboxChange);
                        sequenceCheckboxContainer.appendChild(sequenceCheckbox);
                        assetItem.appendChild(sequenceCheckboxContainer);

                        const assetContentWrapper = document.createElement('div');
                        assetContentWrapper.className = 'flex-grow flex flex-col sm:flex-row items-start sm:items-center gap-3 w-full';

                        const assetDetailsContainer = document.createElement('div');
                        assetDetailsContainer.className = 'flex-grow w-full text-center sm:text-left';
                        const assetInfoDisplay = document.createElement('div');
                        assetInfoDisplay.className = 'asset-info-text mt-1';
                        let assetName = asset.id || `Asset ${index + 1}`;
                        if (assetName.startsWith('data:image')) assetName = `Asset ${index + 1}`;
                        if (assetName.length > 30) assetName = assetName.substring(0, 27) + '...';

                        const initialImageTypeForPill = getImageTypeFromBase64(asset.p);
                        const initialImageSize = getApproximateSizeFromBase64(asset.p);
                        let initialDimensionsText = (asset.w && asset.h) ? `${Math.round(asset.w)}x${Math.round(asset.h)} px` : 'Dimensions N/A';

                        if (initialMimeType === 'image/svg+xml' &&
                            asset.originalLottieW && asset.originalLottieH &&
                            (Math.round(asset.w) !== asset.originalLottieW || Math.round(asset.h) !== asset.originalLottieH)) {
                            initialDimensionsText += ` <span class="size-mismatch-warning">(slot: ${asset.originalLottieW}x${asset.originalLottieH})</span>`;
                        }
                        assetInfoDisplay.innerHTML = `<span class="asset-name">${assetName}</span><span class="asset-details">${initialImageSize} &bull; ${initialDimensionsText}</span>`;
                        assetDetailsContainer.appendChild(assetInfoDisplay);

                        const controlsButtonContainer = document.createElement('div');
                        controlsButtonContainer.className = 'asset-controls-container justify-center sm:justify-start';

                        const aspectRatioButton = document.createElement('button');
                        aspectRatioButton.className = 'icon-button';
                        aspectRatioButton.title = 'Toggle Cover/Stretch (Cover when active)';
                        aspectRatioButton.innerHTML = aspectRatioIconSVG;

                        const isSVGInitial = initialMimeType === 'image/svg+xml';
                        let disableButtonForRasterInitial = false;
                        if (!isSVGInitial) {
                            if (asset.originalLottieW && asset.originalLottieH) { // Slot dimensions defined
                                // Disable if current Lottie image dimensions match the slot dimensions
                                // This assumes asset.w/h are the natural dimensions of the image currently in Lottie
                                // or have been processed to match the slot.
                                disableButtonForRasterInitial = asset.w && asset.h &&
                                                                Math.round(asset.w) === asset.originalLottieW &&
                                                                Math.round(asset.h) === asset.originalLottieH;
                            } else { // No slot dimensions defined for this asset in Lottie
                                disableButtonForRasterInitial = true;
                            }
                        }
                        aspectRatioButton.disabled = isSVGInitial || disableButtonForRasterInitial;
                        aspectRatioButton.classList.toggle('active', false);
                        if (aspectRatioButton.disabled) {
                             aspectRatioButton.classList.remove('active');
                             aspectRatioButton.classList.add('opacity-50', 'cursor-not-allowed');
                        }


                        aspectRatioButton.addEventListener('click', async () => {
                            if (aspectRatioButton.disabled) return;

                            const currentAssetItem = aspectRatioButton.closest('.asset-item');
                            const assetIdx = parseInt(currentAssetItem.dataset.assetIndex);
                            const newCoverModeActiveState = aspectRatioButton.classList.toggle('active');
                            const newShouldStretchState = !newCoverModeActiveState;

                            const base64ToProcessForToggle = currentAssetItem.dataset.lastUploadedRawBase64;
                            const mimeTypeForProcessing = currentAssetItem.dataset.originalFileType || getMimeTypeFromBase64(base64ToProcessForToggle);

                            if (isSequenceModeActive && selectedAssetIndicesForSequence.includes(assetIdx)) {
                                const promises = selectedAssetIndicesForSequence.map(idxInSequence => {
                                    const itemInSequence = document.querySelector(`.asset-item[data-asset-index='${idxInSequence}']`);
                                    const assetDataInSequence = lottieData.assets[idxInSequence];
                                    const btnInSequence = itemInSequence ? itemInSequence.querySelector('.icon-button[title*="Toggle Cover/Stretch"]') : null;

                                    if (itemInSequence && assetDataInSequence && btnInSequence && !btnInSequence.disabled) {
                                        btnInSequence.classList.toggle('active', newCoverModeActiveState);
                                        const rawBase64ForSeqItem = itemInSequence.dataset.lastUploadedRawBase64;
                                        const mimeTypeForSeqItem = itemInSequence.dataset.originalFileType || getMimeTypeFromBase64(rawBase64ForSeqItem);
                                        const imgElementForList = itemInSequence.querySelector('.preview-image-container img');
                                        if (rawBase64ForSeqItem && imgElementForList) {
                                            return processAndApplyImage(idxInSequence, rawBase64ForSeqItem, imgElementForList, newShouldStretchState, mimeTypeForSeqItem, true);
                                        }
                                    }
                                    return Promise.resolve();
                                });
                                try { await Promise.all(promises); }
                                catch (error) { console.error(`Error applying toggle to sequence: ${error.message || error}`); }
                                displayLottiePreview();
                            } else {
                                if (base64ToProcessForToggle && lottieData.assets[assetIdx]) {
                                    const assetImageElementInList = currentAssetItem.querySelector('.preview-image-container img');
                                    if (assetImageElementInList) {
                                         try {
                                            await processAndApplyImage(assetIdx, base64ToProcessForToggle, assetImageElementInList, newShouldStretchState, mimeTypeForProcessing);
                                         } catch (error) {
                                            console.error(`Error applying toggle to asset ${assetIdx + 1}: ${error.message || error}`);
                                         }
                                    }
                                }
                            }
                        });
                        controlsButtonContainer.appendChild(aspectRatioButton);

                        const downloadAssetButton = document.createElement('button');
                        downloadAssetButton.className = 'icon-button';
                        downloadAssetButton.title = 'Download this asset';
                        downloadAssetButton.innerHTML = downloadAssetIconSVG;
                        // Inside the listAssets function, when creating the downloadAssetButton
                        // 'index' here refers to the originalAssetIndex of the asset card being created.
                        const assetIndexOfClickedCard = index; // Store it for clarity if needed in single download

                        downloadAssetButton.addEventListener('click', async () => { // Made async for await zip.generateAsync
                            if (isSequenceModeActive && selectedAssetIndicesForSequence.length > 0) {
                                // --- NEW: ZIP SELECTED ASSETS LOGIC ---
                                const zip = new JSZip();
                                const baseLottieName = lottieFileName.replace(/\.json$/i, '');
                                const zipFileName = `${baseLottieName}_selected_assets.zip`;

                                // 1. Get all filterable image assets from lottieData in their original order
                                //    to determine correct global prefixes.
                                const allImageAssetsInOrder = lottieData.assets
                                    .map((asset, originalIdx) => ({ asset, originalAssetIndex: originalIdx }))
                                    .filter(item => item.asset.p && typeof item.asset.p === 'string' && item.asset.p.startsWith('data:image/'));

                                // 2. Iterate through the *selected* asset indices
                                selectedAssetIndicesForSequence.forEach(selectedAssetOriginalIndex => {
                                    // Find this selected asset in our ordered list of all image assets
                                    // to determine its global sequence prefix.
                                    const globalAssetInfo = allImageAssetsInOrder.find(imgAsset => imgAsset.originalAssetIndex === selectedAssetOriginalIndex);

                                    if (globalAssetInfo) {
                                        const asset = globalAssetInfo.asset;
                                        // This is the 0-based index in the full list of actual image assets
                                        const globalOrderIndex = allImageAssetsInOrder.indexOf(globalAssetInfo);
                                        const prefix = globalOrderIndex + 1; // 1-based prefix for filename

                                        const base64Data = asset.p.substring(asset.p.indexOf(',') + 1);
                                        const mimeType = getMimeTypeFromBase64(asset.p); //
                                        let extension = mimeType.split('/')[1] || 'png';
                                        if (extension === 'svg+xml') extension = 'svg';
                                        if (extension === 'jpeg') extension = 'jpg';

                                        // Use asset.id or asset.u if available, otherwise a generic name
                                        let filenamePart = asset.id || asset.u || `asset_${selectedAssetOriginalIndex}`;
                                        // Clean up filenamePart (remove paths, existing extensions)
                                        if (filenamePart.includes('/')) filenamePart = filenamePart.substring(filenamePart.lastIndexOf('/') + 1);
                                        if (filenamePart.includes('\\')) filenamePart = filenamePart.substring(filenamePart.lastIndexOf('\\') + 1);
                                        filenamePart = filenamePart.replace(/\.[^/.]+$/, "");

                                        const prefixedFilename = `${prefix}-${filenamePart}.${extension}`;
                                        zip.file(prefixedFilename, base64Data, {base64: true});
                                    }
                                });

                                if (Object.keys(zip.files).length > 0) {
                                    try {
                                        const zipBlob = await zip.generateAsync({type:"blob"});
                                        const link = document.createElement('a');
                                        link.href = URL.createObjectURL(zipBlob);
                                        link.download = zipFileName;
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                        URL.revokeObjectURL(link.href);
                                    } catch (error) {
                                        console.error("Error generating selected assets ZIP file:", error);
                                    }
                                } else {
                                    // Optionally, provide feedback if no files were added (e.g., if selection was cleared unexpectedly)
                                    console.warn("No selected assets were found to include in the ZIP.");
                                }
                                return; // Crucial: prevent falling through to single asset download
                            }

                            // --- ORIGINAL SINGLE ASSET DOWNLOAD LOGIC ---
                            // This code runs if not in sequence mode or if no assets are selected.
                            const processedBase64ToDownload = lottieData.assets[assetIndexOfClickedCard].p;
                            const idForName = lottieData.assets[assetIndexOfClickedCard].id || `asset_${assetIndexOfClickedCard}`;
                            let typeForName = getImageTypeFromBase64(processedBase64ToDownload).toLowerCase() || 'png'; //

                            if (typeForName === 'svg+xml') {
                                typeForName = 'svg';
                            }

                            if (processedBase64ToDownload) {
                                const link = document.createElement('a');
                                link.href = processedBase64ToDownload;
                                link.download = `${idForName}.${typeForName}`;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(link.href);
                            }
                        });
                        controlsButtonContainer.appendChild(downloadAssetButton);
                        assetDetailsContainer.appendChild(controlsButtonContainer);
                        assetContentWrapper.appendChild(assetDetailsContainer);

                        const imagePreviewContainer = document.createElement('div');
                        imagePreviewContainer.className = 'preview-image-container flex-shrink-0 text-center sm:text-right';
                        imagePreviewContainer.title = 'Click or Drag/Drop to replace asset';
                        const assetImage = document.createElement('img');
                        assetImage.src = asset.p;
                        assetImage.alt = `Preview for ${assetName}`;
                        assetImage.className = 'preview-image-max-height';
                        const extensionPill = document.createElement('div');
                        extensionPill.className = 'asset-id-pill';
                        extensionPill.textContent = initialImageTypeForPill;
                        imagePreviewContainer.appendChild(extensionPill);
                        imagePreviewContainer.appendChild(assetImage);
                        assetContentWrapper.appendChild(imagePreviewContainer);

                        const fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.accept = 'image/*';
                        fileInput.className = 'hidden-file-input';
                        fileInput.id = `fileInput-${index}`;

                        imagePreviewContainer.addEventListener('click', () => { if (!isSequenceModeActive) fileInput.click(); });
                        imagePreviewContainer.addEventListener('dragover', (e) => { if (!isSequenceModeActive) { e.preventDefault(); e.stopPropagation(); imagePreviewContainer.classList.add('drag-over'); }});
                        imagePreviewContainer.addEventListener('dragleave', (e) => { if (!isSequenceModeActive) { e.preventDefault(); e.stopPropagation(); imagePreviewContainer.classList.remove('drag-over'); }});
                        imagePreviewContainer.addEventListener('drop', (e) => {
                            if (!isSequenceModeActive) {
                                e.preventDefault(); e.stopPropagation(); imagePreviewContainer.classList.remove('drag-over');
                                const files = e.dataTransfer.files;
                                if (files.length > 0) {
                                    const btn = assetItem.querySelector('.icon-button[title*="Toggle Cover/Stretch"]');
                                    const stretchMode = btn.disabled ? true : !btn.classList.contains('active');
                                    handleAssetReplacement(index, files[0], assetImage, stretchMode);
                                }
                            }
                        });
                        fileInput.addEventListener('change', (e) => {
                            if (e.target.files[0]) {
                                const btn = assetItem.querySelector('.icon-button[title*="Toggle Cover/Stretch"]');
                                const stretchMode = btn.disabled ? true : !btn.classList.contains('active');
                                handleAssetReplacement(index, e.target.files[0], assetImage, stretchMode);
                            }
                        });

                        assetItem.appendChild(assetContentWrapper);
                        assetItem.appendChild(fileInput);
                        assetList.appendChild(assetItem);
                    }
                });
            }
            noAssetsMessage.classList.toggle('hidden', imageAssetsFound);
            if (!imageAssetsFound) noAssetsMessage.textContent = 'No replaceable image assets found.';
            replaceSequenceButton.disabled = !imageAssetsFound;
            downloadAllAssetsButton.disabled = !imageAssetsFound;
            if (!imageAssetsFound) setSequenceMode(false);
            updateScrollIndicators();
        }

        // --- Sequence Mode Logic ---
        function updateSelectionCounter() {
            selectionCounterPill.textContent = `${selectedAssetIndicesForSequence.length} Selected`;
        }

        function handleSequenceCheckboxChange(event) {
            const changedCheckbox = event.target;
            // const assetItem = changedCheckbox.closest('.asset-item');

            const allCheckboxes = Array.from(assetList.querySelectorAll('.asset-sequence-checkbox'));
            let currentlyCheckedOriginalIndices = [];
            allCheckboxes.forEach(cb => { if (cb.checked) currentlyCheckedOriginalIndices.push(parseInt(cb.dataset.assetIndex)); });

            document.querySelectorAll('.asset-item.asset-item-selected').forEach(item => item.classList.remove('asset-item-selected'));
            allCheckboxes.forEach(cb => cb.checked = false);

            if (currentlyCheckedOriginalIndices.length === 0) {
                selectedAssetIndicesForSequence = [];
            } else if (currentlyCheckedOriginalIndices.length === 1) {
                selectedAssetIndicesForSequence = [...currentlyCheckedOriginalIndices];
                const singleItem = document.querySelector(`.asset-item[data-asset-index='${selectedAssetIndicesForSequence[0]}']`);
                if (singleItem) {
                    singleItem.classList.add('asset-item-selected');
                    singleItem.querySelector('.asset-sequence-checkbox').checked = true;
                }
            } else {
                const minIdx = Math.min(...currentlyCheckedOriginalIndices);
                const maxIdx = Math.max(...currentlyCheckedOriginalIndices);

                const allLottieImgAssets = lottieData.assets
                    .map((asset, originalAssetIndex) => ({ asset, originalAssetIndex }))
                    .filter(item => item.asset.p && item.asset.p.startsWith('data:image/'));

                let finalSelectedOriginalIndices = [];
                let inRange = false;
                for (const { originalAssetIndex } of allLottieImgAssets) {
                    if (originalAssetIndex === minIdx) inRange = true;
                    if (inRange) {
                        finalSelectedOriginalIndices.push(originalAssetIndex);
                        const itemCard = document.querySelector(`.asset-item[data-asset-index='${originalAssetIndex}']`);
                        if (itemCard) {
                            itemCard.classList.add('asset-item-selected');
                            const cb = itemCard.querySelector('.asset-sequence-checkbox');
                            if (cb) cb.checked = true;
                        }
                    }
                    if (originalAssetIndex === maxIdx) break;
                }
                selectedAssetIndicesForSequence = finalSelectedOriginalIndices.sort((a, b) => a - b);
            }
            updateSelectionCounter();
            browseSequenceFilesButton.disabled = selectedAssetIndicesForSequence.length === 0;
        }

        function setSequenceMode(active) {
            isSequenceModeActive = active;
            replaceSequenceButton.classList.toggle('hidden', active);
            browseSequenceFilesButton.classList.toggle('hidden', !active);
            cancelSequenceButton.classList.toggle('hidden', !active);
            cancelSequenceButton.disabled = false;

            const checkboxContainers = assetList.querySelectorAll('.sequence-checkbox-container');
            checkboxContainers.forEach(container => {
                container.classList.toggle('hidden', !active);
                container.classList.toggle('flex', active);
                if (!active) {
                    const checkbox = container.querySelector('.asset-sequence-checkbox');
                    if (checkbox) checkbox.checked = false;
                    const assetItem = container.closest('.asset-item');
                    if (assetItem) assetItem.classList.remove('asset-item-selected');
                }
            });

            sequenceTooltip.classList.toggle('visible', active);
            sequenceErrorTooltip.classList.remove('visible');

            if (!active) {
                selectedAssetIndicesForSequence = [];
                updateSelectionCounter();
                browseSequenceFilesButton.disabled = true;
            } else {
                 browseSequenceFilesButton.disabled = selectedAssetIndicesForSequence.length === 0;
            }
        }

        replaceSequenceButton.addEventListener('click', () => setSequenceMode(true));
        cancelSequenceButton.addEventListener('click', () => setSequenceMode(false));

        browseSequenceFilesButton.addEventListener('click', () => {
            if (selectedAssetIndicesForSequence.length > 0) {
                sequenceTooltip.classList.remove('visible');
                multipleFilesInput.click();
            }
        });

        async function performReplacement(filesToReplaceWith, assetsToReplaceIndices) {
            browseSequenceFilesButton.disabled = true;
            cancelSequenceButton.disabled = true;

            const numFiles = filesToReplaceWith.length;
            const numAssets = assetsToReplaceIndices.length;
            const limit = Math.min(numFiles, numAssets);

            for (let i = 0; i < limit; i++) {
                const assetIndex = assetsToReplaceIndices[i];
                const file = filesToReplaceWith[i];
                const assetItem = document.querySelector(`.asset-item[data-asset-index='${assetIndex}']`);
                const assetImageElementInList = assetItem ? assetItem.querySelector('.preview-image-container img') : null;
                const aspectRatioButton = assetItem ? assetItem.querySelector('.icon-button[title*="Toggle Cover/Stretch"]') : null;
                const shouldStretch = aspectRatioButton ? (aspectRatioButton.disabled ? true : !aspectRatioButton.classList.contains('active')) : true;

                try {
                    const newImageRawBase64 = await new Promise((resolveFileRead, rejectFileRead) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolveFileRead(e.target.result);
                        reader.onerror = (err) => rejectFileRead(err);
                        reader.readAsDataURL(file);
                    });

                    if (assetItem) {
                        assetItem.dataset.lastUploadedRawBase64 = newImageRawBase64;
                        assetItem.dataset.originalFileType = file.type;
                    }
                    await processAndApplyImage(assetIndex, newImageRawBase64, assetImageElementInList, shouldStretch, file.type, true);
                } catch (error) {
                    console.error(`Failed to process file for asset ${assetIndex + 1}. Skipping. Error: ${error.message || error}`);
                }
            }

            displayLottiePreview();
            setSequenceMode(false);
            multipleFilesInput.value = '';
            lastSelectedFiles = [];
        }

        multipleFilesInput.addEventListener('change', async (event) => {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            lastSelectedFiles = Array.from(files);
            sequenceErrorTooltip.classList.remove('visible');

            if (files.length !== selectedAssetIndicesForSequence.length) {
                sequenceErrorText.textContent = `You selected ${files.length} files but have ${selectedAssetIndicesForSequence.length} assets marked for replacement.`;
                sequenceErrorTooltip.classList.add('visible');
                return;
            }
            await performReplacement(lastSelectedFiles, selectedAssetIndicesForSequence.sort((a, b) => a - b));
        });

        replaceAnywayButton.addEventListener('click', async () => {
            sequenceErrorTooltip.classList.remove('visible');
            if (lastSelectedFiles.length > 0 && selectedAssetIndicesForSequence.length > 0) {
                await performReplacement(lastSelectedFiles, selectedAssetIndicesForSequence.sort((a, b) => a - b));
            }
        });

        async function handleAssetReplacement(assetIndex, newFile, assetImageElementInList, shouldStretch) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const newImageRawBase64 = e.target.result;
                const assetItemElement = document.querySelector(`.asset-item[data-asset-index='${assetIndex}']`);
                if (assetItemElement) {
                    assetItemElement.dataset.lastUploadedRawBase64 = newImageRawBase64;
                    assetItemElement.dataset.originalFileType = newFile.type;
                }
                try {
                    await processAndApplyImage(assetIndex, newImageRawBase64, assetImageElementInList, shouldStretch, newFile.type);
                } catch (error) {
                    console.error(`Error processing image for asset ${assetIndex + 1}: ${error.message || error}`);
                }
            };
            reader.onerror = (error) => {
                console.error('Error reading new asset file:', error);
            };
            reader.readAsDataURL(newFile);
        }

        /**
         * Processes an image (resize, crop, format conversion) and applies it to the Lottie data and UI.
         * @param {number} assetIndex - The original index of the asset in lottieData.assets.
         * @param {string} imageBase64ToProcess - The base64 string of the image to process.
         * @param {HTMLImageElement} assetImageElementInList - The img element in the asset card (can be null if not updating UI directly).
         * @param {boolean} shouldStretch - True to stretch, false to cover (if resizing).
         * @param {string} originalUploadedMimeType - MIME type of the originally uploaded file (e.g., 'image/jpeg', 'image/svg+xml').
         * @param {boolean} [isBulkUpdate=false] - If true, skips immediate Lottie preview refresh.
         */
        function processAndApplyImage(assetIndex, imageBase64ToProcess, assetImageElementInList, shouldStretch, originalUploadedMimeType, isBulkUpdate = false) {
            return new Promise((resolve, reject) => {
                const originalAsset = lottieData.assets[assetIndex];
                if (!originalAsset) {
                    console.error(`Asset ${assetIndex} not found in Lottie data.`);
                    reject(new Error(`Asset ${assetIndex} not found.`));
                    return;
                }

                const originalLottieW = originalAsset.originalLottieW;
                const originalLottieH = originalAsset.originalLottieH;

                const img = new Image();
                img.onload = () => {
                    let finalBase64 = imageBase64ToProcess;
                    let finalLottieAssetW = img.width;
                    let finalLottieAssetH = img.height;
                    const rawUploadedImgW = img.width; // Capture raw dimensions
                    const rawUploadedImgH = img.height;

                    const isUploadedSVG = originalUploadedMimeType === 'image/svg+xml';
                    const isRasterExactMatchWithSlot = !isUploadedSVG &&
                                                   originalLottieW && originalLottieH &&
                                                   rawUploadedImgW === originalLottieW &&
                                                   rawUploadedImgH === originalLottieH;

                    if (isUploadedSVG) {
                        console.log(`Asset ${assetIndex}: SVG detected. Embedding directly. Dimensions: ${rawUploadedImgW}x${rawUploadedImgH}`);
                        finalBase64 = imageBase64ToProcess;
                        finalLottieAssetW = rawUploadedImgW;
                        finalLottieAssetH = rawUploadedImgH;
                    } else if (isRasterExactMatchWithSlot) {
                        console.log(`Asset ${assetIndex}: Raster exact match with Lottie slot (${originalLottieW}x${originalLottieH}). Bypassing resize/crop.`);
                        finalLottieAssetW = originalLottieW;
                        finalLottieAssetH = originalLottieH;

                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = finalLottieAssetW;
                        tempCanvas.height = finalLottieAssetH;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);

                        if (originalUploadedMimeType === 'image/jpeg') {
                            try { finalBase64 = tempCanvas.toDataURL('image/jpeg', 0.92); }
                            catch (e) { console.error("Error re-encoding exact match JPEG:", e); finalBase64 = imageBase64ToProcess; }
                        } else if (!imageBase64ToProcess.startsWith('data:image/png')) {
                            try { finalBase64 = tempCanvas.toDataURL('image/png'); }
                            catch (e) { console.error("Error converting exact match to PNG:", e); finalBase64 = imageBase64ToProcess; }
                        } else {
                            finalBase64 = imageBase64ToProcess;
                        }
                    } else if (originalLottieW && originalLottieH) { // Raster, but NOT exact match with slot, AND slot dimensions exist
                        console.log(`Asset ${assetIndex}: Raster, processing required. Uploaded: ${rawUploadedImgW}x${rawUploadedImgH}, Target Slot: ${originalLottieW}x${originalLottieH}. Stretch: ${shouldStretch}`);
                        finalLottieAssetW = originalLottieW;
                        finalLottieAssetH = originalLottieH;

                        const canvas = document.createElement('canvas');
                        canvas.width = originalLottieW;
                        canvas.height = originalLottieH;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        if (!shouldStretch) { // COVER
                            const targetAspectRatio = canvas.width / canvas.height;
                            const sourceAspectRatio = rawUploadedImgW / rawUploadedImgH;
                            let sx = 0, sy = 0, sWidth = rawUploadedImgW, sHeight = rawUploadedImgH;

                            if (sourceAspectRatio > targetAspectRatio) {
                                sWidth = rawUploadedImgH * targetAspectRatio;
                                sx = (rawUploadedImgW - sWidth) / 2;
                            } else if (sourceAspectRatio < targetAspectRatio) {
                                sHeight = rawUploadedImgW / targetAspectRatio;
                                sy = (rawUploadedImgH - sHeight) / 2;
                            }
                            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);
                        } else { // STRETCH
                            ctx.drawImage(img, 0, 0, originalLottieW, originalLottieH);
                        }

                        try {
                            let outputMimeType = 'image/png';
                            let quality;
                            if (originalUploadedMimeType === 'image/jpeg') {
                                outputMimeType = 'image/jpeg';
                                quality = 0.92;
                            }
                            finalBase64 = quality !== undefined ? canvas.toDataURL(outputMimeType, quality) : canvas.toDataURL(outputMimeType);
                        } catch (cvError) {
                            console.error("Canvas toDataURL error during resize/crop:", cvError);
                            try { finalBase64 = canvas.toDataURL('image/png'); }
                            catch (pngError) {
                                console.error("PNG fallback error:", pngError);
                                finalBase64 = imageBase64ToProcess;
                                finalLottieAssetW = rawUploadedImgW; // Fallback to raw dimensions
                                finalLottieAssetH = rawUploadedImgH;
                            }
                        }
                    } else { // Raster, but NO originalLottieW/H defined in slot. Use image as-is.
                        console.warn(`Asset ${assetIndex}: Raster, but no original Lottie slot w/h. Using uploaded image dimensions: ${rawUploadedImgW}x${rawUploadedImgH}.`);
                        finalLottieAssetW = rawUploadedImgW;
                        finalLottieAssetH = rawUploadedImgH;

                        const tempCanvas = document.createElement('canvas'); // Still ensure PNG/JPEG
                        tempCanvas.width = finalLottieAssetW;
                        tempCanvas.height = finalLottieAssetH;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        if (originalUploadedMimeType === 'image/jpeg') {
                            try { finalBase64 = tempCanvas.toDataURL('image/jpeg', 0.92); }
                            catch (e) { finalBase64 = imageBase64ToProcess; }
                        } else if (!imageBase64ToProcess.startsWith('data:image/png')) {
                            try { finalBase64 = tempCanvas.toDataURL('image/png'); }
                            catch (e) { finalBase64 = imageBase64ToProcess; }
                        } else {
                            finalBase64 = imageBase64ToProcess;
                        }
                    }

                    lottieData.assets[assetIndex].p = finalBase64;
                    lottieData.assets[assetIndex].w = Math.round(finalLottieAssetW);
                    lottieData.assets[assetIndex].h = Math.round(finalLottieAssetH);

                    // Pass rawUploadedImgW/H to updateAssetCardDisplay for its button logic
                    updateAssetCardDisplay(assetIndex, Math.round(finalLottieAssetW), Math.round(finalLottieAssetH), rawUploadedImgW, rawUploadedImgH);

                    if (!isBulkUpdate) {
                        displayLottiePreview();
                    }
                    resolve();
                };
                img.onerror = () => {
                     console.error(`Could not load image from base64 for processing (asset ${assetIndex}).`);
                     lottieData.assets[assetIndex].p = imageBase64ToProcess;
                     const tempImgErr = new Image();
                     tempImgErr.onload = () => {
                        const wError = originalLottieW || tempImgErr.width;
                        const hError = originalLottieH || tempImgErr.height;
                        lottieData.assets[assetIndex].w = wError;
                        lottieData.assets[assetIndex].h = hError;
                        // When calling updateAssetCardDisplay on error, we pass the error image's dimensions as "raw"
                        updateAssetCardDisplay(assetIndex, wError, hError, tempImgErr.width, tempImgErr.height);
                        if (!isBulkUpdate) displayLottiePreview();
                        resolve();
                     }
                     tempImgErr.onerror = () => {
                        console.error('Fallback image load also failed for asset ' + assetIndex);
                        const wCritical = originalLottieW || 0;
                        const hCritical = originalLottieH || 0;
                        lottieData.assets[assetIndex].w = wCritical;
                        lottieData.assets[assetIndex].h = hCritical;
                        // Pass 0,0 or undefined for raw dimensions if truly unknown
                        updateAssetCardDisplay(assetIndex, wCritical, hCritical, undefined, undefined);
                        if (!isBulkUpdate) displayLottiePreview();
                        reject(new Error('Image load and fallback failed for asset ' + assetIndex));
                     }
                     tempImgErr.src = imageBase64ToProcess;
                };
                img.src = imageBase64ToProcess;
            });
        }


        // --- Download Logic ---
        downloadLottieButton.addEventListener('click', () => {
            if (!lottieData) { return; }
            try {
                const baseName = lottieFileName.replace(/\.json$/i, '');
                const dlFilename = `${baseName}_modified.json`;
                const dataToDownload = JSON.parse(JSON.stringify(lottieData));

                if (dataToDownload.assets) {
                    dataToDownload.assets.forEach(asset => {
                        delete asset.originalLottieW;
                        delete asset.originalLottieH;
                    });
                }

                const blob = new Blob([JSON.stringify(dataToDownload, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = dlFilename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error preparing Lottie for download:', error);
            }
        });

        downloadAllAssetsButton.addEventListener('click', async () => {
                    if (!lottieData || !lottieData.assets || lottieData.assets.length === 0) {
                        return;
                    }

                    const zip = new JSZip();
                    const imageAssets = lottieData.assets.filter(asset => asset.p && typeof asset.p === 'string' && asset.p.startsWith('data:image/'));

                    if (imageAssets.length === 0) {
                        return;
                    }

                    imageAssets.forEach((asset, index) => { // 'index' here is 0-based for the imageAssets array
                        const base64Data = asset.p.substring(asset.p.indexOf(',') + 1);
                        const mimeType = getMimeTypeFromBase64(asset.p);
                        let extension = mimeType.split('/')[1] || 'png';
                        if (extension === 'svg+xml') extension = 'svg';
                        if (extension === 'jpeg') extension = 'jpg';

                        let filenamePart = asset.id || asset.u || `asset_${index}`; // Original filename part
                        if (filenamePart.includes('/')) filenamePart = filenamePart.substring(filenamePart.lastIndexOf('/') + 1);
                        if (filenamePart.includes('\\')) filenamePart = filenamePart.substring(filenamePart.lastIndexOf('\\') + 1);
                        filenamePart = filenamePart.replace(/\.[^/.]+$/, "");

                        // Add the prefix here. 'index + 1' makes it 1-based.
                        const prefixedFilename = `${index + 1}-${filenamePart}.${extension}`; // MODIFIED LINE

                        zip.file(prefixedFilename, base64Data, {base64: true}); // Use prefixedFilename
                    });

                    try {
                        const zipBlob = await zip.generateAsync({type:"blob"});
                        const zipFileName = lottieFileName.replace(/\.json$/i, '_assets.zip') || 'lottie_assets.zip';
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(zipBlob);
                        link.download = zipFileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    } catch (error) {
                        console.error("Error generating ZIP file:", error);
                    }
                });


        // --- UI Helpers (Scroll Indicators) ---
        function updateScrollIndicators() {
            const el = assetListContainer;
            const scrollThreshold = 10;
            if (el.scrollHeight > el.clientHeight) {
                scrollDownIndicator.classList.toggle('visible', el.scrollTop + el.clientHeight < el.scrollHeight - scrollThreshold);
                scrollUpIndicator.classList.toggle('visible', el.scrollTop > scrollThreshold);
            } else {
                scrollUpIndicator.classList.remove('visible');
                scrollDownIndicator.classList.remove('visible');
            }
        }

        assetListContainer.addEventListener('scroll', updateScrollIndicators);
        window.addEventListener('resize', updateScrollIndicators);
        scrollUpIndicator.addEventListener('click', () => assetListContainer.scrollTo({ top: 0, behavior: 'smooth' }));
        scrollDownIndicator.addEventListener('click', () => assetListContainer.scrollTo({ top: assetListContainer.scrollHeight, behavior: 'smooth' }));
	closeSequenceTooltipButton.addEventListener('click', () => {
   cancelSequenceButton.click(); // This function already handles hiding the tooltip
});
        // Initial setup
        updateScrollIndicators();
        setSequenceMode(false);
        replaceSequenceButton.disabled = true;
        downloadAllAssetsButton.disabled = true;
    </script>
</body>
</html>
